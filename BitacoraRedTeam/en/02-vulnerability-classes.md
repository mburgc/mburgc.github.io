# Chapter 2: Vulnerability Classes

This chapter documents the main classes of vulnerabilities found in operating systems and applications, with a particular emphasis on the context of kernel and low-level systems. Each entry includes a technical description, real-world case studies, impact, and applicable mitigations.

**Objective:** To understand the primary classes of memory corruption vulnerabilities and their real-world impact.

**Recommended Reading Resources:**
- “The Art of Software Security Assessment” by Mark Dowd, John McDonald, Justin Schuh - Chapter 5: Memory Corruption
- [Memory Corruption: Examples, Impact, and 4 Ways to Prevent It](https://en.wikipedia.org/wiki/Memory_corruption)
- [Microsoft Security Research: Memory Safety](https://www.zdnet.com/article/microsoft-70-of-all-security-bugs-are-memory-safety-issues/)
- [Google Project Zero Blog - Recent findings on memory corruption](https://googleprojectzero.blogspot.com/2022/04/the-more-you-know-more-you-know-you.html)

## 2.1. 1.1 Fundamentals of Memory Corruption

Memory corruption continues to be one of the most critical and prevalent classes of vulnerabilities in software written in C/C++. Despite decades of security research, these bugs persist due to the inherent complexity of manual memory management.

**Key Concepts:**
- **What is memory corruption and why does it matter?** Memory corruption occurs when a program modifies memory in unintended ways, allowing attackers to alter the program's state and potentially gain execution control.
- **Stack:** A memory region for local variables and return addresses. Its LIFO (Last-In-First-Out) structure makes it vulnerable to overflows that can overwrite return addresses.
- **Heap:** A dynamic memory region managed by the allocator (malloc/free). Heap metadata and adjacent objects can be corrupted by overflows.
- **Memory Lifecycle:** Allocation → Usage → Deallocation. Errors in any phase can lead to vulnerabilities.

### 2.1.1. 1.1.1 Stack Buffer Overflow

**General Description**

A stack buffer overflow occurs when a program writes more data to a buffer located on the stack than it can hold. This causes the overwriting of adjacent memory, including critical data such as return addresses, potentially allowing the program's execution to be redirected.

**Attack Mechanics:**

```
      STACK LAYOUT
+-------------------------+
|   [High Addresses]      |
|   +-----------------+   |
|   | Return          | <--- Overwritten by attacker
|   | Address         |   |
|   +-----------------+   |
|   | Saved Frame     | <--- Also corrupted
|   | Pointer         |   |
|   +-----------------+   |
|   | Local           |   |
|   | Variables       |   |
|   +-----------------+   |
|   | Buffer[64]      | <--- Overflow occurs here
|   |                 |   |
|   +-----------------+   |
|   [Low Addresses]       |
+-------------------------+
```

**Case Study: CVE-2024-27130 — QNAP QTS/QuTS Hero**

| Field             | Detail                                       |
| ----------------- | --------------------------------------------- |
| Affected Product  | QNAP QTS and QuTS hero                          |
| Type              | Stack Buffer Overflow                         |
| Vector            | Web administration interface                |
| Severity          | Critical                                      |
| PoC Available     | [github.com/watchtowrlabs/CVE-2024-27130](https://github.com/watchtowrlabs/CVE-2024-27130)       |

**The Bug**

The QNAP QTS and QuTS hero operating systems contained multiple buffer copy vulnerabilities where insecure functions like `strcpy()` were used to copy user-supplied input to fixed-size buffers on the stack without proper size validation. The vulnerabilities affected the web administration interface and file handling components.

**The Attack (Step-by-Step)**

1.  **Reconnaissance:** Attacker identifies a vulnerable endpoint in the web administration interface.
2.  **Preparation:** Construction of a payload with oversized input.
3.  **Exploitation:** Sending a specially crafted request with data that exceeds the buffer size.
4.  **Corruption:** The unverified data overflows the stack buffer, overwriting:
    -   Adjacent local variables
    -   Saved frame pointer
    -   Return address
5.  **Execution Control:** When the function returns, the execution flow is redirected to attacker-controlled code.

**Impact**

-   Remote code execution with the privileges of the QNAP service (typically root).
-   Complete control of the NAS device, allowing:
    -   Access to all stored data
    -   Pivoting to other network resources
    -   Installation of persistent backdoors
-   Critical risk for enterprise infrastructure where NAS devices store sensitive data.

**Mitigation**

QNAP released QTS 5.1.7.2770 build 20240520 and QuTS hero h5.1.7.2770 build 20240520 in May 2024:
-   Replacement of insecure string copy functions (`strcpy`, `sprintf`) with bounds-checking alternatives (`strncpy`, `snprintf`).
-   Implementation of additional input validation.
-   Enablement of compiler protections (stack canaries).

**Observations**

Stack overflows are still common in:
-   Embedded devices with legacy C/C++ code.
-   NAS systems with internet-exposed administration interfaces.
-   Applications that have not adopted modern secure APIs.

They are particularly dangerous when:
-   They provide the initial entry point for sophisticated attack chains against enterprise infrastructure.
-   They do not have compiler protections enabled (ASLR, DEP, stack canaries).

### 2.1.2. 1.1.2 Use-After-Free / UAF

**General Description**

A Use-After-Free (UAF) vulnerability occurs when a program continues to use a pointer after the memory it points to has been freed. This creates a “dangling pointer” that can be exploited by carefully controlling heap allocations to place attacker-controlled data where the freed object previously resided.

**Bug Mechanics:**

```
      UAF LIFECYCLE
+--------------------------------+
|   1. ALLOCATION                |
|      obj = malloc(sizeof(Object)); |
|      obj->vtable = &legitimate_vtable; |
|                                |
|   2. LEGITIMATE USE              |
|      obj->method();   // Call function via vtable |
|                                |
|   3. DEALLOCATION                |
|      free(obj);       // Memory freed, but... |
|      // The 'obj' pointer still exists! |
|                                |
|   4. REALLOCATION (by attacker) |
|      attacker_data = malloc(sizeof(Object)); |
|      // Same size → can get the same location |
|      attacker_data->vtable = &malicious_vtable; |
|                                |
|   5. USE-AFTER-FREE |
|      obj->method();   // Calls attacker's function! |
+--------------------------------+
```

**Case Study: CVE-2024-2883 — Chrome ANGLE**

| Field                | Detail                                    |
| -------------------- | ------------------------------------------ |
| Affected Product    | Google Chrome (ANGLE component)           |
| Type                 | Use-After-Free                             |
| Vector               | Malicious web page                       |
| Severity            | Critical                                   |
| Exploitable Code    | Yes, without user interaction            |

**The Bug**

The ANGLE (Almost Native Graphics Layer Engine) component of Google Chrome, which translates OpenGL ES API calls to DirectX, Vulkan, or native OpenGL, contained a use-after-free vulnerability. The bug occurred when WebGL contexts were destroyed while still being referenced by pending graphics operations, leaving dangling pointers to freed graphics objects.

**The Attack (Step-by-Step)**

1.  **Environment Preparation:**
    -   Attacker creates a malicious HTML page with WebGL JavaScript code.
    -   The code manipulates the creation and destruction of graphics contexts.
2.  **Triggering the Bug:**
    ```javascript
    // Simplified concept (not the actual exploit):
    let ctx = canvas.getContext('webgl');
    // Start asynchronous graphics operation
    ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
    // Destroy context while operation is pending
    ctx = null;
    // Garbage collection frees the context
    // but pending operation still has a reference
    ```
3.  **Heap Feng-Shui:**
    -   Use heap spray techniques to control allocations.
    -   Allocate objects of the same size as the freed object.
    -   Place attacker-controlled data in the freed location.
4.  **Exploitation:**
    -   When ANGLE code uses the dangling pointer, it accesses the attacker's data.
    -   The attacker places a fake object with a malicious vtable.
    -   The next virtual method call executes the attacker's code.

**Impact**

-   Remote code execution via a malicious web page with NO user interaction other than visiting the page.
-   By placing a fake object in the freed memory, the attacker can hijack the control flow.
-   Execute arbitrary code in the renderer process.
-   Can be chained with sandbox escape exploits for full system compromise.

**Mitigation**

Google Chrome 123.0.6312.86 (released March 2024) fixed the vulnerability:
-   Implementation of proper lifetime management for graphics objects.
-   Added reference counting to prevent premature destruction of objects still in use.
-   Additional validation before using pointers to graphics objects.

**Observations**

UAF vulnerabilities are particularly dangerous in:
-   Browsers: Complex C++ applications where object lifetimes are difficult to track.
-   Graphics Subsystems: ANGLE, Skia, and similar handle untrusted content and have complex state management.
-   Code with Asynchronous Callbacks: Where the order of execution is difficult to predict.

They are a favorite target of advanced attackers because:
-   They offer fine-grained control over program execution.
-   They are difficult to detect with static analysis.
-   Modern mitigations (ASLR) can be bypassed with heap manipulation techniques.

### 2.1.3. 1.1.3 Heap Buffer Overflow

**General Description**

Similar to stack overflows, heap overflows occur when a program writes beyond the boundaries of a dynamically allocated buffer on the heap. Instead of corrupting stack frames, heap overflows typically corrupt heap metadata or adjacent objects, leading to memory corruption when the allocator later processes the corrupted structures.

**Heap Overflow Mechanics:**

```
      HEAP LAYOUT
+----------------------------------+
|   +----------------------------+   |
|   | Chunk Header (metadata)    |   |
|   +----------------------------+   |
|   | Vulnerable Buffer [100]    |   |
|   |                            |   |
|   | ══════════════════════════ | <--- Boundary
|   | OVERFLOW →→→→→→→→→→→→→→→→→→ |
|   +----------------------------+   |
|   +----------------------------+   |
|   | Chunk Header (CORRUPTED)   | <--- Corruption
|   +----------------------------+   |
|   | Adjacent Object            |   |
|   | - vtable *                 | <--- Or object
|   | - function_ptr             |      corruption
|   | - data fields              |   |
|   +----------------------------+   |
+----------------------------------+
```

**Case Study: CVE-2023-4863 — libWebP**

| Field             | Detail                                       |
| ----------------- | --------------------------------------------- |
| Affected Product  | libWebP (Chrome, Firefox, Edge, multiple apps) |
| Type              | Heap Buffer Overflow                          |
| Vector            | Malicious WebP image                         |
| Severity          | Critical                                      |
| PoC Available     | [github.com/mistymntncop/CVE-2023-4863](https://github.com/mistymntncop/CVE-2023-4863)         |

**The Bug**

The libWebP library, used by Chrome, Firefox, Edge, and many other applications to process WebP images, contained a heap overflow in the `BuildHuffmanTable()` function. When parsing specially crafted WebP images with malformed Huffman coding data, the function wrote beyond the boundaries of the allocated buffer.

**The Attack (Step-by-Step)**

1.  **Input Vector:**
    -   Attacker embeds a malicious WebP image on a web page.
    -   Or sends it via messaging applications (WhatsApp, Telegram, Signal).
    -   Or includes it in a document (email, Word, PDF).
2.  **Trigger:**
    -   The victim's browser/application attempts to decode the image.
    -   The WebP parser processes malformed Huffman data.
    -   `BuildHuffmanTable()` calculates an incorrect table size.
3.  **Exploitation:**
    -   The overflow corrupts heap metadata.
    -   Or corrupts adjacent objects with function pointers.
    -   The attacker controls the overflow data to achieve primitives.
4.  **Result:**
    -   Arbitrary code execution in the process context.
    -   In browsers: code executes in the renderer process.

**Impact**

-   Remote code execution without user interaction other than viewing a web page or opening an image.
-   Zero-day actively exploited before its public disclosure (September 2023).
-   Billions of devices affected across multiple platforms:
    -   Windows, macOS, Linux (desktop)
    -   Android, iOS (mobile)
    -   Any software using libWebP (Electron apps, etc.)

**Why This Vulnerability is Emblematic:**

1.  **Supply Chain Risk:** A bug in libWebP affected dozens of major applications.
2.  **Ubiquity of Images:** Images are processed automatically and are ubiquitous.
3.  **Modern Heap Techniques:** Attackers combined the heap overflow with ASLR bypass techniques.

**Mitigation**

-   libWebP 1.3.2 (September 2023): Corrected bounds checking in `BuildHuffmanTable()`.
-   Chrome 116.0.5845.187: Emergency patch.
-   Firefox 117.0.1: Emergency patch.
-   Other affected software released coordinated updates.

**Observations**

Heap overflows in image parsers are particularly dangerous because:
-   Images are processed automatically without user confirmation.
-   They are routinely shared and considered “safe.”
-   Image parsers optimize for performance, sometimes sacrificing security checks.
-   The complexity of compression formats (Huffman, LZW, etc.) introduces bugs.

### 2.1.4. 1.1.4 Out-of-Bounds Read / Info Leak

**General Description**

An Out-of-Bounds (OOB) Read occurs when a program reads memory past the boundaries of a buffer without modifying it. Although it does not allow direct writing, it is frequently used to:
-   Leak pointers to bypass ASLR/KASLR.
-   Expose object metadata to build more powerful primitives.
-   Reveal kernel memory layout for reliable exploitation.

**Role in Exploit Chains:**

```
      TYPICAL EXPLOIT CHAIN
+--------------------------------+
|   1. OOB READ (Info Leak)      | <--- Leak kernel addresses
|   └─────────┬─────────┘        |
|             │                  |
|             ▼                  |
|   2. KASLR BYPASS              | <--- Calculate real addresses
|   └─────────┬─────────┘        |
|             │                  |
|             ▼                  |
|   3. WRITE PRIMITIVE           | <--- Another vulnerability (UAF, overflow)
|   └─────────┬─────────┘        |
|             │                  |
|             ▼                  |
|   4. CODE EXECUTION            | <--- Write to a known location
+--------------------------------+
```

**Case Study: CVE-2024-53108 — Linux AMDGPU Display Driver**

| Field             | Detail                               |
| ----------------- | ------------------------------------- |
| Affected Product  | Linux Kernel (AMD Display driver)     |
| Type              | Out-of-Bounds Read (slab-out-of-bounds)|
| Vector            | Malicious EDID/display data         |
| Severity          | Medium-High                            |
| Patch Diff        | [git.kernel.org](https://git.kernel.org)                        |

**The Bug**

In the AMD display driver of the Linux kernel, the EDID/VSDB (Video Specification Database) parsing path had insufficient bounds checking when extracting capability identifiers. When processing EDID data with manipulated length fields, the driver would read beyond the boundaries of the allocated EDID buffer.

The bug was detected by KASAN (Kernel AddressSanitizer), which reported a slab-out-of-bounds access during the extraction of display data.

**The Attack**

A maliciously crafted EDID/display data stream could:
1.  Trigger an OOB read in kernel space.
2.  Expose kernel memory contents (including pointers).
3.  Provide information to bypass KASLR.
4.  Be chained with another write vulnerability for full exploitation.

**Impact**

-   Information disclosure: Exposure of kernel memory content.
-   Potential system instability: Reading invalid memory can cause an oops.
-   Exploitation enabler: Usable to bypass KASLR in more complex exploit chains.

**Why OOB Reads Matter:**

In kernel contexts:
-   KASLR is a fundamental mitigation against exploitation.
-   Without an info leak, a blind write fails - the attacker needs to know where to write.
-   OOB reads are the first step in most modern kernel exploits.

**Mitigation**

Kernel updates adjusted the length validation:
-   Verify that bLength is >= the minimum expected size.
-   Validate offsets before accessing fields.
-   Ensure that all reads remain within the boundaries of the EDID buffer.

**Observations**

Pure OOB reads are valuable for building reliable exploit chains:
-   They provide the necessary information to bypass ASLR/KASLR.
-   They are frequently the first stage of multi-step exploits.
-   In the kernel, defeating KASLR is pivotal for reliable exploitation.

### 2.1.5. 1.1.5 Uninitialized Memory Use

**General Description**

Using stack/heap/pool memory before it is initialized can expose residual contents from previous operations. These contents may include:
-   Previous pointers (kernel addresses for bypassing KASLR).
-   Capability flags (for privilege escalation).
-   Structure fields (for type confusion).

**Why It's Dangerous:**

```c
// Vulnerable code - uninitialized variable
void vulnerable_function(struct netlink_msg *msg) {
    struct nft_pipapo_match *m; // <--- UNINITIALIZED

     // If some code path does not assign 'm'...
     if (some_condition(msg)) {
         m = find_match(msg);
     }
     // ... but 'm' is used unconditionally

     copy_to_user(response, &m, sizeof(m)); // <--- Leaks residual stack data
}
```

**Case Study: CVE-2024-26581 — Linux Kernel Netfilter**

| Field             | Detail                               |
| ----------------- | ------------------------------------- |
| Affected Product  | Linux Kernel (netfilter subsystem)   |
| Type              | Uninitialized Variable Use       |
| Vector            | Local netlink messages              |
| Severity          | High                                  |
| PoC Available     | [sploitus.com/exploit?id=A4D521EE-225F-57D5-8C31-9F1C86D066B6](https://sploitus.com/exploit?id=A4D521EE-225F-57D5-8C31-9F1C86D066B6) |

**The Bug**

The Linux kernel's netfilter subsystem contained an uninitialized variable vulnerability in the nf_tables component. When processing netlink messages to configure firewall rules, the `nft_pipapo_walk()` function failed to initialize a local variable before its use.

The uninitialized stack variable could contain residual data from previous function calls, including kernel pointers and sensitive memory addresses.

**The Attack (Step-by-Step)**

1.  **Obtain Capabilities:**
    -   Attacker is in an unprivileged user namespace.
    -   User namespaces grant CAP_NET_ADMIN (default on Ubuntu, Debian).
2.  **Trigger the Bug:**
    -   Send specific netlink messages for nf_tables configuration.
    -   Cause the code path with the uninitialized variable to be executed.
    -   The variable is read and copied back to user space.
3.  **Collect Information:**
    -   Repeat the trigger multiple times.
    -   Analyze the returned data.
    -   Extract kernel addresses (heap, stack, code).
4.  **Exploit with Information:**
    -   Use the leaked addresses to bypass KASLR.
    -   Combine with another netfilter write vulnerability.
    -   Achieve full privilege escalation (LPE chain).

**Impact**

-   Information disclosure → KASLR bypass.
-   Leaked kernel addresses allow for reliable exploitation of other vulnerabilities.
-   Particularly dangerous when combined with other netfilter bugs for full LPE chains.

**The Danger of the Combo: Netfilter + User Namespaces**

Many Linux distributions allow unprivileged user namespaces by default:
-   Ubuntu: Enabled by default.
-   Debian: Enabled by default.
-   Fedora: Enabled by default.

This means that CAP_NET_ADMIN is available to unprivileged users, making netfilter bugs exploitable without root privileges.

**Mitigation**

Linux kernel 6.8-rc1 (February 2024):
-   Added proper initialization: `struct nft_pipapo_match *m = NULL;`
-   Enabled designated initializers for stack structures.
-   Enabled stricter compiler warnings (`-Wuninitialized`) for netfilter.

**Observations**

Uninitialized memory reads are often the first stage in exploit chains:
-   They provide entropy reductions to bypass modern mitigations.
-   They are particularly valuable in kernel exploitation where KASLR is essential.
-   The combination of unprivileged user namespaces and netfilter leaks makes this class of vulnerability accessible to local attackers without requiring root privileges.
... (The rest of the chapter would follow the same structure)
