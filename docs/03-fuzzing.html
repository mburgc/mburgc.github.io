<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 03: Fuzzing | Bitácora Red Team</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        :root {
            --primary-color: #0D47A1;
            --secondary-color: #E3F2FD;
            --accent-color: #42A5F5;
            --text-color: #1A237E;
            --bg-color: #FFFFFF;
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.3);
            --sidebar-width: 300px;
            --sidebar-collapsed: 60px;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text-color);
            line-height: 1.8;
            min-height: 100vh;
        }
        
        .layout {
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--glass-border);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 100;
        }
        
        .sidebar-header {
            padding: 25px 20px;
            background: linear-gradient(135deg, #0a1628 0%, #0D47A1 50%, #1565C0 100%);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .sidebar-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            margin: 0 0 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sidebar-header .subtitle {
            font-size: 0.7rem;
            opacity: 0.85;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .nav-section {
            padding: 5px 0;
        }
        
        .nav-section-title {
            padding: 12px 20px 8px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent-color);
            font-weight: 700;
            background: rgba(66, 165, 245, 0.08);
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 20px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .nav-item:hover {
            background: var(--secondary-color);
            border-left-color: var(--accent-color);
        }
        
        .nav-item.active {
            background: var(--secondary-color);
            border-left-color: var(--primary-color);
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .nav-item i {
            width: 18px;
            color: var(--accent-color);
            text-align: center;
            font-size: 0.85rem;
        }
        
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 40px 50px;
            max-width: calc(100vw - var(--sidebar-width));
        }
        
        .sidebar-toggle {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 200;
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 15px rgba(13, 71, 161, 0.3);
        }
        
        .content-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .content-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2rem;
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .breadcrumb {
            font-size: 0.85rem;
            color: #666;
        }
        
        .breadcrumb a {
            color: var(--accent-color);
            text-decoration: none;
        }
        
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
        }
        
        .section h2 {
            font-family: 'Montserrat', sans-serif;
            color: var(--primary-color);
            margin: 30px 0 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
            font-size: 1.4rem;
        }
        
        .section h2:first-child {
            margin-top: 0;
        }
        
        .section h3 {
            color: var(--text-color);
            margin: 25px 0 15px;
            font-size: 1.15rem;
            font-weight: 600;
        }
        
        .section h4 {
            color: #333;
            margin: 20px 0 12px;
            font-size: 1rem;
        }
        
        .section p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .section ul, .section ol {
            margin: 15px 0 15px 25px;
        }
        
        .section li {
            margin-bottom: 8px;
        }
        
        .section pre {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .section code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        
        .section :not(pre) > code {
            background: var(--secondary-color);
            padding: 3px 8px;
            border-radius: 5px;
            color: var(--primary-color);
            font-size: 0.9em;
        }
        
        .section table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .section th, .section td {
            padding: 14px 18px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .section th {
            background: var(--secondary-color);
            font-weight: 700;
            color: var(--primary-color);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.5px;
        }
        
        .section tr:hover {
            background: rgba(66, 165, 245, 0.05);
        }
        
        .vuln-card {
            background: linear-gradient(135deg, rgba(13, 71, 161, 0.06) 0%, rgba(66, 165, 245, 0.1) 100%);
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 12px 12px 0;
        }
        
        .vuln-card.danger {
            border-left-color: #f44336;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.06) 0%, rgba(244, 67, 54, 0.1) 100%);
        }
        
        .vuln-card.warning {
            border-left-color: #ff9800;
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.06) 0%, rgba(255, 152, 0, 0.1) 100%);
        }
        
        .vuln-card.success {
            border-left-color: #4caf50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.06) 0%, rgba(76, 175, 80, 0.1) 100%);
        }
        
        .toc {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 20px 25px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            margin: 0 0 15px;
            color: var(--primary-color);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }
        
        .toc a:hover {
            color: var(--accent-color);
        }
        
        .page-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 25px;
            border-top: 1px solid #ddd;
        }
        
        .page-nav a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 24px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            text-decoration: none;
            color: var(--text-color);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .page-nav a:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(13, 71, 161, 0.3);
        }
        
        .page-nav a.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        @media (max-width: 900px) {
            .sidebar-toggle {
                display: block;
            }
            
            .sidebar {
                transform: translateX(-100%);
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                padding: 70px 20px 30px;
            }
        }
        
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }
        
        .license-notice {
            font-size: 0.75rem;
            color: #666;
            padding: 15px 20px;
            border-top: 1px solid rgba(0,0,0,0.05);
            margin-top: auto;
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" onclick="toggleSidebar()">
        <i class="fas fa-bars"></i>
    </button>
    
    <div class="layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-shield-alt"></i> Bitácora</h1>
                <div class="subtitle">Red Team</div>
            </div>
            
            <nav>
                
            <a href="01-introduccion.html" class="nav-item">
                <i class="fas fa-book"></i>Introducción
            </a>
            <a href="02-clases-vulnerabilidades.html" class="nav-item">
                <i class="fas fa-bug"></i>Clases de Vulnerabilidades
            </a>
            <a href="03-fuzzing.html" class="nav-item">
                <i class="fas fa-flask"></i>Fuzzing
            </a>
            <a href="04-patch-diffing.html" class="nav-item">
                <i class="fas fa-code-branch"></i>Patch Diffing
            </a>
            <a href="05-analisis-crashes.html" class="nav-item">
                <i class="fas fa-exclamation-triangle"></i>Análisis de Crashes
            </a>
            </nav>
            
            <div class="license-notice">
                <i class="fas fa-creative-commons"></i> CC BY-NC 4.0
            </div>
        </aside>
        
        <main class="main-content">
            <div class="content-header animate__animated animate__fadeInDown">
                <div class="breadcrumb"><a href="/">Bitácora Red Team</a> / Capítulo 03: Fuzzing</div>
                <h1>Capítulo 03: Fuzzing</h1>
            </div>
            
            <div class="animate__animated animate__fadeInUp">
                <div class="section"><h3 id="capitulo-2-clases-de-vulnerabilidades">CAPÍTULO 2. CLASES DE VULNERABILIDADES</h3>
<p>Bitácora Red Team
Observaciones
Mientras no es una vulnerabilidad per se, BYOVD es ampliamente usado en cadenas de explotación
y representa un riesgo significativo de abuso de drivers legítimos firmados.</p>
<h3 id="26">2.6.</h3>
<h3 id="16-evaluacion-de-impacto-y-clasificacion">1.6 Evaluación de Impacto y Clasificación</h3>
<p>Comprender cómo evaluar y clasificar vulnerabilidades por su impacto real y explotabilidad es fun‐
damental para la priorización de parches y respuesta a incidentes.</p>
<h3 id="261">2.6.1.</h3>
<p>Categorías de Impacto
Ejecución Remota de Código ﴾RCE﴿‐ Definición: Atacante puede ejecutar código arbitrario en el
sistema objetivo remotamente ‐ Impacto: Máxima severidad ‐ compromiso completo del sistema
posible ‐ Ejemplos: CVE‐2024‐27130 ﴾QNAP﴿, CVE‐2024‐2883 ﴾Chrome ANGLE﴿, CVE‐2023‐4863
﴾libWebP﴿
Escalada de Privilegios Local ﴾LPE﴿‐ Definición: Atacante con acceso limitado puede obtener
privilegios más altos ‐ Impacto: Alta severidad ‐ permite persistencia, evasión de defensas, movi‐
miento lateral ‐ Ejemplos: CVE‐2024‐26218 ﴾Windows Kernel TOCTOU﴿, CVE‐2022‐0847 ﴾Dirty Pipe﴿
Divulgación de Información ‐ Definición: Atacante puede leer datos a los que no debería tener
acceso ‐ Impacto: Media a Alta ‐ frecuentemente encadenada con otros bugs para bypass de ASLR
‐ Ejemplos: Fugas de format string, lecturas de memoria no inicializada
Denegación de Servicio ﴾DoS﴿‐ Definición: Atacante puede hacer un servicio no disponible sin
ganar ejecución de código ‐ Impacto: Baja a Media ‐ interrumpe disponibilidad sin comprometer
confidencialidad/integridad ‐ Ejemplos: CVE‐2024‐27316 ﴾HTTP/2 CONTINUATION﴿, bombas de
descompresión</p>
<h3 id="262">2.6.2.</h3>
<p>Factores de Explotabilidad
Factor
Bajo
Alto
Complejidad de Ataque
Requiere preparación
compleja
Explotable repetidamente
con mínimo esfuerzo
Vector de Ataque
Requiere acceso físico
Explotable remotamente
sobre red
Privilegios Requeridos
Requiere acceso
administrativo
Sin autenticación necesaria
Interacción de Usuario
Víctima debe realizar acción
Completamente
automatizado</p>
<hr />
<h3 id="capitulo-2-clases-de-vulnerabilidades_1">CAPÍTULO 2. CLASES DE VULNERABILIDADES</h3>
<p>Bitácora Red Team</p>
<h3 id="263">2.6.3.</h3>
<p>Sistema de Puntuación CVSS
Componentes del Score Base ﴾Cualidades Intrínsecas﴿: ‐ Vector de Ataque ﴾AV﴿: Red/Adyacente/Local/Físico
‐ Complejidad de Ataque ﴾AC﴿: Baja/Alta ‐ Privilegios Requeridos ﴾PR﴿: Ninguno/Bajo/Alto ‐ In‐
teracción de Usuario ﴾UI﴿: Ninguna/Requerida ‐ Alcance ﴾S﴿: Sin Cambio/Con Cambio ‐ Impacto
a Confidencialidad ﴾C﴿, Integridad ﴾I﴿, Disponibilidad ﴾A﴿: Ninguno/Bajo/Alto
Rangos de Score: | Rango | Severidad | |——‐|———–| | 0.0 | Ninguna | | 0.1‐3.9 | Baja | | 4.0‐6.9 |
Media | | 7.0‐8.9 | Alta | | 9.0‐10.0 | Crítica |</p>
<h3 id="264">2.6.4.</h3>
<p>Conclusiones del Capítulo 1
1. La corrupción de memoria sigue siendo prevalente: A pesar de décadas de investigación,
los bugs de corrupción de memoria continúan afectando software, especialmente en bases
de código C/C++.
2. La defensa en profundidad es esencial: Cada ejemplo real muestra atacantes evadiendo
múltiples mecanismos de protección ﴾DEP, ASLR, CET, safe‐linking﴿.
3. Las mitigaciones modernas elevan la barrera pero no eliminan el riesgo: Mientras tec‐
nologías como CET shadow stack y safe‐linking hacen la explotación más difícil, atacantes
determinados continúan encontrando bypasses.
4. Las causas raíz son similares, pero los contextos difieren: Bugs de stack, heap y UAF com‐
parten causas raíz comunes ﴾verificación inadecuada de límites, gestión de tiempo de vida﴿
pero requieren diferentes técnicas de explotación.
5. Los componentes legacy permanecen vulnerables: Vulnerabilidades de años de antigüedad
en parsers de office y manejadores de archivos continúan siendo explotadas debido a ciclos
de parcheo lentos.
6. Las vulnerabilidades lógicas no requieren corrupción de memoria: Bypasses de autentica‐
ción, fallas TOCTOU y primitivas de escritura arbitraria pueden ser igualmente impactantes.
7. User namespaces expanden la superficie de ataque: Muchas vulnerabilidades del kernel
se vuelven explotables desde contextos no privilegiados cuando user namespaces otorgan
capacidades como CAP_NET_ADMIN.</p>
<hr />
<p>Capítulo 3
Fuzzing
El fuzzing es una técnica automatizada de descubrimiento de vulnerabilidades que ha encontrado
miles de bugs de seguridad críticos en software de producción. Este capítulo cubre los fundamentos
del fuzzing, herramientas clave y metodologías para encontrar vulnerabilidades.</p>
<h3 id="31">3.1.</h3>
<h3 id="21-fundamentos-de-fuzzing">2.1 Fundamentos de Fuzzing</h3>
<p>Qué es el Fuzzing
El fuzzing es una técnica de prueba de software que involucra proporcionar datos inválidos, inespe‐
rados o aleatorios como entrada a un programa. El objetivo es encontrar crashes, assertions fallidos,
fugas de memoria y otros comportamientos anómalos que puedan indicar vulnerabilidades de se‐
guridad.
Por Qué el Fuzzing es Efectivo
Automatización: Puede probar millones de entradas por hora
Cobertura: Explora casos extremos que las pruebas manuales nunca alcanzarían
Reproducibilidad: Las entradas que causan crashes se guardan para análisis
Escalabilidad: Puede ejecutarse continuamente durante días/semanas
Tipos de Fuzzing
Tipo
Descripción
Ejemplo
Caja Negra
Sin conocimiento del código interno
Mutación aleatoria de
entradas
Caja Blanca
Conocimiento completo del código
Ejecución simbólica
Caja Gris
Instrumentación de cobertura
AFL++, libFuzzer
Guiado por
Cobertura
Mide qué código se ejecuta
AFL++, Honggfuzz
Guiado por
Gramática
Conoce la estructura del formato
Syzkaller ﴾syscalls﴿</p>
<hr />
<h3 id="capitulo-3-fuzzing">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team</p>
<h3 id="32">3.2.</h3>
<h3 id="22-afl-y-fuzzing-guiado-por-cobertura">2.2 AFL++ y Fuzzing Guiado por Cobertura</h3>
<p>Descripción General
AFL++ ﴾American Fuzzy Lop Plus Plus﴿es uno de los fuzzers más efectivos y ampliamente utilizados.
Usa instrumentación de cobertura para guiar la mutación de entradas hacia nuevos caminos de
código.
Componentes Clave de AFL++
1. Instrumentación de Cobertura: Compilador modificado que inserta código para rastrear qué
bloques básicos se ejecutan
2. Motor de Mutación: Aplica transformaciones inteligentes a las entradas
3. Gestión de Corpus: Mantiene conjunto mínimo de entradas que maximizan cobertura
4. Detección de Crashes: Identifica y guarda entradas que causan fallos
Caso de Estudio: AFL++ Encontrando CVE‐2024‐47606 ﴾GStreamer﴿
Campo
Detalle
Método de Descubrimiento
Campañas de fuzzing continuas con AFL++
Objetivo
Demuxer QuickTime de GStreamer ﴾qtdemux﴿
Superficie de Ataque
Archivos MP4/MOV procesados por navegadores,
reproductores, apps de mensajería
El Proceso de Descubrimiento
1. Corpus de Semillas: Archivos MP4 válidos de datasets públicos
2. Instrumentación: Compilado con AFL++ y AddressSanitizer
3. Estrategia de Mutación: Structure‐aware ﴾entendiendo átomos MP4﴿
4. Resultado: Crash de heap buffer overflow después de ~48 horas de fuzzing
Por Qué el Fuzzing lo Encontró
Combinación de Entrada Rara: Requería valores específicos de tamaño de extensión Theora
que subdesbordaran
Limitación de Análisis Estático: Conversión signed‐to‐unsigned enterrada en lógica de par‐
sing compleja
Falla de Code Review: Aritmética de enteros parecía correcta sin considerar valores negativos
Brecha de Testing Automatizado: Pruebas unitarias no cubrían extensiones Theora malfor‐
madas
Insight Clave
El fuzzing sobresale en encontrar casos extremos en parsers complejos que los humanos nunca
probarían manualmente. La combinación de: ‐ Mutación guiada por cobertura ﴾AFL++ explorando
nuevos caminos de código﴿‐ AddressSanitizer ﴾detectando corrupción de memoria inmediatamen‐
te﴿‐ Fuzzing persistente ﴾ejecutándose por días/semanas﴿
…lo hace más efectivo que las pruebas manuales para esta clase de vulnerabilidad.</p>
<hr />
<h3 id="capitulo-3-fuzzing_1">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team</p>
<h3 id="33">3.3.</h3>
<h3 id="23-fuzztest-y-fuzzing-inprocess">2.3 FuzzTest y Fuzzing In‐Process</h3>
<p>Descripción General
FuzzTest es un framework de fuzzing in‐process estilo unit‐test de Google que integra fuzzing con
GoogleTest. Es ideal para fuzzear funciones C++ individuales directamente.
Características Clave
Integración con GoogleTest: Se escribe TEST y FUZZ_TEST lado a lado en el mismo archivo
Fuzzing guiado por cobertura bajo el capó: Estilo libFuzzer pero oculta código boilerplate
de harness
Ideal para bibliotecas y lógica core: Parsers, decoders, helpers de crypto
Perfecto para CI: El mismo binario puede ejecutar tests determinísticos rápidos o campañas
de fuzz largas
Ventajas de FuzzTest
Aspecto
FuzzTest
AFL++/Honggfuzz
Target
Funciones individuales
Programas completos
Integración
GoogleTest nativo
Harness separado
Uso
Unit tests →fuzz tests
Binarios standalone</p>
<h3 id="cicd">CI/CD</h3>
<p>Excelente
Requiere setup adicional
Observaciones
FuzzTest es particularmente útil para equipos que ya tienen suites de unit tests y quieren añadir
fuzzing de manera incremental a sus flujos de trabajo existentes.</p>
<h3 id="34">3.4.</h3>
<h3 id="24-honggfuzz-y-fuzzing-de-protocolos">2.4 Honggfuzz y Fuzzing de Protocolos</h3>
<p>Descripción General
Honggfuzz es un fuzzer desarrollado por Google con soporte excelente para fuzzing de protocolos
de red y aplicaciones multi‐hilo. Ofrece cobertura asistida por hardware usando Intel PT.
Características Distintivas
Multi‐hilo nativo: Maneja targets multi‐hilo sin problemas
Cobertura Hardware: Usa Intel Processor Trace para cobertura de bajo overhead
Modo Persistente: Mantiene el proceso vivo entre iteraciones
Detección de Feedback: Detecta crashes, timeouts, memory errors
Caso de Estudio: Fuzzing de Implementaciones TLS</p>
<hr />
<h3 id="capitulo-3-fuzzing_2">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
Aspecto
Desafío
Solución
Protocolo Stateful
Debe completar handshake
antes de llegar a lógica
profunda
Harness que simula estado de
conexión
Operaciones Criptográficas
Valores aleatorios, firmas,
MACs
Seeds con datos criptográficos
válidos
Múltiples Versiones</p>
<h3 id="tls-10-11-12-13">TLS 1.0, 1.1, 1.2, 1.3</h3>
<p>Configurar target para versión
específica
Extensiones
ALPN, SNI, session tickets
Corpus con variedad de
extensiones
Bugs Reales Encontrados por Fuzzing de Protocolos
De OpenSSL y otras implementaciones TLS: ‐ Buffer overflows en parsing de certificados: Manejo
de extensiones X.509 ‐ Use‐after‐free en reanudación de sesión: Gestión de lifetime de tickets
‐ Integer overflows en capa de registro: Cálculos de longitud ‐ Bugs de confusión de estado:
Ordenamiento inesperado de mensajes
Observaciones
El fuzzing de protocolos es más desafiante que el fuzzing de formatos de archivo debido a la natura‐
leza stateful de los protocolos, pero es altamente efectivo para encontrar bugs en implementaciones
de red.</p>
<h3 id="35">3.5.</h3>
<h3 id="25-syzkaller-y-fuzzing-de-kernel">2.5 Syzkaller y Fuzzing de Kernel</h3>
<p>Descripción General
Syzkaller es un fuzzer de syscalls del kernel desarrollado por Google. Es responsable de encontrar
miles de bugs del kernel Linux y se usa activamente en el desarrollo del kernel.
Características Clave
Conocimiento de Syscalls: Entiende las signatures de syscalls y sus argumentos
Generación de Programas: Crea secuencias de syscalls válidas y semi‐válidas
Gestión de VMs: Ejecuta targets en VMs para aislamiento
Reproducción: Genera programas C reproducibles para crashes encontrados
Arquitectura de Syzkaller
┌─────────────────────────────────────────────────────────────┐
│
Manager (syz-manager)
│
│
- Coordina múltiples VMs
│
│
- Gestiona corpus de programas
│
│
- Rastrea cobertura de código
│
└─────────────────────────────────────────────────────────────┘
│</p>
<hr />
<h3 id="capitulo-3-fuzzing_3">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
┌────────────────────┼────────────────────┐
▼
▼
▼
┌─────────┐
┌─────────┐
┌─────────┐
│</p>
<h3 id="vm1">VM1</h3>
<p>│
│</p>
<h3 id="vm2">VM2</h3>
<p>│
│</p>
<h3 id="vm3">VM3</h3>
<p>│
│fuzzer
│
│fuzzer
│
│fuzzer
│
│executor│
│executor│
│executor│
└─────────┘
└─────────┘
└─────────┘
Subsistemas del Kernel Frecuentemente Fuzzeados
Subsistema
Superficie de Ataque
Bugs Comunes
Netfilter
Reglas de firewall, NAT
UAF, race conditions
io_uring
Async I/O
Race conditions, memory leaks</p>
<h3 id="usb">USB</h3>
<p>Descriptores de dispositivo
OOB reads, tipo confusions
Filesystems
Imágenes de disco
Integer overflows, NULL derefs
Network
Paquetes, sockets
Buffer overflows, state confusion
Caso de Estudio: Syzkaller y CVE‐2022‐32250 ﴾Netfilter UAF﴿
Campo
Detalle
Target
net/netfilter/nf_tables_api.c
Tiempo de Descubrimiento
~72 horas desde introducción del código
Causa Raíz
Error de conteo de referencias en expresiones stateful
Impacto
Escalada de privilegios local a root
Cómo Syzkaller Encontró el Bug:
Syzkaller genera secuencias de syscalls que interactúan con el subsistema netfilter:
socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER) →fd
sendmsg(fd, { type: NFT_MSG_NEWTABLE, ... })
sendmsg(fd, { type: NFT_MSG_NEWCHAIN, data: [chain_with_stateful_expr] })
sendmsg(fd, { type: NFT_MSG_NEWRULE, data: [rule_that_frees_expr] })
// Resultado: Uso de expresión liberada →Crash UAF
Por Qué Syzkaller lo Encontró:
1. Cobertura de Syscalls: Prueba todas las operaciones netfilter sistemáticamente
2. Exploración de Secuencias: Prueba millones de ordenamientos de syscalls
3. Rastreo de Estado: Mantiene estado del kernel a través de operaciones
4. Integración KASAN: Detección inmediata de corrupción de memoria
5. Reproducibilidad: Genera reproducers C mínimos para desarrolladores
Impacto Real: El bug permitía escalada de privilegios local desde cualquier usuario a root en siste‐
mas con user namespaces no privilegiados ﴾default en Ubuntu, Debian﴿. Exploit público disponible
en semanas.
Observaciones</p>
<hr />
<h3 id="capitulo-3-fuzzing_4">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
Syzkaller ha transformado la seguridad del kernel Linux al encontrar bugs de manera sistemática
antes de que sean explotados. Es una herramienta esencial para cualquier investigador de seguridad
de kernel.</p>
<h3 id="36">3.6.</h3>
<h3 id="26-configuracion-practica-de-afl">2.6 Configuración Práctica de AFL++</h3>
<p>Instalación Paso a Paso</p>
<h1 id="instalar-dependencias-de-compilacion">Instalar dependencias de compilación</h1>
<p>sudo apt update
sudo apt install -y build-essential gcc-13-plugin-dev cpio python3-dev \
libcapstone-dev pkg-config libglib2.0-dev libpixman-1-dev \
automake autoconf python3-pip ninja-build cmake git wget meson</p>
<h1 id="instalar-llvm-19-verificar-ultima-version-en-httpsaptllvmorg">Instalar LLVM 19 (verificar última versión en https://apt.llvm.org/)</h1>
<p>wget https://apt.llvm.org/llvm.sh
chmod +x llvm.sh
sudo ./llvm.sh 19 all</p>
<h1 id="verificar-instalacion-de-llvm">Verificar instalación de LLVM</h1>
<p>clang-19 --version
llvm-config-19 --version</p>
<h1 id="instalar-rust-requerido-para-algunos-componentes-de-afl">Instalar Rust (requerido para algunos componentes de AFL++)</h1>
<p>curl --proto '=https' --tlsv1.2 -sSf "https://sh.rustup.rs" | sh
source ~/.cargo/env</p>
<h1 id="compilar-e-instalar-afl">Compilar e instalar AFL++</h1>
<p>mkdir -p ~/soft &amp;&amp; cd ~/soft
git clone --depth 1 https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
make distrib
sudo make install</p>
<h1 id="verificar-instalacion">Verificar instalación</h1>
<p>which afl-fuzz
afl-fuzz --version
Compilación de Target con Instrumentación</p>
<h1 id="compilar-programa-cc-con-instrumentacion-afl">Compilar programa C/C++ con instrumentación AFL++</h1>
<p>CC=/usr/local/bin/afl-clang-fast \
CXX=/usr/local/bin/afl-clang-fast++ \
cmake ..
make -j$(nproc)</p>
<h1 id="habilitar-sanitizers-para-mejor-deteccion-de-bugs">Habilitar sanitizers para mejor detección de bugs</h1>
<hr />
<h3 id="capitulo-3-fuzzing_5">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
export AFL_USE_ASAN=1
export AFL_USE_UBSAN=1
export ASAN_OPTIONS="detect_leaks=1:abort_on_error=1:symbolize=1"
Ejecución del Fuzzer</p>
<h1 id="configurar-sistema-para-fuzzing-optimo">Configurar sistema para fuzzing óptimo</h1>
<p>echo core | sudo tee /proc/sys/kernel/core_pattern
echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor</p>
<h1 id="crear-corpus-de-semillas">Crear corpus de semillas</h1>
<p>mkdir -p seeds
for i in {0..4}; do
dd if=/dev/urandom of=seeds/seed_$i bs=64 count=10 2&gt;/dev/null
done</p>
<h1 id="ejecutar-fuzzer">Ejecutar fuzzer</h1>
<p>afl-fuzz -i seeds/ -o findings/ -m none -d -- ./target_binary @@</p>
<h1 id="fuzzing-paralelo-multiples-instancias">Fuzzing paralelo (múltiples instancias)</h1>
<h1 id="terminal-1-instancia-master">Terminal 1: Instancia Master</h1>
<p>afl-fuzz -i seeds/ -o findings/ -M Master -- ./target @@</p>
<h1 id="terminal-2-instancias-slave">Terminal 2+: Instancias Slave</h1>
<p>afl-fuzz -i seeds/ -o findings/ -S Slave1 -- ./target @@
afl-fuzz -i seeds/ -o findings/ -S Slave2 -- ./target @@</p>
<h1 id="verificar-estado">Verificar estado</h1>
<p>afl-whatsup findings/</p>
<h3 id="37">3.7.</h3>
<h3 id="27-analisis-de-crashes-y-evaluacion-de-explotabilidad">2.7 Análisis de Crashes y Evaluación de Explotabilidad</h3>
<p>El análisis de crashes es el proceso de determinar si un crash descubierto por fuzzing represen‐
ta una vulnerabilidad explotable. Esta sección cubre las herramientas y metodologías para triage
sistemático de crashes.
Árbol de Decisión para Análisis de Crashes
┌─────────────────────────────────────────────────────────────┐
│</p>
<h3 id="crash-recibido">CRASH RECIBIDO</h3>
<p>│
└─────────────────────────────────────────────────────────────┘
│
▼
┌───────────────────────┐
│¿Código fuente
│
│
disponible?
│
└───────────────────────┘</p>
<hr />
<h3 id="capitulo-3-fuzzing_6">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
│
│
Sí
No
│
│
▼
▼
┌─────────────────────┐
┌─────────────────────┐
│Recompilar con
│
│Usar depurador
│</p>
<h3 id="asan-ubsan">│ASAN + UBSAN</h3>
<p>│
│(GDB/WinDbg)
│
└─────────────────────┘
└─────────────────────┘
│
│
▼
▼
┌─────────────────────┐
┌─────────────────────┐
│Ejecutar crash
│
│Analizar registros
│
│Obtener reporte
│
│y memoria
│
└─────────────────────┘
└─────────────────────┘
│
│
└────────┬───────────┘
▼
┌───────────────────────────┐
│Clasificar vulnerabilidad │
│con CASR
│
└───────────────────────────┘</p>
<h3 id="371">3.7.1.</h3>
<h3 id="271-caso-de-estudio-analisis-de-heap-buffer-overflow">2.7.1 Caso de Estudio: Análisis de Heap Buffer Overflow</h3>
<p>Escenario: El fuzzing descubrió un crash en un parser de imágenes. Analicemos paso a paso.
Código Vulnerable:
// vuln_parser.c - Parser de imágenes vulnerable</p>
<h1 id="include">include <stdio.h></h1>
<h1 id="include_1">include <stdlib.h></h1>
<h1 id="include_2">include <string.h></h1>
<h1 id="include_3">include <stdint.h></h1>
<p>void build_huffman_table(uint8_t <em>input, size_t size) {
if (size &lt; 8) return;
uint32_t table_size = </em>(uint32_t<em>)input;
// Controlado por atacante
uint8_t </em>codes = input + 4;
uint8_t *table = malloc(256);
// Asignación fija de 256 bytes
// VULNERABILIDAD: Sin verificación de límites en table_size
// Puede escribir más allá del búfer de 256 bytes
memcpy(table, codes, table_size);
// ¡Heap buffer overflow!</p>
<hr />
<h3 id="capitulo-3-fuzzing_7">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
printf("Built Huffman table with
%u codes\n", table_size);
free(table);
}
Compilación con ASAN:
clang-19 -g -O0 -fsanitize=address -o vuln_parser_asan vuln_parser.c
Creación de Input Malicioso:</p>
<h1 id="usrbinenv-python3">!/usr/bin/env python3</h1>
<p>import struct</p>
<h1 id="table_size-512-causa-overflow-de-256-bytes">table_size = 512 (causa overflow de 256 bytes)</h1>
<p>payload = struct.pack('&lt;I', 512)</p>
<h1 id="tamano-512-bytes">Tamaño: 512 bytes</h1>
<p>payload += b'A' * 512</p>
<h1 id="datos-de-overflow">Datos de overflow</h1>
<p>with open('crash_heap_overflow.bin', 'wb') as f:
f.write(payload)
Salida de ASAN:
==37160==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x511000000140 at pc 0x56d6a37d0f62 bp 0x7ffd9f024440 sp 0x7ffd9f023c00
WRITE of size 512 at 0x511000000140 thread T0</p>
<h1 id="0-0x56d6a37d0f61-in-__asan_memcpy">0 0x56d6a37d0f61 in __asan_memcpy</h1>
<h1 id="1-0x56d6a38147f5-in-build_huffman_table-vuln_parserc165">1 0x56d6a38147f5 in build_huffman_table vuln_parser.c:16:5</h1>
<h1 id="2-0x56d6a38148fe-in-main-vuln_parserc375">2 0x56d6a38148fe in main vuln_parser.c:37:5</h1>
<p>0x511000000140 is located 0 bytes after 256-byte region
[0x511000000040,0x511000000140) allocated by thread T0 here:</p>
<h1 id="1-0x56d6a38147df-in-build_huffman_table-vuln_parserc1222">1 0x56d6a38147df in build_huffman_table vuln_parser.c:12:22</h1>
<p>Interpretación del Reporte ASAN:
Campo
Valor
Significado
Tipo de Bug
heap-buffer-overflow
Desbordamiento de heap
Operación
WRITE of size 512
Escribiendo 512 bytes
Ubicación
vuln_parser.c:16
Línea del bug
Asignación
256‐byte buffer at line 12
Búfer asignado
Overflow
512 ‐ 256 = 256 bytes
Cantidad de overflow
Clasificación de Explotabilidad:</p>
<h1 id="usar-casr-para-clasificacion-automatica">Usar CASR para clasificación automática</h1>
<p>casr-san --stdout -- ./vuln_parser_asan crash_heap_overflow.bin</p>
<h1 id="resultado-esperado">Resultado esperado:</h1>
<h1 id="type-exploitable">"Type": "EXPLOITABLE",</h1>
<h1 id="shortdescription-heap-buffer-overflowwrite">"ShortDescription": "heap-buffer-overflow(write)",</h1>
<p>Evaluación de Explotabilidad: EXPLOITABLE</p>
<hr />
<h3 id="capitulo-3-fuzzing_8">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
Razonamiento: 1. Atacante controla tamaño: table_size viene del input 2. Atacante controla
datos: codes array content 3. Corrupción de heap posible: Puede sobrescribir objetos adyacentes
4. Ruta de explotación: Overflow →Corromper puntero de función o vtable →Hijack de control
flow →RCE
Ejemplo Real Similar: CVE‐2023‐4863 ﴾libWebP Heap Buffer Overflow﴿</p>
<h3 id="372">3.7.2.</h3>
<h3 id="272-caso-de-estudio-analisis-de-useafterfree">2.7.2 Caso de Estudio: Análisis de Use‐After‐Free</h3>
<p>Código Vulnerable:
// vuln_uaf.c - Use-After-Free vulnerability
typedef struct {
char <em>name;
void (</em>process)(void);
// Puntero de función
} Handler;
Handler <em>handler = NULL;
void register_handler(char </em>name) {
handler = malloc(sizeof(Handler));
handler-&gt;name = strdup(name);
handler-&gt;process = default_handler;
}
void unregister_handler(void) {
if (handler) {
free(handler-&gt;name);
free(handler);
// BUG: ¡Debería establecer handler = NULL aquí!
}
}
void call_handler(void) {
if (handler) {
handler-&gt;process();
// UAF: handler ya fue liberado
}
}
Salida de ASAN:
==38664==ERROR: AddressSanitizer: heap-use-after-free on address
0x502000000010 at pc 0x617b2245a953 bp 0x7ffe92f7c160 sp 0x7ffe92f7c158
READ of size 8 at 0x502000000010 thread T0</p>
<h1 id="0-0x617b2245a952-in-call_handler-vuln_uafc4450">0 0x617b2245a952 in call_handler vuln_uaf.c:44:50</h1>
<p>0x502000000010 freed by thread T0 here:</p>
<h1 id="1-0x617b2245a86a-in-unregister_handler-vuln_uafc299">1 0x617b2245a86a in unregister_handler vuln_uaf.c:29:9</h1>
<hr />
<h3 id="capitulo-3-fuzzing_9">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
previously allocated by thread T0 here:</p>
<h1 id="1-0x617b2245a7a5-in-register_handler-vuln_uafc2115">1 0x617b2245a7a5 in register_handler vuln_uaf.c:21:15</h1>
<p>Estrategia de Explotación:
┌─────────────────────────────────────────────────────────────┐
│</p>
<h3 id="explotacion-uaf">EXPLOTACIÓN UAF</h3>
<p>│
├─────────────────────────────────────────────────────────────┤
│
│
│</p>
<h3 id="1-liberacion">1. LIBERACIÓN</h3>
<p>│
│
unregister_handler() libera handler
│
│
pero handler sigue apuntando a memoria liberada
│
│
│
│</p>
<h3 id="2-heap-grooming">2. HEAP GROOMING</h3>
<p>│
│
Atacante realiza asignaciones del mismo tamaño
│
│
for (i = 0; i &lt; 1000; i++) {
│
│
Handler *fake = malloc(sizeof(Handler));
│
│
fake-&gt;process = evil_handler;
│
│
}
│
│
│
│</p>
<h3 id="3-reclamar-memoria">3. RECLAMAR MEMORIA</h3>
<p>│
│
Una de las nuevas asignaciones ocupa la memoria
│
│
liberada, sobrescribiendo handler-&gt;process
│
│
│
│</p>
<h3 id="4-disparar-uaf">4. DISPARAR UAF</h3>
<p>│
│
call_handler() →handler-&gt;process()
│
│
Ejecuta evil_handler en lugar de default_handler
│
│
│
│
5. RESULTADO: Ejecución de código arbitrario
│
└─────────────────────────────────────────────────────────────┘
Evaluación de Explotabilidad: EXPLOITABLE
Nota Importante: Las herramientas automáticas como CASR pueden clasificar esto como
NOT_EXPLOITABLE porque ASAN detecta la lectura del puntero de función antes de la llamada. El
análisis manual demuestra que el control de flujo es hijackable.</p>
<h3 id="373">3.7.3.</h3>
<h3 id="273-caso-de-estudio-integer-overflow-heap-corruption">2.7.3 Caso de Estudio: Integer Overflow →Heap Corruption</h3>
<p>Código Vulnerable:
// vuln_intoverflow.c - Integer overflow leading to heap corruption
void process_image(uint32_t width, uint32_t height, uint8_t *data) {
// Integer overflow: 65536 * 65536 = 0 (32-bit overflow)</p>
<hr />
<h3 id="capitulo-3-fuzzing_10">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
size_t pixel_count = width * height;
size_t buffer_size = pixel_count * 4;
printf("Allocating
%zu bytes for
%ux %u image\n",
buffer_size, width, height);
uint8_t *buffer = malloc(buffer_size);
// malloc(0) = tiny buffer
// Loop usa bounds "correctos" pero buffer es tiny
for (size_t i = 0; i &lt; (size_t)width * height; i++) {
buffer[i * 4] = data[i
% 1024];
// Massive overflow!
}
free(buffer);
}
int main(void) {
// Dimensiones controladas por atacante
uint32_t width = 0x10000;
// 65536
uint32_t height = 0x10000;
// 65536
// width * height = 0x100000000 →overflow a 0
uint8_t fake_data[1024];
memset(fake_data, 'A', sizeof(fake_data));
process_image(width, height, fake_data);
return 0;
}
Salida de UBSAN + ASAN:
vuln_intoverflow.c:7:32: runtime error: unsigned integer overflow:
65536 * 65536 cannot be represented in type 'uint32_t'
==39011==ERROR: AddressSanitizer: heap-buffer-overflow on address
0x502000000014 at pc 0x5fa5104bd933
WRITE of size 1 at 0x502000000014 thread T0</p>
<h1 id="0-0x5fa5104bd932-in-process_image-vuln_intoverflowc1723">0 0x5fa5104bd932 in process_image vuln_intoverflow.c:17:23</h1>
<p>0x502000000014 is located 3 bytes after 1-byte region
[0x502000000010,0x502000000011) allocated by:</p>
<h1 id="1-malloc-returned-1-byte-due-to-malloc0">1 malloc() returned 1 byte (due to malloc(0))</h1>
<p>Cadena de Explotación:
┌───────────────────────────────────────────────────────────┐
│
1. Integer Overflow
│
│
width * height = 0x10000 * 0x10000 = 0
│
│
(overflow de 32 bits, envuelve a 0)
│</p>
<hr />
<h3 id="capitulo-3-fuzzing_11">CAPÍTULO 3. FUZZING</h3>
<p>Bitácora Red Team
│
│
│
2. Bajo-allocación
│
│
malloc(0) asigna chunk tiny
│
│
│
│
3. Loop con bounds originales
│
│
Loop itera 4 mil millones de veces
│
│
(usando valor sin overflow de 64-bit)
│
│
│
│
4. Heap Corruption
│
│
Escribe mucho más allá del buffer asignado
│
│
Corrompe metadatos de heap y objetos adyacentes
│
└───────────────────────────────────────────────────────────┘
Evaluación de Explotabilidad: EXPLOITABLE
Ejemplo Real Similar: CVE‐2024‐38063 ﴾Windows TCP/IP Integer Underflow RCE﴿</p>
<h3 id="38">3.8.</h3>
<h3 id="28-desarrollo-de-harnesses-de-fuzzing">2.8 Desarrollo de Harnesses de Fuzzing</h3>
<p>Un harness de fuzzing es el código que conecta el fuzzer con el target API. Un harness bien diseñado
es crítico para fuzzing efectivo.
Harness Malo vs Harness Bueno:
// HARNESS MALO: Lento, ineficiente
int main(int argc, char <em><em>argv) {
FILE </em>f = fopen(argv[1], "rb");
// I/O de archivo cada iteración
// ... leer archivo ...
// ... llamar API target ...
fclose(f);
return 0;
}
// HARNESS BUENO: Rápido, in-process
extern "C" int LLVMFuzzerTestOneInput(const uint8_t </em>data, size_t size) {
// Buffer de memoria directo, sin I/O
// Se llama miles de veces por segundo en el mismo proceso
target_api(data, size);
return 0;
}</p>
<h3 id="381">3.8.1.</h3>
<h3 id="281-ejemplo-harness-para-parser-json">2.8.1 Ejemplo: Harness para Parser JSON</h3>
<p>// fuzz_json.c - Harness para fuzzing de json-c</p>
<h1 id="include_4">include <json-c/json.h></h1></div>
            </div>
            
            <div class="page-nav">
                <a href="02-clases-vulnerabilidades.html"><i class="fas fa-arrow-left"></i>Capítulo 02: Clases de Vulnerabilidades</a>
                <a href="04-patch-diffing.html">Capítulo 04: Patch Diffing<i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }
        
        hljs.highlightAll();
        
        const currentPath = window.location.pathname;
        const fileName = currentPath.split('/').pop().replace('.html', '');
        
        document.querySelectorAll('.nav-item').forEach(item => {
            const href = item.getAttribute('href');
            if (href && href.replace('.html', '') === fileName) {
                item.classList.add('active');
            }
        });
        
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
