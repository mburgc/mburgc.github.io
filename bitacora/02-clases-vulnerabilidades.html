<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 02: Clases de Vulnerabilidades | Bitácora Red Team</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Lato:wght@300;400;700&family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        :root {
            --primary-color: #c62828;
            --primary-dark: #8e0000;
            --secondary-color: #212121;
            --accent-color: #ff5252;
            --text-color: #e0e0e0;
            --text-muted: #9e9e9e;
            --bg-dark: #121212;
            --bg-card: #1a1a1a;
            --bg-hover: #252525;
            --border-color: #333333;
            --sidebar-width: 280px;
            --code-bg: #0d0d0d;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(145deg, #0a0a0a 0%, #151515 50%, #0d0d0d 100%);
            color: var(--text-color);
            line-height: 1.8;
            min-height: 100vh;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(198, 40, 40, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(198, 40, 40, 0.05) 0%, transparent 40%);
            pointer-events: none;
            z-index: -1;
        }
        
        .layout { display: flex; min-height: 100vh; }
        
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg-dark); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 3px; }
        
        .sidebar-header {
            padding: 20px;
            background: linear-gradient(180deg, var(--primary-dark) 0%, var(--secondary-color) 100%);
            color: white;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .sidebar-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            margin: 0;
        }
        
        .sidebar-header p {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 5px;
        }
        
        .nav-section {
            padding: 15px 0;
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .nav-item:hover {
            background: var(--bg-hover);
            color: var(--text-color);
            border-left-color: var(--accent-color);
        }
        
        .nav-item.active {
            background: rgba(198, 40, 40, 0.15);
            border-left-color: var(--primary-color);
            font-weight: 600;
            color: var(--accent-color);
        }
        
        .nav-item i { width: 18px; text-align: center; color: var(--text-muted); }
        .nav-item.active i { color: var(--accent-color); }
        
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 40px 50px;
            max-width: calc(100vw - var(--sidebar-width));
        }
        
        .content-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .content-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2rem;
            color: var(--text-color);
        }
        
        .section h2 {
            font-family: 'Montserrat', sans-serif;
            color: var(--accent-color);
            margin: 30px 0 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.4rem;
        }
        
        .section h3, .section h4 {
            color: var(--text-color);
            margin: 25px 0 15px;
            font-weight: 600;
        }
        
        .section p { margin-bottom: 15px; text-align: justify; color: #bdbdbd; }
        
        .section a {
            color: var(--accent-color);
            text-decoration: none;
            border-bottom: 1px dotted var(--accent-color);
            transition: all 0.2s;
        }
        
        .section a:hover { color: var(--primary-color); }
        
        .section ul, .section ol { margin: 15px 0 15px 25px; color: #bdbdbd; }
        .section li { margin-bottom: 8px; }
        .section li::marker { color: var(--primary-color); }
        
        .section pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .section code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
        }
        
        .section table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .section th, .section td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }
        
        .section th {
            background: var(--bg-card);
            color: var(--accent-color);
            font-weight: 600;
        }
        
        .section tr:nth-child(even) { background: rgba(255, 255, 255, 0.02); }
        .section tr:hover { background: rgba(198, 40, 40, 0.08); }
        
        .page-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
            padding-top: 25px;
            border-top: 1px solid var(--border-color);
        }
        
        .page-nav a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 24px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-muted);
            transition: all 0.3s ease;
        }
        
        .page-nav a:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(198, 40, 40, 0.3);
        }
        
        .page-nav a.disabled { opacity: 0.4; pointer-events: none; }
        
        @media (max-width: 900px) {
            .sidebar { transform: translateX(-100%); }
            .sidebar.open { transform: translateX(0); }
            .main-content { margin-left: 0; padding: 70px 20px 30px; }
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-shield-alt"></i> Bitácora Red Team</h1>
                <p>Explotación Moderna del Kernel de Linux</p>
            </div>
            <nav class="nav-section">
                
            <a href="01-introduccion.html" class="nav-item">
                <i class="fas fa-book"></i> 01: Introducción
            </a>
            <a href="02-clases-vulnerabilidades.html" class="nav-item active">
                <i class="fas fa-bug"></i> 02: Clases de Vulnerabilidades
            </a>
            <a href="03-fuzzing.html" class="nav-item">
                <i class="fas fa-flask"></i> 03: Fuzzing
            </a>
            <a href="04-patch-diffing.html" class="nav-item">
                <i class="fas fa-code-branch"></i> 04: Patch Diffing
            </a>
            <a href="05-analisis-crashes.html" class="nav-item">
                <i class="fas fa-exclamation-triangle"></i> 05: Análisis de Crashes
            </a>
            </nav>
        </aside>
        
        <main class="main-content">
            <div class="content-header">
                <h1>Capítulo 02: Clases de Vulnerabilidades</h1>
            </div>
            
            <div class="section">
                <p>Capítulo 2</p>
<p>Clases de Vulnerabilidades</p>
<p>Estecapítulodocumentalasprincipalesclasesdevulnerabilidadesencontradasensistemasopera-</p>
<p>tivos y aplicaciones, con énfasis particular en el contexto de kernel y sistemas de bajo nivel. Cada</p>
<p>entradaincluyedescripcióntécnica,casosdeestudioreales,impactoymitigacionesaplicables.</p>
<p>Objetivo: Comprender las clases primarias de vulnerabilidades de corrupción de memoria y su</p>
<p>impactoenelmundoreal.</p>
<p>RecursosdeLecturaRecomendados:-“TheArtofSoftwareSecurityAssessment”porMarkDowd,</p>
<p>John McDonald, Justin Schuh - Capítulo 5: Memory Corruption - Memory Corruption: Examples,</p>
<p>Impact, and 4 Ways to Prevent It - Microsoft Security Research: Memory Safety - Google Project</p>
<p>ZeroBlog-Hallazgosrecientesdecorrupcióndememoria</p>
<ol>
  <li>1. 1. 1 Fundamentos de Corrupción de Memoria</li>
</ol>
<p>La corrupción de memoria continúa siendo una de las clases de vulnerabilidades más críticas y</p>
<p>prevalentesensoftwareescritoenC/C++.Apesardedécadasdeinvestigaciónenseguridad,estos</p>
<p>bugspersistendebidoalacomplejidadinherentedelagestiónmanualdememoria.</p>
<p>ConceptosClave:-¿Quéeslacorrupcióndememoriayporquéimporta?Lacorrupcióndeme-</p>
<p>moria ocurre cuando un programa modifica memoria de maneras no intencionadas, permitiendo</p>
<p>a atacantes alterar el estado del programa y potencialmente obtener control de ejecución. - Pi-</p>
<p>la (Stack): Región de memoria para variables locales y direcciones de retorno. Su estructura LIFO</p>
<p>(Last-In-First-Out) la hace vulnerable a desbordamientos que pueden sobrescribir direcciones de</p>
<p>retorno. - Heap: Región de memoria dinámica gestionada por el allocator (malloc/free). Los me-</p>
<p>tadatos del heap y objetos adyacentes pueden ser corrompidos por desbordamientos. - Ciclo de</p>
<p>Vida de Memoria: Asignación → Uso → Liberación. Los errores en cualquier fase pueden llevar a</p>
<p>vulnerabilidades.</p>
<ol>
  <li>1.1. 1. 1.1 Desbordamiento de Búfer en Pila (Stack Buffer Overflow)</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Un desbordamiento de búfer en pila (stack buffer overflow) ocurre cuando un programa escribe</p>
<p>más datos en un búfer ubicado en la pila de los que este puede contener. Esto provoca la sobres-</p>
<p>crituradememoriaadyacente,incluyendodatoscríticoscomodireccionesderetorno,permitiendo</p>
<p>potencialmenteredirigirlaejecucióndelprograma.</p>
<p>Mecánica del Ataque:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ LAYOUT DE PILA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ [Direcciones Altas] │</p>
<p>│ ┌─────────────────┐ │</p>
<p>│ │ Dirección de │ ← Sobrescrita por atacante │</p>
<p>│ │ Retorno │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Frame Pointer │ ← También corrompido │</p>
<p>│ │ Guardado │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Variables │ │</p>
<p>│ │ Locales │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Búfer[64] │ ← Desbordamiento ocurre aquí │</p>
<p>│ │ │ │</p>
<p>│ └─────────────────┘ │</p>
<p>│ [Direcciones Bajas] │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-27130 — QNAP QTS/QuTS Hero</p>
<p>Campo Detalle</p>
<p>Producto Afectado QNAPQTSyQuTShero</p>
<p>Tipo StackBufferOverflow</p>
<p>Vector Interfazdeadministraciónweb</p>
<p>Severidad Crítica</p>
<p>PoC Disponible github. com/watchtowrlabs/CVE-2024-27130</p>
<p>El Bug</p>
<p>Los sistemas operativos QTS y QuTS hero de QNAP contenían múltiples vulnerabilidades de copia</p>
<p>debúferdondefuncionesinsegurascomostrcpy()seutilizabanparacopiarentradasuministrada</p>
<p>por el usuario a búferes de tamaño fijo en la pila sin validación de tamaño adecuada. Las vulnera-</p>
<p>bilidadesafectabanlainterfazdeadministraciónwebyloscomponentesdemanejodearchivos.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Reconocimiento:Atacanteidentificaendpointvulnerableeninterfazdeadministraciónweb</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>Preparación:Construccióndepayloadconentradasobredimensionada</li>
  <li>Explotación: Envío de solicitud especialmente diseñada con datos que exceden el tamaño</li>
</ol>
<p>delbúfer</p>
<ol>
  <li>Corrupción: Losdatosnoverificadosdesbordanelbúferenpila,sobrescribiendo:</li>
</ol>
<p>Variableslocalesadyacentes</p>
<p>Framepointerguardado</p>
<p>Direcciónderetorno</p>
<ol>
  <li>Control de Ejecución: Cuando la función retorna, el flujo de ejecución se redirige a código</li>
</ol>
<p>controladoporelatacante</p>
<p>Impacto</p>
<p>EjecuciónremotadecódigoconlosprivilegiosdelservicioQNAP(típicamenteroot)</p>
<p>ControlcompletodeldispositivoNAS,permitiendo:</p>
<p>• Accesoatodoslosdatosalmacenados</p>
<p>• Pivoteoaotrosrecursosdered</p>
<p>• Instalacióndebackdoorspersistentes</p>
<p>RiesgocríticoparainfraestructuraempresarialdondelosNASalmacenandatossensibles</p>
<p>Mitigación</p>
<p>QNAP lanzó QTS 5. 1.7. 2770 build 20240520 y QuTS hero h5. 1.7. 2770 build 20240520 en mayo de</p>
<p>2024: - Reemplazo de funciones de copia de cadenas inseguras (strcpy, sprintf) con alternativas</p>
<p>converificacióndelímites(strncpy,snprintf)-Implementacióndevalidacióndeentradaadicional</p>
<p>-Habilitacióndeproteccionesdecompilador(stackcanaries)</p>
<p>Observaciones</p>
<p>Los desbordamientos de pila siguen siendo comunes en: - Dispositivos embebidos con código</p>
<p>legacyC/C++-SistemasNASconinterfacesdeadministraciónexpuestasaInternet-Aplicaciones</p>
<p>quenohanadoptadoAPIssegurasmodernas</p>
<p>Son particularmente peligrosos cuando: - Proporcionan el punto de entrada inicial para cadenas</p>
<p>de ataque sofisticadas contra infraestructura empresarial - No tienen protecciones de compilador</p>
<p>habilitadas(ASLR,DEP,stackcanaries)</p>
<ol>
  <li>1.2. 1. 1.2 Uso Después de Liberación (Use-After-Free / UAF)</li>
</ol>
<p>Descripción General</p>
<p>Una vulnerabilidad de uso después de liberación (Use-After-Free) ocurre cuando un programa con-</p>
<p>tinúa usando un puntero después de que la memoria a la que apunta ha sido liberada. Esto crea</p>
<p>un “puntero colgante” (dangling pointer) que puede ser explotado controlando cuidadosamente</p>
<p>lasasignacionesdelheapparacolocardatoscontroladosporelatacantedondeelobjetoliberado</p>
<p>residíaanteriormente.</p>
<p>Mecánica del Bug:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ CICLO DE VIDA UAF │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<h2>│ 1. ASIGNACIÓN │</h2>
<p>│ obj = malloc(sizeof(Object)); │</p>
<p>│ obj->vtable = &legitimate_vtable; │</p>
<h2>│ 2. USO LEGÍTIMO │</h2>
<p>│ obj->method(); // Llama función via vtable │</p>
<h2>│ 3. LIBERACIÓN │</h2>
<p>│ free(obj); // Memoria liberada, pero... │</p>
<p>│ // ¡El puntero 'obj' aún existe! │</p>
<p>│ 4. REASIGNACIÓN (por atacante) │</p>
<p>│ attacker_data = malloc(sizeof(Object)); │</p>
<p>│ // Mismo tamaño → puede obtener la misma ubicación │</p>
<p>│ attacker_data->vtable = &malicious_vtable; │</p>
<h2>│ 5. USO DESPUÉS DE LIBERACIÓN │</h2>
<p>│ obj->method(); // ¡Llama función del atacante! │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-2883 — Chrome ANGLE</p>
<p>Campo Detalle</p>
<p>Producto Afectado GoogleChrome(componenteANGLE)</p>
<p>Tipo Use-After-Free</p>
<p>Vector Páginawebmaliciosa</p>
<p>Severidad Crítica</p>
<p>Código ExplotableRemotamente Sí,sininteraccióndelusuario</p>
<p>El Bug</p>
<p>El componente ANGLE (Almost Native Graphics Layer Engine) de Google Chrome, que traduce lla-</p>
<p>madas de API OpenGL ES a DirectX, Vulkan o OpenGL nativo, contenía una vulnerabilidad de uso</p>
<p>después de liberación. El bug ocurría cuando los contextos WebGL eran destruidos mientras aún</p>
<p>estabanreferenciadosporoperaciones gráficaspendientes,dejandopunteros colgantesaobjetos</p>
<p>gráficosliberados.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Preparación del Entorno:</li>
</ol>
<p>AtacantecreapáginaHTMLmaliciosaconcódigoJavaScriptWebGL</p>
<p>Elcódigomanipulalacreaciónydestruccióndecontextosgráficos</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>// Concepto simplificado (no es el exploit real):</p>
<p>let ctx = canvas. getContext('webgl');</p>
<p>// Iniciar operación gráfica asíncrona</p>
<p>ctx. bindBuffer(ctx. ARRAY_BUFFER, buffer);</p>
<p>// Destruir contexto mientras operación está pendiente</p>
<p>ctx = null;</p>
<p>// Garbage collection libera el contexto</p>
<p>// pero operación pendiente aún tiene referencia</p>
<ol>
  <li>Heap Feng-Shui:</li>
</ol>
<p>Usartécnicasdeheapsprayparacontrolarasignaciones</p>
<p>Asignarobjetosdelmismotamañoqueelobjetoliberado</p>
<p>Colocardatoscontroladosporatacanteenubicaciónliberada</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>CuandocódigodeANGLEusaelpunterocolgante,accedeadatosdelatacante</p>
<p>Elatacantecolocaunobjetofalsoconvtablemaliciosa</p>
<p>Lapróximallamadaamétodovirtualejecutacódigodelatacante</p>
<p>Impacto</p>
<p>EjecuciónremotadecódigovíapáginawebmaliciosaconNOinteraccióndelusuariomásallá</p>
<p>devisitarlapágina</p>
<p>Al colocar un objeto falso en la memoria liberada, el atacante puede secuestrar el flujo de</p>
<p>control</p>
<p>Ejecutarcódigoarbitrarioenelprocesodelrenderer</p>
<p>Puedeencadenarseconexploitsdeescapedesandboxparacompromisocompletodelsiste-</p>
<p>Mitigación</p>
<p>Google Chrome 123. 0.6312. 86 (lanzado marzo 2024) corrigió la vulnerabilidad: - Implementación</p>
<p>degestiónadecuadadeltiempodevidaparaobjetosgráficos-Añadidoconteodereferenciaspara</p>
<p>prevenirdestrucciónprematuradeobjetosaúnenuso-Validaciónadicionalantesdeusarpunteros</p>
<p>aobjetosgráficos</p>
<p>Observaciones</p>
<p>Las vulnerabilidades UAF son particularmente peligrosas en: - Navegadores: Aplicaciones C++</p>
<p>complejasdondeeltiempodevidadeobjetosesdifícilderastrear-SubsistemasGráficos:ANGLE,</p>
<p>Skiaysimilaresmanejancontenidonoconfiableytienengestióndeestadocompleja-Códigocon</p>
<p>Callbacks Asíncronos:Dondeelordendeejecuciónesdifícildepredecir</p>
<p>Son un objetivo favorito de atacantes avanzados porque: - Ofrecen control fino sobre la ejecución</p>
<p>del programa - Son difíciles de detectar con análisis estático - Las mitigaciones modernas (ASLR)</p>
<p>puedenserevadidascontécnicasdeheapmanipulation</p>
<ol>
  <li>1.3. 1. 1.3 Desbordamiento de Búfer en Heap (Heap Buffer Overflow)</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Similaralosdesbordamientosdepila,losdesbordamientosdeheapocurrencuandounprograma</p>
<p>escribemásalládeloslímitesdeunbúferasignadodinámicamenteenelheap. Enlugardecorrom-</p>
<p>per frames de pila, los desbordamientos de heap típicamente corrompen metadatos del heap o</p>
<p>objetosadyacentes,llevandoacorrupcióndememoriacuandoelallocatorposteriormenteprocesa</p>
<p>lasestructurascorrompidas.</p>
<p>Mecánica del Desbordamiento de Heap:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ LAYOUT DE HEAP │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ┌─────────────────────────────────────────┐ │</p>
<p>│ │ Chunk Header (metadatos del allocator) │ │</p>
<p>│ ├─────────────────────────────────────────┤ │</p>
<p>│ │ Búfer Vulnerable [100 bytes] │ │</p>
<p>│ │ │ │</p>
<p>│ │ ════════════════════════════════════════│← Límite │</p>
<h2>│ │ OVERFLOW →→→→→→→→→→→→→→→→→→→→→→→→→→→→ │ │</h2>
<p>│ └─────────────────────────────────────────┘ │</p>
<p>│ ┌─────────────────────────────────────────┐ │</p>
<p>│ │ Chunk Header (CORROMPIDO) ←←←←←←←←←←← │← Corrupción │</p>
<p>│ ├─────────────────────────────────────────┤ │</p>
<p>│ │ Objeto Adyacente │ │</p>
<p>│ │ - vtable * │← O corrupción │</p>
<p>│ │ - function_ptr │ de objeto │</p>
<p>│ │ - data fields │ │</p>
<p>│ └─────────────────────────────────────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-4863 — libWebP</p>
<p>Campo Detalle</p>
<p>Producto Afectado libWebP(Chrome,Firefox,Edge,múltiplesapps)</p>
<p>Tipo HeapBufferOverflow</p>
<p>Vector ImagenWebPmaliciosa</p>
<p>Severidad Crítica</p>
<p>PoC Disponible github. com/mistymntncop/CVE-2023-4863</p>
<p>El Bug</p>
<p>LabibliotecalibWebP,utilizadaporChrome,Firefox,Edgeymuchasotrasaplicacionesparaproce-</p>
<p>sar imágenes WebP, contenía un desbordamiento de heap en la función BuildHuffmanTable(). Al</p>
<p>parsearimágenesWebPespecialmentediseñadascondatosdecodificaciónHuffmanmalformados,</p>
<p>lafunciónescribíamásalládeloslímitesdelbúferasignado.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Vector de Entrada:</li>
</ol>
<p>AtacanteembebeimagenWebPmaliciosaenpáginaweb</p>
<p>Olaenvíavíaaplicacionesdemensajería(WhatsApp,Telegram,Signal)</p>
<p>Oincluyeendocumento(email,Word,PDF)</p>
<ol>
  <li>Trigger:</li>
</ol>
<p>Navegador/aplicacióndevíctimaintentadecodificarlaimagen</p>
<p>ParserWebPprocesadatosHuffmanmalformados</p>
<p>BuildHuffmanTable()calculatamañodetablaincorrectamente</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>Eldesbordamientocorrompemetadatosdelheap</p>
<p>Ocorrompeobjetosadyacentesconfunciónpointers</p>
<p>Atacantecontroladatosdeldesbordamientoparaconseguirprimitivas</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>Ejecucióndecódigoarbitrarioencontextodelproceso</p>
<p>Ennavegadores:códigoejecutaenprocesorenderer</p>
<p>Impacto</p>
<p>Ejecución remota de código sin interacción del usuario más allá de ver una página web o</p>
<p>abrirunaimagen</p>
<p>Zero-dayexplotado activamente antesdesudivulgaciónpública(septiembre2023)</p>
<p>Billones de dispositivos afectados enmúltiplesplataformas:</p>
<p>• Windows,macOS,Linux(desktop)</p>
<p>• Android,iOS(mobile)</p>
<p>• CualquiersoftwareusandolibWebP(Electronapps,etc.)</p>
<p>Por Qué Esta Vulnerabilidades Emblemática:</p>
<ol>
  <li>Riesgo de Cadena de Suministro: Un bug en libWebP afectó docenas de aplicaciones ma-</li>
</ol>
<p>yores</p>
<ol>
  <li>Ubicuidad de Imágenes: Lasimágenessonprocesadasautomáticamenteysonubicuas</li>
  <li>Técnicas Modernas de Heap: Los atacantes combinaron heap overflow con técnicas de by-</li>
</ol>
<p>passdeASLR</p>
<p>Mitigación</p>
<p>libWebP 1. 3.2 (septiembre2023):CorrigióverificacióndelímitesenBuildHuffmanTable()</p>
<p>Chrome116. 0.5845. 187:Parchedeemergencia</p>
<p>Firefox117. 0.1:Parchedeemergencia</p>
<p>Otrossoftwareafectadolanzóactualizacionescoordinadas</p>
<p>Observaciones</p>
<p>Los desbordamientos de heap en parsers de imágenes son particularmente peligrosos porque: -</p>
<p>Las imágenes son procesadas automáticamente sin confirmación del usuario - Son compartidas</p>
<p>rutinariamente y consideradas “seguras” - Parsers de imagen optimizan rendimiento, sacrificando</p>
<p>verificaciones de seguridad - La complejidad de formatos de compresión (Huffman, LZW, etc.) in-</p>
<p>troducebugs</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>1.4. 1. 1.4 Lectura Fuera de Límites (Out-of-Bounds Read / Info Leak)</li>
</ol>
<p>Descripción General</p>
<p>Unalecturafueradelímites(Out-of-BoundsRead)ocurrecuandounprogramaleememoriapasando</p>
<p>los límites de un búfer sin modificarla. Aunque no permite escritura directa, frecuentemente se</p>
<p>utilizapara:-FiltrarpunterosparabypassdeASLR/KASLR-Exponermetadatosdeobjetospara</p>
<p>construir primitivas más poderosas - Revelar diseño de memoria del kernel para explotación</p>
<p>confiable</p>
<p>Rolen Cadenas de Explotación:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ CADENA DE EXPLOTACIÓN TÍPICA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 1. OOB READ │ ← Filtrar direcciones de kernel │</p>
<p>│ │ (Info Leak) │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 2. KASLR BYPASS │ ← Calcular direcciones reales │</p>
<p>│ │ │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 3. WRITE PRIMITIVE│ ← Otra vulnerabilidad (UAF, overflow)│</p>
<p>│ │ │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 4. CODE EXECUTION │ ← Escribir a ubicación conocida │</p>
<p>│ │ │ │</p>
<p>│ └───────────────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-53108 — Linux AMDGPU Display Driver</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(driverAMDDisplay)</p>
<p>Tipo Out-of-BoundsRead(slab-out-of-bounds)</p>
<p>Vector DatosEDID/displaymaliciosos</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Campo Detalle</p>
<p>Severidad Media-Alta</p>
<p>Diff del Parche git. kernel. org</p>
<p>El Bug</p>
<p>En el driver de display AMD del kernel Linux, la ruta de parsing EDID/VSDB (Video Specification</p>
<p>Database)teníaverificacióninsuficientedelímitesalextraeridentificadoresdecapacidades. Cuando</p>
<p>procesaba datos EDID con campos de longitud manipulados, el driver leía más allá de los límites</p>
<p>delbúferEDIDasignado.</p>
<p>ElbugfuedetectadoporKASAN(KernelAddressSanitizer)quereportóaccesoslab-out-of-bounds</p>
<p>durantelaextraccióndedatosdeldisplay.</p>
<p>El Ataque</p>
<p>UnflujodedatosEDID/displaymaliciosamenteconstruidopodría:1. DispararlecturaOOBenespa-</p>
<p>cio de kernel 2. Exponer contenidos de memoria de kernel (incluyendo punteros) 3. Proporcionar</p>
<p>información para evadir KASLR 4. Ser encadenado con otra vulnerabilidad de escritura para explo-</p>
<p>tacióncompleta</p>
<p>Impacto</p>
<p>Divulgación de información: Exposicióndecontenidodememoriadelkernel</p>
<p>Potencial inestabilidad del sistema: Lecturadememoriainválidapuedecausaroops</p>
<p>Habilitador de explotación: Utilizable para evadir KASLR en cadenas de explotación más</p>
<p>complejas</p>
<p>Por Qué las OOB Reads Importan:</p>
<p>En contextos de kernel: - KASLR es una mitigación fundamental contra explotación - Sin info</p>
<p>leak, escritura ciega falla - el atacante necesita saber dónde escribir - OOB reads son el primer</p>
<p>pasodelamayoríadeexploitsmodernosdekernel</p>
<p>Mitigación</p>
<p>Las actualizaciones del kernel ajustaron la validación de longitud: - Verificar que bLength sea >=</p>
<p>tamaño mínimo esperado - Validar offsets antes de acceder a campos - Asegurar que todas las</p>
<p>lecturaspermanezcandentrodeloslímitesdelbúferEDID</p>
<p>Observaciones</p>
<p>Las lecturas OOB puras son valiosas para construir cadenas de explotación confiables: - Proporcio-</p>
<p>nan información necesaria para bypass de ASLR/KASLR - Son frecuentemente la primera etapa de</p>
<p>exploitsmulti-paso-Enkernel,derrotarKASLRespivotalparaexplotaciónconfiable</p>
<ol>
  <li>1.5. 1. 1.5 Uso de Memoria No Inicializada (Uninitialized Memory Use)</li>
</ol>
<p>Descripción General</p>
<p>Usarmemoriadepila/heap/poolantesdequeseainicializadapuedeexponercontenidosresiduales</p>
<p>deoperacionesprevias. Estoscontenidospuedenincluir:-Punterosprevios(direccionesdelkernel</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>parabypassdeKASLR)-Flagsdecapacidad(paraescaladadeprivilegios)-Camposdeestructura</p>
<p>(paraconfusióndetipos)</p>
<p>Por Qué Es Peligroso:</p>
<p>// Código vulnerable - variable no inicializada</p>
<p>void vulnerable_function(struct netlink_msg *msg) {</p>
<p>struct nft_pipapo_match *m; // ← NO INICIALIZADO</p>
<p>// Si algún camino de código no asigna 'm'...</p>
<p>if (some_condition(msg)) {</p>
<p>m = find_match(msg);</p>
<p>// ... pero 'm' se usa incondicionalmente</p>
<p>copy_to_user(response, &m, sizeof(m)); // ← Filtra pila residual</p>
<p>Caso de Estudio: CVE-2024-26581 — Linux Kernel Netfilter</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(subsistemanetfilter)</p>
<p>Tipo UsodeVariableNoInicializada</p>
<p>Vector Mensajesnetlinklocales</p>
<p>Severidad Alta</p>
<p>PoC Disponible sploitus. com/exploit?id=A4D521EE-225F-57D5-8C31-</p>
<h2>9F1C86D066B6</h2>
<p>El Bug</p>
<p>ElsubsistemanetfilterdelkernelLinuxconteníaunavulnerabilidaddevariablenoinicializadaenel</p>
<p>componente nf_tables. Al procesar mensajes netlink para configurar reglas de firewall, la función</p>
<p>nft_pipapo_walk()fallabaeninicializarunavariablelocalantesdesuuso.</p>
<p>Lavariablenoinicializadadepilapodríacontenerdatosresidualesdellamadasafuncionesprevias,</p>
<p>incluyendopunterosdelkernelydireccionesdememoriasensibles.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>ObtenerCapacidades:</li>
</ol>
<p>Atacanteestáenespaciodenombresdeusuarionoprivilegiado</p>
<p>UsernamespacesotorganCAP_NET_ADMIN(defaultenUbuntu,Debian)</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>Enviarmensajesnetlinkespecíficosdeconfiguracióndenf_tables</p>
<p>Causarqueseejecutelarutadecódigoconvariablenoinicializada</p>
<p>Lavariableseleeysecopiadevueltaalespaciodeusuario</p>
<ol>
  <li>RecolectarInformación:</li>
</ol>
<p>Repetireltriggermúltiplesveces</p>
<p>Analizardatosretornados</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Extraerdireccionesdekernel(heap,stack,código)</p>
<ol>
  <li>Explotar con Información:</li>
</ol>
<p>UsardireccionesfiltradasparaevadirKASLR</p>
<p>Combinarconotravulnerabilidaddeescrituradenetfilter</p>
<p>Lograrescaladadeprivilegioscompleta(LPEchain)</p>
<p>Impacto</p>
<p>Divulgación de información →bypassdeKASLR</p>
<p>Lasdireccionesdelkernelfiltradaspermitenexplotaciónconfiabledeotrasvulnerabilidades</p>
<p>ParticularmentepeligrosacuandosecombinaconotrosbugsdenetfilterparacadenasLPE</p>
<p>completas</p>
<p>Peligro del Combo: Netfilter+ User Namespaces</p>
<p>Muchas distribuciones Linux permiten user namespaces no privilegiados por defecto: - Ubuntu:</p>
<p>Habilitadopordefecto-Debian:Habilitadopordefecto-Fedora:Habilitadopordefecto</p>
<p>EstosignificaqueCAP_NET_ADMINestádisponibleparausuariosnoprivilegiados,haciendoquebugs</p>
<p>denetfilterseanexplotablessinprivilegiosroot.</p>
<p>Mitigación</p>
<p>Linuxkernel6. 8-rc1(febrero2024):-Añadióinicializaciónapropiada:struct nft_pipapo_match *m</p>
<p>= NULL; - Habilitó inicializadores designados para estructuras de pila - Habilitó advertencias de</p>
<p>compiladormásestrictas(-Wuninitialized)paranetfilter</p>
<p>Observaciones</p>
<p>Las lecturas de memoria no inicializada son frecuentemente la primera etapa en cadenas de ex-</p>
<p>plotación: - Proporcionan reducciones de entropía para evadir mitigaciones modernas - Son parti-</p>
<p>cularmente valiosas en explotación de kernel donde KASLR es esencial - La combinación de user</p>
<p>namespaces no privilegiados y fugas de netfilter hace esta clase de vulnerabilidad accesible a ata-</p>
<p>canteslocalessinrequerirprivilegiosroot</p>
<ol>
  <li>1.6. 1. 1.6 Errores de Conteo de Referencias (Reference Counting Bugs)</li>
</ol>
<p>Descripción General</p>
<p>Los errores de conteo de referencias ocurren cuando hay incrementos/decrementos incorrectos o</p>
<p>desbordamientosencontadoresquecontrolaneltiempodevidadeobjetos(sistemasdearchivos,</p>
<p>networking,drivers).Estosbugspuedenllevara:-Liberaciónprematura:Objetoliberadomientras</p>
<p>referenciasaúnexisten→UAF-Memoryleak:Objetonuncaliberado→agotamientodememoria</p>
<p>-Double-free:Decrementoexcesivo→corrupcióndeheap</p>
<p>Mecánica de Reference Counting:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ GESTIÓN DE CONTEO DE REFERENCIAS │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ CORRECTO: │</h2>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref = 1 │ ──► │ ref = 2 │ ──► │ ref = 1 │ ──► free() │</p>
<p>│ │ (alloc) │ │ (add) │ │ (drop) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<h2>│ BUG - LIBERACIÓN PREMATURA: │</h2>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref = 1 │ ──► │ ref = 0 │ ──► │ USE │ ← UAF! │</p>
<p>│ │ (alloc) │ │ (drop) │ │ (bug) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<h2>│ BUG - DESBORDAMIENTO DE REFCOUNT: │</h2>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref=MAX │ ──► │ ref = 0 │ ──► │ free() │ ← ¡Aún usado!│</p>
<p>│ │ │ │(overflow)│ │ (wrong) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2022-32250 — Linux Netfilter nf_tables</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(nf_tables)</p>
<p>Tipo ErrordeConteodeReferencias→UAF</p>
<p>Vector Usernamespacesnoprivilegiados</p>
<p>Severidad Crítica</p>
<p>Exploit Público github. com/theori-io/CVE-2022-32250-exploit</p>
<p>El Bug</p>
<p>ElsubsistemanetfilterdelkernelLinux(net/netfilter/nf_tables_api. c)teníaunerrordeconteo</p>
<p>dereferenciasenelcomponentenf_tables. UnaverificaciónincorrectadeNFT_STATEFUL_EXPRfallaba</p>
<p>en rastrear adecuadamente los tiempos de vida de objetos de expresión durante actualizaciones</p>
<p>dereglas,llevandoadestrucciónprematuradeobjetosmientrasreferenciasaúnexistían.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Configuración del Entorno:</li>
</ol>
<p>Atacantecreausernamespacenoprivilegiado</p>
<p>EstootorgaCAP_NET_ADMINdentrodelnamespace</p>
<p>Permitemanipularreglasdenf_tables</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>Crearexpresionesstatefulenreglasdenf_tables</p>
<p>Modificarreglasensecuenciasespecíficas</p>
<p>Causarqueelkerneldecrementerefcountincorrectamente</p>
<ol>
  <li>Condición UAF:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Elkernelliberaunobjetodeexpresión</p>
<p>Otrareferenciaalobjetoaúnexiste</p>
<p>Elcódigocontinúausandoelpunterocolgante</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>Usartécnicasdeheapsprayparareclamarlamemorialiberada</p>
<p>Colocardatoscontroladosporatacanteenlaubicación</p>
<p>Usarelpunterocolganteparalograrlectura/escrituraarbitraria</p>
<ol>
  <li>Escalada de Privilegios:</li>
</ol>
<p>Modificarcredencialesdelproceso(task_struct->cred)</p>
<p>Osobrescribirpunterosdefuncióndelkernel</p>
<p>Obtenerrootdesdeusuarionoprivilegiado</p>
<p>Impacto</p>
<p>Escalada de privilegios local de cualquier usuario a root en sistemas que permiten names-</p>
<p>pacesnoprivilegiados</p>
<p>La primitiva UAFpuedeexplotarseparalectura/escrituraarbitrariadememoriadelkernel</p>
<p>AfectókernelsLinuxdesde4. 1(2015)hasta5. 18. 1(2022)-másde7añosdevulnerabilidad</p>
<p>Exploit público disponible haceestavulnerabilidadespecialmentepeligrosa</p>
<p>Distribuciones Afectadas (namespaces habilitados por defecto): -Ubuntu-Debian</p>
<p>-Fedora-Ymuchasotras</p>
<p>Mitigación</p>
<p>Linuxkernel5. 18. 2+corrigiólalógicadeconteodereferencias:-Añadióincrementos/decrementos</p>
<p>derefcountexplícitosenlospuntosapropiadosdelcódigo-Asegurórastreoadecuadodeltiempo</p>
<p>devidaduranteoperacionesdereglas-Agregóvalidacionesadicionalesenexpresionesstateful</p>
<p>Observaciones</p>
<p>Losbugsdeconteodereferencias:-Sonsutiles:Puedenllevaracondicionesdeliberaciónprema-</p>
<p>tura → use-after-free - O desbordamiento de refcount → free mientras referencias permanecen</p>
<p>- Son particularmente peligrosos en código del kernel donde gestión del tiempo de vida de ob-</p>
<p>jetos es crítica - La accesibilidad vía user namespaces no privilegiados hizo esta vulnerabilidad</p>
<p>particularmenteimpactanteparaescaladadeprivilegioslocal</p>
<ol>
  <li>1.7. 1. 1.7 Desreferencia de Puntero Nulo (NULL Pointer Dereference)</li>
</ol>
<p>Descripción General</p>
<p>DesreferenciarunpunteroNULLencódigoprivilegiado. Mientraslossistemasmodernostípicamen-</p>
<p>te previenen el mapeo de páginas NULL en espacio de usuario (mitigando técnicas históricas de</p>
<p>escalada de privilegios), las desreferencias de puntero NULL en kernel siguen siendo fuente signi-</p>
<p>ficativa de vulnerabilidades de: - Denegación de Servicio (kernel panic inmediato) - Divulgación</p>
<p>de Información (en algunos contextos) - Escalada de Privilegios (en configuraciones específicas</p>
<p>legacy)</p>
<p>Evolución de la Mitigación:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<h2>│ EVOLUCIÓN DE PROTECCIONES CONTRA NULL DEREF │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ANTES (Linux < 2. 6.23): │</p>
<p>│ ┌─────────────────────────────────────────────────────┐ │</p>
<p>│ │ Espacio de Usuario podía mapear página 0 │ │</p>
<p>│ │ NULL deref → Ejecuta código de atacante → ROOT │ │</p>
<p>│ └─────────────────────────────────────────────────────┘ │</p>
<p>│ DESPUÉS (Linux moderno con mmap_min_addr): │</p>
<p>│ ┌─────────────────────────────────────────────────────┐ │</p>
<p>│ │ Página 0 no puede ser mapeada por usuario │ │</p>
<p>│ │ NULL deref → Kernel Panic → DoS (pero no RCE) │ │</p>
<p>│ └─────────────────────────────────────────────────────┘ │</p>
<p>│ /proc/sys/vm/mmap_min_addr = 65536 (típico) │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-52434 — Linux SMB Client</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(clienteSMB/CIFS)</p>
<p>Tipo DesreferenciadePunteroNulo</p>
<p>Vector ServidorSMBmalicioso</p>
<p>Severidad Alta(CVSS8. 0)</p>
<p>Vectorde Ataque Redadyacente</p>
<p>El Bug</p>
<p>La implementación del cliente SMB del kernel Linux contenía una vulnerabilidad de desreferencia</p>
<p>de puntero nulo en la función smb2_parse_contexts(). Al parsear respuestas del servidor durante</p>
<p>elestablecimientodeconexiónSMB2/SMB3,elcódigofallabaenvalidarapropiadamenteoffsetsy</p>
<p>longitudesdeestructurasdecontextodecreaciónantesdedesreferenciarpunteros.</p>
<p>Loscontextosmalformadosconoffsetsinválidospodíancausarqueelkernelaccedieraadirecciones</p>
<p>dememorianomapeadas,disparandounadesreferenciadepunteronulo.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Vector de Entrada:</li>
</ol>
<p>ServidorSMBmaliciosoocomprometidoenlared</p>
<p>Oataqueman-in-the-middlemodificandorespuestasSMB</p>
<ol>
  <li>Trigger:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Servidor envía respuestas SMB2_CREATE con estructuras de contexto de creación inváli-</p>
<p>Offsetsapuntanfueradelosdatosválidos</p>
<p>OlongitudescalculanadireccionesNULL</p>
<ol>
  <li>Crash:</li>
</ol>
<p>ClienteLinuxintentamontarelshareoaccederaarchivos</p>
<p>Kernelparseacontextosmalformadossinverificacióndelímites</p>
<p>Accesoadireccióninválida→kernelpanic</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>BUG: unable to handle page fault for address: ffff8881178d8cc3</p>
<p>#PF: supervisor read access in kernel mode</p>
<p>Call Trace:</p>
<p>smb2_parse_contexts+0x...</p>
<p>Impacto</p>
<p>Denegación de servicio afectandokernelsLinuxdesde5. 3hasta6. 7-rc5</p>
<p>La desreferenciade punteronulo causabakernelpanicinmediato</p>
<p>Cualquier usuario con permiso para montar shares SMB podíadispararlavulnerabilidad</p>
<p>Explotable en entornos multi-usuario dondemontajeSMBestápermitido</p>
<p>ContextosdeExplotación:-Redcorporativa:UsuariomaliciosolevantaservidorSMBfalso-WiFi</p>
<p>público: Atacante hace MITM de conexiones SMB - Red comprometida: Servidor SMB legítimo</p>
<p>comprometidoenvíarespuestasmaliciosas</p>
<p>Mitigación</p>
<p>Parches del kernel Linux (versiones 5. 4.277, 5. 10. 211, 5. 15. 150, 6. 1.80 y 6. 6.8+): - Añadieron vali-</p>
<p>dación comprehensiva de offsets de contextos de creación - Verifican que longitudes no excedan</p>
<p>límitesdelbúfer-Aseguranquetodaaritméticadepunterospermanezcadentrodelímitesasigna-</p>
<p>Observaciones</p>
<p>Lasdesreferenciasdepunteronuloenparsersdeprotocolosderedsonparticularmentepeligrosas</p>
<p>porque:-Puedenserdisparadasremotamenteporservidoresmaliciosos-Omedianteataques</p>
<p>MITMmodificandotráficodered-Mientraslasproteccionesmodernasdelkernelprevienenel</p>
<p>mapeo de página NULL (mitigando RCE histórico) - El impacto de DoS permanece crítico para</p>
<p>disponibilidad</p>
<ol>
  <li>1.8. 1. 1.8 Conclusiones de Corrupción de Memoria</li>
</ol>
<p>Hallazgos Clave:</p>
<ol>
  <li>Lacorrupcióndememoriasiguesiendoprevalente:Apesardedécadasdeinvestigaciónen</li>
</ol>
<p>seguridad, los bugs de corrupción de memoria continúan plagando software, especialmente</p>
<p>enbasesdecódigoC/C++.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>La defensa en profundidad es esencial: Cada ejemplo del mundo real muestra atacantes</li>
</ol>
<p>evadiendomúltiplesmecanismosdeprotección(DEP,ASLR,CET,XFG,safe-linking).</p>
<ol>
  <li>Lasmitigacionesmodernaselevanlabarreraperonoeliminanelriesgo:Mientrastecno-</li>
</ol>
<p>logíascomoCETshadowstackysafe-linkingdificultanlaexplotación,atacantesdeterminados</p>
<p>continúanencontrandobypasses.</p>
<ol>
  <li>Lascausasraízsonsimilares,peroloscontextosdifieren:Bugsdestack,heapyUAFcom-</li>
</ol>
<p>parten causas raíz comunes (verificación inadecuada de límites, gestión de tiempo de vida)</p>
<p>perorequierendiferentestécnicasdeexplotación.</p>
<ol>
  <li>Los componentes legacy permanecen vulnerables: Vulnerabilidades de años de antigüe-</li>
</ol>
<p>dad en parsers de office y manejadores de archivos continúan siendo explotadas debido a</p>
<p>ciclosdeparcheolentos.</p>
<p>Preguntasde Discusión:</p>
<ol>
  <li>¿Qué puntos en común ves a través de las clases de vulnerabilidades de corrupción de me-</li>
</ol>
<p>moriacubiertas?</p>
<ol>
  <li>¿Por qué persisten las vulnerabilidades de corrupción de memoria a pesar de décadas de</li>
</ol>
<p>investigaciónenlenguajesmemory-safe?</p>
<ol>
  <li>¿Cómodifierenlastécnicasdeexplotaciónentrevulnerabilidadesdestack,heapyUAF?</li>
  <li>¿Qué mecanismos de defensa fueron evadidos en cada ejemplo, y qué nos dice eso sobre el</li>
</ol>
<p>estadoactualdelamitigacióndeexploits?</p>
<ol>
  <li>2. 1. 2 Vulnerabilidades Lógicas y Condiciones de Carrera</li>
</ol>
<p>Las vulnerabilidades lógicas no involucran corrupción de memoria pero pueden ser igualmente</p>
<p>peligrosas. Estaseccióncubrecondicionesdecarrera,bugsTOCTOU,double-fetch,fallasdeauten-</p>
<p>ticación,primitivasdeescrituraarbitrariaymalusodesincronización.</p>
<p>RecursosdeLectura:-“WebApplicationSecurity,2ndEdition”porAndrewHoffman-Capítulo18:</p>
<p>“Business Logic Vulnerabilities” - Portswigger Logic Flaws - Time-of-check Time-of-use (TOCTOU)</p>
<p>Vulnerabilities-Microsoft:AvoidingRaceConditions</p>
<ol>
  <li>2.1. 1. 2.1 Condiciones de Carrera (Race Conditions)</li>
</ol>
<p>Descripción General</p>
<p>Unacondicióndecarreraocurrecuandoelcomportamientodelsoftwaredependedeltimingrelati-</p>
<p>vodeeventos,comoelordenenqueloshilosejecutan. Cuandomúltipleshilosoprocesosacceden</p>
<p>a recursos compartidos sin sincronización apropiada, un atacante puede manipular el timing para</p>
<p>causarcomportamientoinesperado.</p>
<p>Patrones Comunes:</p>
<ol>
  <li>Condiciones de Carrera en Sistema de Archivos: Verificar permisos de un archivo, luego</li>
</ol>
<p>abrirlo(atacanteintercambiaelarchivoentreverificaciónyapertura)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>Double-Fetch: Kernel lee memoria de modo usuario dos veces, atacante la modifica entre</li>
</ol>
<p>lecturas</p>
<ol>
  <li>Primitivas de Sincronización: Uso faltante o incorrecto de locks, mutexes u operaciones</li>
</ol>
<p>atómicas</p>
<p>Caso de Estudio: CVE-2024-26218 — Windows Kernel TOCTOU</p>
<p>Campo Detalle</p>
<p>Producto Afectado WindowsKernel</p>
<p>Tipo CondicióndeCarreraTOCTOU</p>
<p>Vector Local</p>
<p>Severidad Alta(CVSS7. 7)</p>
<p>El Bug</p>
<p>UnacondicióndecarreraTime-of-CheckTime-of-UseenelWindowsKernelpermitíaaunatacante</p>
<p>explotarunaventanadetimingentrelavalidaciónyelusoderecursosdelkernel. Lavulnerabilidad</p>
<p>ocurríacuandoelkernelverificabapermisosoestadosderecursosperonorealizabaatómicamente</p>
<p>la operación subsecuente, permitiendo a un hilo en carrera modificar el estado del recurso entre</p>
<p>verificaciónyuso.</p>
<p>El Ataque (Paso a Paso)</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ ATAQUE TOCTOU │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ KERNEL ATACANTE │</h2>
<p>│ ────── ──────── │</p>
<p>│ │ │ │</p>
<p>│ │ 1. Verificar permisos │ │</p>
<p>│ │ del recurso │ │</p>
<p>│ │ resultado: OK │ │</p>
<p>│ │ ║ │ │</p>
<p>│ │ ║ ═══════════════════ │ │</p>
<p>│ │ ║ VENTANA DE │ 2. Modificar │</p>
<p>│ │ ║ CARRERA │ estado del │</p>
<p>│ │ ║ │ recurso │</p>
<p>│ │ ║ ═══════════════════ │ │</p>
<p>│ │ ▼ │ │</p>
<p>│ │ 3. Usar recurso (ahora │ │</p>
<p>│ │ modificado por atacante) │ │</p>
<p>│ │ │ │</p>
<p>│ │ 4. RESULTADO: Escalada de │ │</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>│ │ privilegios │ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Impacto</p>
<p>EscaladadeprivilegioslocaldeusuariodebajosprivilegiosaSYSTEM</p>
<p>AfectóWindows10,Windows11yWindowsServer2019/2022</p>
<p>Parcheadoenabril2024(MicrosoftPatchTuesday)</p>
<p>Por Qué Es Difícil de Corregir:</p>
<p>Las condiciones de carrera requieren: - Operaciones atómicas de check-and-use - Mecanismos de</p>
<p>bloqueoapropiadosatravésdesubsistemascomplejosdelkernel-Copiadefensivaparaasegurar</p>
<p>que el estado verificado coincida con el estado usado - Muchas operaciones del kernel asumen</p>
<p>ejecuciónsecuencialsinconsiderarmodificaciónconcurrente</p>
<p>Mitigación</p>
<p>Microsoft implementó: - Operaciones atómicas de verificación y uso - Mecanismos de bloqueo</p>
<p>apropiados para recursos compartidos - Copia defensiva para asegurar coincidencia de estado ve-</p>
<p>rificado/usado</p>
<p>Observaciones</p>
<p>Lascondicionesdecarrerasondifícilesdereproducirperoproporcionanexplotaciónconfiablecuan-</p>
<p>do el timing es controlado. Requieren comprensión profunda del modelo de concurrencia del sis-</p>
<p>temaobjetivo.</p>
<ol>
  <li>2.2. 1. 2.2 Vulnerabilidades TOCTOU (Time-of-Check Time-of-Use)</li>
</ol>
<p>Descripción General</p>
<p>TOCTOU es un tipo específico de condición de carrera donde hay una brecha entre verificar una</p>
<p>condición y usar el resultado. Durante esa brecha, la condición puede cambiar, invalidando la veri-</p>
<p>ficación.</p>
<p>Ejemplo Clásico — Ataques con Symlinks:</p>
<p>// Programa vulnerable</p>
<ol>
  <li>if (access("/tmp/important_file", W_OK) == 0) { // VERIFICACIÓN</li>
</ol>
<p>// [VENTANA DE CARRERA] Atacante: ln -s /etc/passwd /tmp/important_file</p>
<ol>
  <li>fd = open("/tmp/important_file", O_WRONLY); // USO</li>
</ol>
<p>write(fd, data, size); // ¡Escribe a /etc/passwd!</p>
<p>Impacto del Mundo Real:</p>
<p>Escalada de Privilegios: Bugs TOCTOU en programas privilegiados permiten a usuarios no</p>
<p>privilegiadosmodificararchivosprotegidos</p>
<p>BypassdeVerificacionesdeSeguridad:Verificacionesdeautenticaciónoautorizaciónpue-</p>
<p>densereludidassielrecursocambiaentreverificaciónyuso</p>
<p>Corrupción de Datos: Modificaciones inesperadas de archivos pueden corromper el estado</p>
<p>delsistema</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Caso de Estudio: CVE-2025-11001/11002 — 7-Zip Symlink Path Traversal</p>
<p>Campo Detalle</p>
<p>Producto Afectado 7-Zip</p>
<p>Tipo TOCTOU/PathTraversalviaSymlink</p>
<p>Vector ArchivoZIPmalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>LavalidaciónimpropiadeobjetivosdesymlinksenlaextraccióndeZIPpermitíatraversaldedirec-</p>
<p>toriosvíasymlinksmaliciosos,habilitandoescriturasfueradeldirectoriodeextracciónprevisto.</p>
<p>El Ataque:</p>
<ol>
  <li>Preparación del Archivo Malicioso:</li>
</ol>
<p>AtacantecreaarchivoZIP/RARespecialmentediseñado</p>
<p>Incluyeunsymlink: link. txt -> ../../../etc/cron. d/malicious</p>
<p>Incluyearchivolink. txtconcontenidomalicioso</p>
<ol>
  <li>Extracción:</li>
</ol>
<p>Usuarioextraearchivoen/home/user/downloads/</p>
<p>7-Zipcreasymlinkqueapuntafueradeldirectorio</p>
<p>Luegoescribecontenidoalsymlink</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>Archivoescritoa/etc/cron. d/malicious</p>
<p>Ejecucióndecódigocomorootcuandocronprocesaelarchivo</p>
<p>Impacto</p>
<p>EscrituraarbitrariadearchivosllevandoapotencialRCEencontextodeusuario</p>
<p>Dependiendodeldirectorioobjetivo(ej.~/.bashrc,/etc/cron. d/,~/.ssh/authorized_keys),</p>
<p>puedepermitirescaladadeprivilegios</p>
<p>Afectaatodoslosusuariosqueextraenarchivosdefuentesnoconfiables</p>
<p>Mitigación</p>
<p>Las actualizaciones abordaron: - Validación de conversión y lógica de symlinks durante extracción</p>
<p>- Verificación de que rutas de destino permanezcan dentro del directorio de extracción - Rechazo</p>
<p>desymlinksqueapuntanfueradelcontextodeextracción</p>
<p>Observaciones</p>
<p>Las vulnerabilidades TOCTOU en parsers de archivos son particularmente peligrosas porque los</p>
<p>usuariosfrecuentementeextraenarchivosdefuentesnoconfiablessinverificaciónadicional.</p>
<ol>
  <li>2.3. 1. 2.3 Vulnerabilidades Double-Fetch</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Un double-fetch ocurre cuando el código del kernel lee memoria de modo usuario dos veces, asu-</p>
<p>miendoquenocambiaráentrelecturas. Unatacanteconmúltipleshilospuedemodificarlamemoria</p>
<p>después de la primera lectura pero antes de la segunda, causando que el código del kernel opere</p>
<p>sobredatosinconsistentes.</p>
<p>Mecánica:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ VULNERABILIDAD DOUBLE-FETCH │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ KERNEL ESPACIO USUARIO (Atacante) │</p>
<p>│ ────── ───────────────────────── │</p>
<p>│ │ │ │</p>
<p>│ │ 1. Primera lectura │ │</p>
<p>│ │ valor = *userptr │ │</p>
<p>│ │ (validar: valor == 1) │ │</p>
<p>│ │ ║ │ │</p>
<p>│ │ ║ ════════════════ │ │</p>
<p>│ │ ║ VENTANA │ 2. *userptr = 999 │</p>
<p>│ │ ║ ════════════════ │ │</p>
<p>│ │ ▼ │ │</p>
<p>│ │ 3. Segunda lectura │ │</p>
<p>│ │ usar *userptr │ │</p>
<p>│ │ (¡ahora es 999!) │ │</p>
<p>│ │ │ │</p>
<p>│ │ 4. Bug: código usa valor │ │</p>
<p>│ │ no validado (999) │ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-4155 — Linux KVM AMD SEV Double-Fetch</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(KVMAMDSEV)</p>
<p>Tipo Double-Fetch→StackOverflow</p>
<p>Vector InvitadoVMmalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>Una condición de carrera double-fetch en la implementación KVM AMD Secure Encrypted Virtua-</p>
<p>lization del kernel Linux. Invitados KVM usando SEV-ES o SEV-SNP con múltiples vCPUs podían</p>
<p>dispararlavulnerabilidadmanipulandomemoriacompartidadeinvitadoqueelhypervisorleedos</p>
<p>vecessinsincronizaciónapropiada.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>El Patróndel Bug:</p>
<p>ElmanejadorVMGEXITenelhypervisorleíamemoriacontroladaporelinvitadoparadeterminarqué</p>
<p>operación realizar. Un atacante podía modificar esta memoria entre la primera lectura (validación)</p>
<p>ylasegundalectura(uso),causandocomportamientoinconsistente.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Primera Lectura: Hypervisor lee memoria del invitado para validar el código de razón de</li>
</ol>
<h2>VMGEXIT</h2>
<ol>
  <li>VentanadeCarrera:ElhilovCPUdelatacantemodificalamemoriadelinvitadoconteniendo</li>
</ol>
<p>elcódigoderazón</p>
<ol>
  <li>Segunda Lectura: Hypervisor lee el valor modificado y procesa una operación diferente a la</li>
</ol>
<p>validada</p>
<ol>
  <li>Resultado:InvocaciónrecursivadelmanejadorVMGEXIT,llevandoadesbordamientodepila</li>
</ol>
<p>Impacto</p>
<p>Denegacióndeservicio(DoS)víadesbordamientodepilaenhypervisor</p>
<p>En configuraciones del kernel sin páginas de guarda de pila (CONFIG_VMAP_STACK), potencial</p>
<p>escape de invitado a host</p>
<p>AfectaentornosdevirtualizaciónconAMDSEVhabilitado</p>
<p>Por Qué Es Difícil de Corregir:</p>
<p>Los double-fetch requieren: - Identificar todas las ubicaciones donde código del hypervisor lee</p>
<p>memoriadelinvitadomúltiplesveces-Copiardatosdelinvitadoamemoriadelhypervisorunavez</p>
<p>-Operarsobrelacopiaestable-Consideracionesderendimientohacenlacopiadefensivacostosa</p>
<p>enrutascalientesdevirtualización</p>
<p>Mitigación</p>
<p>LosparchesdelkernelLinux:-Añadieronsincronizaciónapropiadaparaasegurarqueelcódigode</p>
<p>razón VMGEXIT se lea una vez - Almacenaron el valor en variable local antes de validación y uso -</p>
<p>Añadieronverificacionesparaprevenirinvocaciónrecursivadelmanejador</p>
<p>Observaciones</p>
<p>Las vulnerabilidades double-fetch son particularmente difíciles de corregir y particularmente peli-</p>
<p>grosasencontextosdehypervisordondeelescapeinvitado→hosttieneimpactocrítico.</p>
<ol>
  <li>2.4. 1. 2.4 Fallas Lógicas en Autenticación</li>
</ol>
<p>Descripción General</p>
<p>Bugs en el flujo lógico de verificaciones de autenticación o autorización que permiten a atacantes</p>
<p>evadirlímitesdeseguridadsinexplotarcorrupcióndememoria.</p>
<p>Tipos de Fallas Lógicas de Autenticación:</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Tipo Descripción Ejemplo</p>
<p>Bypass de Accedersincredenciales Solicitudesmalformadas</p>
<p>Autenticación evadenverificación</p>
<p>Escalada Vertical Usuarioseconvierteenadmin Manipulacióndeparámetros</p>
<p>derol</p>
<p>Escalada UsuarioAaccedeadatosdeB IDOR(InsecureDirectObject</p>
<p>Horizontal Reference)</p>
<p>Confusión de Estadodesesióninconsistente Tokensdereseteo</p>
<p>Estado reutilizables</p>
<p>Caso de Estudio: CVE-2024-0012 — Palo Alto PAN-OS Authentication Bypass</p>
<p>Campo Detalle</p>
<p>Producto Afectado PaloAltoNetworksPAN-OS</p>
<p>Tipo BypassdeAutenticación</p>
<p>Vector Interfazwebdeadministración</p>
<p>Severidad Crítica</p>
<p>PoC Disponible github. com/0xjessie21/CVE-2024-0012</p>
<p>El Bug</p>
<p>ElsoftwarePAN-OSdePaloAltoNetworksconteníaunavulnerabilidaddebypassdeautenticación</p>
<p>ensuinterfazwebdeadministración. Lavulnerabilidadpermitíaaunatacantenoautenticadoeva-</p>
<p>dir completamente las verificaciones de autenticación y obtener privilegios de administrador sin</p>
<p>proporcionarningunacredencial.</p>
<p>El Ataque:</p>
<ol>
  <li>AtacantetieneaccesoderedalainterfazwebdeadministracióndePAN-OS</li>
  <li>Envíasolicitudesespecialmentediseñadasqueevadenlalógicadeautenticación</li>
  <li>Noserequierencredencialesniinteraccióndelusuario</li>
  <li>Atacanteobtieneaccesodirectodeadministrador</li>
</ol>
<p>Impacto</p>
<p>Bypasscompletodeautenticaciónpermitiendoaatacantesremotosnoautenticadosobte-</p>
<p>nerprivilegiosdeadministradordePAN-OS</p>
<p>Habilitabarealizaraccionesadministrativas:</p>
<p>• Manipularconfiguracionesdefirewall</p>
<p>• Crearreglasparapermitirtráficomalicioso</p>
<p>• Extraerconfiguracionesycredenciales</p>
<p>Podía encadenarse con otras vulnerabilidades como CVE-2024-9474 para explotación adi-</p>
<p>cional</p>
<p>Mitigación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>PaloAltolanzóparchesenversiones10. 2.12,11. 0.6,11. 1.5y11. 2.4(noviembre2024):-Corrigieron</p>
<p>la lógica devalidaciónde autenticación - Recomendaronrestringir acceso a la interfaz de adminis-</p>
<p>traciónsoloaIPsinternasconfiablescomodefensaenprofundidad</p>
<p>Observaciones</p>
<p>Lasfallaslógicasenautenticaciónyautorizaciónpuedenllevara:-Escaladadeprivilegios(usuario</p>
<p>seconvierteenadmin)-Escaladahorizontal(usuarioAaccedeadatosdeusuarioB)-Bypassde</p>
<p>autenticación(accesosincredenciales)</p>
<p>Todo sin corrupción de memoria. Verificaciones faltantes, confusión de estado, manipulación de</p>
<p>parámetrosyfallasdegestióndesesiónsonpatronescomunes.</p>
<ol>
  <li>2.5. 1. 2.5 Escritura Arbitraria (Write-What-Where)</li>
</ol>
<p>Descripción General</p>
<p>Unaprimitivadeescrituraarbitrariapermitealatacanteescribirunvalorcontroladoaunadirección</p>
<p>controlada. Esta es una de las primitivas de explotación más poderosas, ya que permite modificar</p>
<p>cualquierubicacióndememoria.</p>
<p>Usos de Escritura Arbitraria:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ PRIMITIVAS DE ESCRITURA ARBITRARIA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ 1. SOBRESCRIBIR CREDENCIALES │</h2>
<p>│ task_struct->cred->uid = 0 → Convertirse en root │</p>
<h2>│ 2. CORROMPER PUNTEROS DE FUNCIÓN │</h2>
<p>│ callback_ptr = &shellcode → Ejecución de código │</p>
<h2>│ 3. DESHABILITAR PROTECCIONES │</h2>
<p>│ security_callback = NULL → Bypass de seguridad │</p>
<h2>│ 4. MODIFICAR POLÍTICAS │</h2>
<p>│ selinux_enforcing = 0 → Deshabilitar SELinux │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-21338 — Windows AppLocker Driver Arbitrary Function Call</p>
<p>Campo Detalle</p>
<p>Producto Afectado WindowsAppLockerdriver(appid. sys)</p>
<p>Tipo LlamadaArbitrariaaFunción→EscrituraArbitraria</p>
<p>Vector Local(serviciolocaloimpersonacióndeadmin)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Campo Detalle</p>
<p>Severidad Alta</p>
<p>PoC Disponible github. com/hakaioffsec/CVE-2024-21338</p>
<p>El Bug</p>
<p>El driver de Windows AppLocker (appid. sys) contenía una vulnerabilidad en su manejador IOCTL</p>
<p>(código de control 0x22A018) que permitía a un atacante con privilegios de servicio local llamar</p>
<p>punteros de función del kernel arbitrarios con argumentos controlados. El IOCTL estaba diseñado</p>
<p>paraaceptarpunterosdefuncióndelkernelparaoperacionesdearchivosperopermanecíaaccesi-</p>
<p>bledesdeespaciodeusuariosinvalidaciónapropiada.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>ObtenerAcceso:</li>
</ol>
<p>Atacanteimpersonalacuentadeserviciolocal</p>
<p>Otieneaccesoadminquepuedeimpersonar</p>
<ol>
  <li>Enviar IOCTL Malicioso:</li>
</ol>
<p>EnviarsolicitudIOCTLespecialmentediseñadaa\Device\AppId</p>
<p>Incluirpunterosdefunciónmaliciososenelbúferdeentrada</p>
<ol>
  <li>Explotar Gadget:</li>
</ol>
<p>Escogerlafuncióngadgetcorrecta</p>
<p>Realizarcopiade64bitsadirecciónarbitrariadelkernel</p>
<p>Objetivo específico: CampoPreviousModeenestructuraKTHREADdelhiloactual</p>
<ol>
  <li>Corrupción de PreviousMode:</li>
</ol>
<p>CorromperPreviousModeaKernelMode(0)</p>
<p>Esto bypasea verificaciones de modo kernel en syscalls como NtReadVirtualMemory y</p>
<p>NtWriteVirtualMemory</p>
<p>Otorgacapacidadesdelectura/escrituraarbitrariadelkerneldesdemodousuario</p>
<ol>
  <li>Post-Explotación:</li>
</ol>
<p>Realizarmanipulacióndirectadeobjetosdelkernel(DKOM)</p>
<p>Deshabilitarcallbacksdeseguridad</p>
<p>CegartelemetríaETW</p>
<p>SuspenderprocesosdeseguridadprotegidosporPPL</p>
<p>Impacto</p>
<p>EstavulnerabilidadfueusadaporelsofisticadorootkitFudModule para:-Escaladadeprivilegios</p>
<p>local de servicio local (o admin vía impersonación) a lectura/escritura arbitraria nivel kernel - Ata-</p>
<p>que de kernel verdaderamente fileless - sin necesidad de soltar o cargar drivers personalizados</p>
<p>- Manipulación directa de objetos del kernel (DKOM) - Deshabilitación de callbacks de seguridad -</p>
<p>CegartelemetríaETW-SuspenderprocesosdeseguridadprotegidosporPPL</p>
<p>Por Qué Es Significativo:</p>
<p>EstorepresentaunaevoluciónsofisticadamásalládetécnicasBYOVDtradicionales. Alexplotar</p>
<p>un zero-day en un driver incorporado de Windows, los atacantes lograron un ataque de kernel</p>
<p>verdaderamentefilelesssinnecesidaddesoltarocargardriverspersonalizados.</p>
<p>Mitigación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Microsoft lanzó parches en febrero 2024 (Patch Tuesday) que: - Añadieron verificación ExGetPre-</p>
<p>viousMode al manejador IOCTL - Previenen que IOCTLs iniciados desde modo usuario disparen la</p>
<p>invocacióndecallbackarbitrario</p>
<p>Observaciones</p>
<p>Laprimitivadeescrituraarbitraria(logradavíacorrupcióndePreviousMode)esunatécnicacanónica</p>
<p>para: - Voltear bits de privilegios - Sobrescribir punteros de función - Modificar datos de políticas</p>
<p>deseguridad</p>
<p>EstecasodemuestracómomanejadoresIOCTLconvalidacióndeentradainsuficientepuedenpro-</p>
<p>porcionarprimitivaspoderosasparaexplotacióndekernel,especialmentecuandoaceptanpunteros</p>
<p>defunciónopermitenconfusióndeobjetos.</p>
<ol>
  <li>2.6. 1. 2.6 Mal Uso de Locking/RCU</li>
</ol>
<p>Descripción General</p>
<p>Ordenamientodelocksincorrecto,locksfaltantesomalusodeRCU(Read-Copy-Update)llevando</p>
<p>acarrerassobreobjetosliberados. Estosbugsocurrenencódigodelkernelconaltaconcurrencia.</p>
<p>Patrones Comunes:</p>
<ol>
  <li>Lock Faltante:Accesoadatoscompartidossinsincronización</li>
  <li>Ordenamiento de Locks Incorrecto: Deadlocksocarrerasporordeninconsistente</li>
  <li>Violaciones de RCU: UsarobjetoRCU-protegidofueradeseccióncrítica</li>
  <li>Liberación Prematura:Soltarlockantesdequeoperacióncomplete</li>
</ol>
<p>Caso de Estudio: CVE-2023-32629 — Linux Netfilter nf_tables Race Condition</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(nf_tables)</p>
<p>Tipo CondicióndeCarreraporLockingImpropio→UAF</p>
<p>Vector Usernamespacesnoprivilegiados</p>
<p>Severidad Alta</p>
<p>PoC Disponible github. com/ThrynSec/CVE-2023-32629-CVE-2023-</p>
<p>2640—POC-Escalation</p>
<p>El Bug</p>
<p>El subsistema nf_tables de netfilter del kernel Linux contenía una vulnerabilidad de condición de</p>
<p>carrera debido a bloqueo impropio al manejar operaciones batch. La vulnerabilidad ocurría en el</p>
<p>códigodemanejo detransacciones dondeelacceso concurrentea objetosde nf_tablesnoestaba</p>
<p>sincronizadoapropiadamente,permitiendocondicionesuse-after-free.</p>
<p>El Ataque:</p>
<p>UnatacanteconcapacidadCAP_NET_ADMIN(obtenibleatravésdeusernamespacesnoprivilegiados</p>
<p>enmuchasdistribuciones)podía:</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>Enviarmensajesnetlinkconcurrentesparamanipularreglasdenf_tables</li>
  <li>Cronometrarcuidadosamenteestasoperacionesatravésdemúltipleshilos</li>
  <li>Dispararunaventanadondeunhiloliberaunobjetomientrasotrohiloaúntieneunareferen-</li>
</ol>
<ol>
  <li>Explotarlacondiciónuse-after-freeparaescaladadeprivilegios</li>
</ol>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldeusuarionoprivilegiadoarootensistemasconusernamespa-</p>
<p>cesnoprivilegiadoshabilitados(defaultenUbuntu,Debian,Fedorayotros)</p>
<p>La primitiva use-after-free podía explotarse para obtener capacidades de lectura/escritura</p>
<p>arbitrariadelkernel</p>
<p>Típicamenteusadaparamodificarcredencialesdeprocesoosobrescribirpunterosdefunción</p>
<p>delkernel</p>
<p>AfectókernelsLinuxanterioresaversión6. 3.1(mayo2023)</p>
<p>Mitigación</p>
<p>Linux kernel 6. 3.1: - Añadió mecanismos de bloqueo apropiados alrededor del procesamiento de</p>
<p>transaccionesbatchdenf_tables-Implementóconteodereferenciaspararastreartiemposdevida</p>
<p>de objetos correctamente - Aseguró operaciones atómicas para acceso concurrente a estructuras</p>
<p>dedatoscompartidasdenetfilter</p>
<p>Observaciones</p>
<p>El mal uso de locking y RCU lleva a UAF reproducible y corrupción de memoria en rutas calientes</p>
<p>comosistemasdearchivos,networkingytimers. Elordenamientodelocksincorrecto,locksfaltantes</p>
<p>y violaciones de RCU son particularmente peligrosos en código del kernel donde la concurrencia</p>
<p>esomnipresente.</p>
<p>Elsubsistemanetfiltercontinúasiendounafuenterecurrentedetalesvulnerabilidadesdebidoasu</p>
<p>complejidadyusoextensivodeestructurasdedatosconcurrentes.</p>
<ol>
  <li>2.7. 1. 2.7 Conclusiones de Vulnerabilidades Lógicas</li>
</ol>
<p>Hallazgos Clave:</p>
<ol>
  <li>Las vulnerabilidades lógicas no requieren corrupción de memoria: Bypasses de autenti-</li>
</ol>
<p>cación, fallas TOCTOU y primitivas de escritura arbitraria pueden ser tan impactantes como</p>
<p>corrupcióndememoriatradicional.</p>
<ol>
  <li>Losbugsdeconcurrenciahabilitanexploitssofisticados:Double-fetch,condicionesdeca-</li>
</ol>
<p>rreraymalusodelockingsondifícilesdereproducirperoproporcionanexplotaciónconfiable</p>
<p>cuandoeltimingescontrolado.</p>
<ol>
  <li>La escritura arbitraria es la primitiva definitiva: Ya sea lograda a través de manejadores</li>
</ol>
<p>IOCTL,corrupcióndePreviousModeomalusodeRCU,laescrituraarbitrariadelkernelhabilita</p>
<p>escaladadeprivilegios,deshabilitacióndecallbacksdeseguridadydesplieguederootkits.</p>
<ol>
  <li>Los user namespaces expanden la superficie de ataque: Muchas vulnerabilidades del ker-</li>
</ol>
<p>nel (netfilter, io_uring) se vuelven explotables desde contextos no privilegiados cuando user</p>
<p>namespacesotorgancapacidadescomoCAP_NET_ADMIN.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>La defensa requiere operaciones atómicas: Las vulnerabilidades TOCTOU demuestran que</li>
</ol>
<p>lospatronescheck-then-usesoninherentementepropensosacarreras;operacionesatómicas</p>
<p>check-and-use,bloqueoapropiadoycopiadefensivasonesenciales.</p>
<p>Preguntasde Discusión:</p>
<ol>
  <li>¿Cómo difieren las vulnerabilidades double-fetch de las condiciones de carrera TOCTOU tra-</li>
</ol>
<p>dicionalesyquélashaceparticularmentepeligrosasencontextosdehypervisor?</p>
<ol>
  <li>Comparelacomplejidaddeexplotacióndefallaslógicasdeautenticaciónversuscondiciones</li>
</ol>
<p>decarreradelkernel.¿Cuálproporcionaexplotaciónmásconfiableyporqué?</p>
<ol>
  <li>¿Cómo difiere la primitiva de escritura arbitraria lograda en CVE-2024-21338 (vía corrupción</li>
</ol>
<p>de PreviousMode) de la escritura arbitraria tradicional basada en buffer overflow, y qué ven-</p>
<p>tajasproporcionaalosatacantes?</p>
<ol>
  <li>3. 1. 3 Confusión de Tipos y Enteros</li>
</ol>
<p>Las vulnerabilidades de confusión de tipos ocurren cuando un programa procesa un objeto como</p>
<p>untipodiferentealprevisto. Losbugsdeenterosincluyendesbordamiento,subdesbordamientoy</p>
<p>truncamiento.</p>
<ol>
  <li>3.1. 1. 3.1 Confusión de Tipos en JIT</li>
</ol>
<p>Descripción General</p>
<p>La confusión de tipos ocurre cuando un programa procesa un objeto como un tipo diferente al</p>
<p>previsto. Esto puede suceder en lenguajes de tipado dinámico, durante casts de tipo inseguros, o</p>
<p>encompiladoresJITquehacensuposicionesincorrectassobretiposdeobjetos.</p>
<p>Caso de Estudio: CVE-2024-7971 — V8 TurboFan Type Confusion</p>
<p>Campo Detalle</p>
<p>Producto Afectado GoogleChrome(V8JavaScriptEngine)</p>
<p>Tipo TypeConfusionenJIT</p>
<p>Vector Páginawebmaliciosa</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>LaoptimizacióndeeliminaciónCheckBoundsdeTurboFanasumióincorrectamentetiposdeelemen-</p>
<p>tosdearraydurantelacompilaciónJIT. Alencontraruninlinecachepolimórfico,TurboFanaveces</p>
<p>confundíapunterostagged(objetosHeap)conSMI(SmallIntegers).</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigovíapáginawebmaliciosa</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>PermitíacrearJSArrayfalsoconpunterodebackingstorecontrolado</p>
<p>Capacidadesdelectura/escriturafueradelímites</p>
<p>EscapedelsandboxV8paraejecucióndeshellcode</p>
<p>Contexto de Explotación</p>
<p>La confusión de tipos permitía construir primitivas de explotación: - addrof: Filtrar direcciones de</p>
<p>objetos (fuga de información para bypass de ASLR) - fakeobj: Crear objetos falsos con estructura</p>
<p>controlada-lectura/escrituraarbitraria:Accesofueradelímitesacualquierubicacióndememoria</p>
<p>Mitigación</p>
<p>V8parcheólalógicadeeliminaciónCheckBoundspararastrearcorrectamenteinformacióndetipos</p>
<p>durantepasesdeoptimización.</p>
<p>Observaciones</p>
<p>Laexplotacióndenavegadoresesunobjetivodealtovalor. Laconfusióndetiposencompiladores</p>
<p>JITesunaclasedevulnerabilidadcomún,connuevasvariantesdescubiertasregularmente.</p>
<ol>
  <li>3.2. 1. 3.2 Desbordamiento de Enteros</li>
</ol>
<p>Descripción General</p>
<p>Losbugsdeenterosincluyen:-Desbordamiento:Excedervalormáximo(ej. INT_MAX + 1envuelvea</p>
<p>INT_MIN)-Subdesbordamiento:Irpordebajodelvalormínimo(ej. 0 - 1seconvierteenUINT_MAX</p>
<p>paraunsigned)-Truncamiento:Perderdatosalconvertirdetipomayoramenor</p>
<p>Los bugs de enteros frecuentemente llevan a corrupción de memoria porque los enteros se usan</p>
<p>paratamañosdebúfer,contadoresdebucleeíndicesdearray.</p>
<p>Caso de Estudio: CVE-2024-38063 — Windows TCP/IP Integer Underflow RCE</p>
<p>Campo Detalle</p>
<p>Producto Afectado WindowsTCP/IPStack(tcpip. sys)</p>
<p>Tipo IntegerUnderflow→RCE</p>
<p>Vector PaquetesIPv6dered</p>
<p>Severidad Crítica(CVSS9. 8)</p>
<p>El Bug</p>
<p>LapilaTCP/IPdeWindowsconteníaunavulnerabilidadcríticadesubdesbordamientodeenterosen</p>
<p>sucódigodeprocesamientodepaquetesIPv6. AlmanejarpaquetesIPv6especialmentediseñados</p>
<p>concabeceras de extensión malformadas, el driver tcpip. sys realizaba operaciones aritméticas que</p>
<p>podíanresultarenunsubdesbordamientodeenteros.</p>
<p>Impacto</p>
<p>EjecuciónRemotadeCódigoconprivilegiosSYSTEMensistemasWindowsafectados</p>
<p>CVSSScore:9. 8(Crítico)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>AfectóWindows10,Windows11yWindowsServerversionesdesde2008hasta2022</p>
<p>Potencialmentewormeable(podíapropagarseautomáticamentecomoSMBGhost)</p>
<p>Contexto de Explotación</p>
<ol>
  <li>PaquetesIPv6conconfiguracionesespecíficasdecabecerasdeextensión</li>
  <li>Dispararelsubdesbordamientoencálculosdetamaño</li>
  <li>Elvalorsubdesbordadoenvuelveaunenterounsignedgrande</li>
  <li>Elkernelasignabúferpequeñobasadoenelvalorenvuelto</li>
  <li>Operación de copia subsecuente usa tamaño grande original, causando desbordamiento de</li>
</ol>
<p>heap</p>
<ol>
  <li>EldesbordamientodeheapllevaacorrupcióndememoriadelkernelyRCE</li>
</ol>
<p>Mitigación</p>
<p>Microsoftlanzóparchesenagosto2024queañadieronverificaciónapropiadadelímitesalprocesa-</p>
<p>mientodepaquetesIPv6ycorrigieronoperacionesaritméticasdeenterosparaprevenircondiciones</p>
<p>desubdesbordamiento.</p>
<p>Observaciones</p>
<p>Esta vulnerabilidad demuestra cómo el subdesbordamiento de enteros en parsers de protocolos</p>
<p>de red puede llevar a vulnerabilidades de RCE críticas. El bug afectaba código de red fundamental</p>
<p>que procesa entrada de red no confiable, haciéndolo objetivo principal para exploits wormables</p>
<p>similaresaSMBGhostyEternalBlue.</p>
<ol>
  <li>3.3. 1. 3.3 Vulnerabilidades de Parsers</li>
</ol>
<p>Descripción General</p>
<p>Los parsers convierten datos estructurados (archivos, protocolos de red, etc.) en representaciones</p>
<p>internasdelprograma. Sucomplejidadloshaceobjetivosprincipalesparafuzzingyexplotación.</p>
<p>Caso de Estudio: CVE-2024-47606 — GStreamer Signed-to-Unsigned Integer Underflow</p>
<p>Campo Detalle</p>
<p>Producto Afectado GStreamermultimediaframework</p>
<p>Tipo ConversiónSigned-to-Unsigned→RCE</p>
<p>Vector Archivomultimediamalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>GStreamer contenía una vulnerabilidad de conversión de entero signed a unsigned en la función</p>
<p>qtdemux_parse_theora_extension. Una variable de tamaño gint (entero signed) subdesbordaba</p>
<p>a un valor negativo, que luego era implícitamente convertido a un entero unsigned de 64 bits,</p>
<p>convirtiéndoseenunvalormasivo.</p>
<p>Impacto</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Ejecuciónremotadecódigoalprocesararchivosmultimediamaliciosos</p>
<p>GStreameresusadoporinnumerablesaplicaciones(GNOME,KDE,Firefox,Chrome,derivados</p>
<p>deVLC)</p>
<p>Losarchivosmultimediasoncomúnmentecompartidosyprocesadosautomáticamente</p>
<p>Afectatantosistemasdeescritoriocomoembebidos</p>
<p>Contexto de Explotación</p>
<ol>
  <li>ArchivomultimediamaliciosocontieneextensiónTheoraconcamposdetamañodiseñados</li>
  <li>Lafuncióncalculatamañousandoaritméticasigned</li>
  <li>Elcálculosubdesborda(ej.-6o0xFFFFFFFAenrepresentaciónde32bits)</li>
  <li>Valornegativode32bitsesconvertidoaunsignedde64bits→valormasivo</li>
  <li>Soloseasignanbytespequeñosapesardeltamañoenormesolicitado</li>
  <li>memcpysubsecuentecopiadatosgrandesenbúferpequeño</li>
  <li>DesbordamientodebúfercorrompeestructuraGstMapInfo</li>
  <li>SecuestrodepunterodefunciónlograRCE</li>
</ol>
<p>Mitigación</p>
<p>GStreamer 1. 24. 10 (diciembre 2024) corrigió la vulnerabilidad añadiendo verificaciones explícitas</p>
<p>paravaloresnegativosantesdeconvertirsignedaunsignedyusandoaritméticadeenterossegura.</p>
<p>Observaciones</p>
<p>Este es un ejemplo de libro de texto de vulnerabilidades de conversión signed-to-unsigned (CWE-</p>
<p>195).EnC/C++,lasconversionesimplícitasentreenterossignedyunsignedsiguenreglascomplejas</p>
<p>quelosdesarrolladoresfrecuentementemalinterpretan. Losenterossignednegativosseconvierten</p>
<p>envaloresunsignedpositivosenormescuandosonconvertidos.</p>
<p>Caso de Estudio: CVE-2024-27316 — nghttp2 HTTP/2 CONTINUATION Frame DoS</p>
<p>Campo Detalle</p>
<p>Producto Afectado nghttp2HTTP/2library</p>
<p>Tipo AgotamientodeRecursos→DoS</p>
<p>Vector ConexiónHTTP/2dered</p>
<p>Severidad Alta(CVSS7. 5)</p>
<p>El Bug</p>
<p>La biblioteca nghttp2 HTTP/2 (usada por Apache httpd, nginx y muchos otros servidores) conte-</p>
<p>nía una vulnerabilidad en su manejo de frames CONTINUATION. La biblioteca fallaba en limitar el</p>
<p>tamañototalacumuladodedatosdecabeceraatravésdeframesCONTINUATION.</p>
<p>Impacto</p>
<p>DenegacióndeServiciovíaagotamientodememoria</p>
<p>UnaúnicaconexiónTCPpodíaagotargigabytesdememoriadelservidor</p>
<p>Muybajoanchodebandarequeridodelatacante</p>
<p>Afectónghttp2,ApacheHTTPServer,nginxyotros</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Contexto de Explotación</p>
<p>UnatacantepodíaestablecerunaconexiónHTTP/2yejecutar:1. EnviarframeHEADERSválidopara</p>
<p>iniciarnuevostream2. EnviarframesCONTINUATIONcontinuossinestablecerflagEND_HEADERS</p>
<ol>
  <li>Cada frame CONTINUATION añade datos al búfer de cabecera acumulado 4. El servidor asigna</li>
</ol>
<p>másmemoriaporcadaframerecibido5. Elprocesoserepitehastaquelamemoriadelservidorse</p>
<p>agota</p>
<p>Mitigación</p>
<p>nghttp2 v1. 61. 0 (abril 2024) añadió límite NGHTTP2_DEFAULT_MAX_HEADER_LIST_SIZE (64KB por de-</p>
<p>fecto) para el tamaño total acumulado de cabeceras. Apache httpd 2. 4.59 implementó directiva</p>
<p>H2MaxHeaderListSize.</p>
<p>Observaciones</p>
<p>Esta vulnerabilidad demuestra que los parsers deben rastrear el consumo de recursos a través de</p>
<p>operaciones relacionadas, no solo operaciones individuales. El ataque es particularmente efectivo</p>
<p>porqueexplotaelmecanismolegítimodelprotocolo.</p>
<ol>
  <li>4. 1. 4 Vulnerabilidades de Strings y Formato</li>
</ol>
<p>Las vulnerabilidades de format string ocurren cuando datos controlados por el usuario se pasan</p>
<p>comoargumentodeformatstringafuncionescomoprintf,sprintfysimilares.</p>
<p>Caso de Estudio: CVE-2023-35086 — ASUS Router Format String RCE</p>
<p>Campo Detalle</p>
<p>Producto Afectado ASUSRT-AX56UV2yRT-AC86Urouters</p>
<p>Tipo FormatString→RCE</p>
<p>Vector Interfazwebdeadministración</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>Los routers ASUS contenían una vulnerabilidad de format string en su interfaz de administración</p>
<p>web(demoniohttpd).Lafunciónlogmessage_normaldelmódulodo_detwan_cgiusabadirectamen-</p>
<p>teentradacontroladaporelusuariocomoformatstringalllamarasyslog().</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigoconprivilegiosroot</p>
<p>PermitíafugadeinformaciónparabypassdeASLR</p>
<p>Habilitabaescrituraarbitrariadememoriavíadirectiva%n</p>
<p>Compromisocompletodeldispositivodered</p>
<p>Contexto de Explotación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Etapa1-FugadeInformación:-AtacanteenvíasolicitudHTTPconformatstring:%p.%p.%p.%p-</p>
<p>Routerregistraestoasyslog,filtrandodireccionesdepila-Lasdirectivas%prevelanlayoutdepila</p>
<p>yderrotanASLR</p>
<p>Etapa 2 - Escritura Arbitraria: - Atacante diseña format string con directiva%n - Sobreescribe</p>
<p>puntero de función o dirección de retorno en pila - Redirige ejecución a shellcode controlado por</p>
<p>atacante-Resultado:EjecuciónRemotadeCódigoconprivilegiosroot</p>
<p>Mitigación</p>
<p>ActualizacionesdefirmwareASUScambiaron:</p>
<p>// Vulnerable:</p>
<p>syslog(LOG_INFO, user_input);</p>
<p>// Corregido:</p>
<p>syslog(LOG_INFO, "%s", user_input);</p>
<p>Adicionalmente implementaron validación de entrada y habilitaron advertencias de compilador -</p>
<p>Wformat-security.</p>
<p>Observaciones</p>
<p>Las vulnerabilidades de format string en dispositivos embebidos y routers son particularmente pe-</p>
<p>ligrosas porque los dispositivos frecuentemente ejecutan firmware desactualizado, muchos están</p>
<p>expuestosaInternet,yelcompromisoproporcionaaccesopersistentearedes.</p>
<ol>
  <li>5. 1. 5 Vulnerabilidades de Drivers y Sistemas de Archivos</li>
</ol>
<p>Los drivers y sistemas de archivos representan una superficie de ataque masiva debido a sus inter-</p>
<p>facescomplejasconelkernelyelmanejodeentradanoconfiable.</p>
<ol>
  <li>5.1. Vulnerabilidades de Manejadores IOCTL/Syscall</li>
</ol>
<p>Caso de Estudio: CVE-2023-21768 — Windows AFD. sys Buffer Size Confusion</p>
<p>Campo Detalle</p>
<p>Producto Afectado WindowsAFD. sys(AncillaryFunctionDriver)</p>
<p>Tipo ConfusióndeTamañodeBúfer</p>
<p>Vector Local</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>El Windows Ancillary Function Driver (AFD. sys), que maneja operaciones de socket, tenía una</p>
<p>vulnerabilidad de confusión de tamaño de búfer en su manejador IOCTL. Al procesar solicitudes</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>IOCTL_AFD_SELECT,eldriverfallabaenvalidarapropiadamentelarelaciónentreeltamañodebúfer</p>
<p>proporcionadoporelusuarioyeltamañorealdelaestructura.</p>
<p>Impacto</p>
<p>EscaladadeprivilegioslocaldeusuarioestándaraSYSTEM</p>
<p>La primitiva de escritura OOB se usaba para corromper objetos del kernel adyacentes en el</p>
<p>pool</p>
<p>Explotadoenelwildantesdelparcheo</p>
<p>Contexto de Explotación</p>
<p>Un atacante podía llamar a DeviceIoControl() con un búfer de entrada especialmente diseñado</p>
<p>donde el tamaño declarado no coincidía con el tamaño real de datos. El driver asignaba un búfer</p>
<p>basadoenunvalordetamañoperocopiabadatosbasadoenotro.</p>
<p>Mitigación</p>
<p>Microsoft KB5022845 añadió validación estricta asegurando que la longitud proporcionada por el</p>
<p>usuario coincidiera con el tamaño de estructura esperado, usóProbeForRead()para validar punte-</p>
<p>rosdeusuario,eimplementóverificaciónadicionaldelímites.</p>
<p>Observaciones</p>
<p>Los manejadores IOCTL/syscall son vectores de ataque comunes debido a confusión de tama-</p>
<p>ño/límites,confianzaenpunterosdeusuariosinprobing,yproblemasdedouble-fetch.</p>
<ol>
  <li>5.2. Vulnerabilidades de Sistemas de Archivos</li>
</ol>
<p>Caso de Estudio: CVE-2022-0847 — Dirty Pipe</p>
<p>Campo Detalle</p>
<p>Producto Afectado LinuxKernel(implementacióndepipes)</p>
<p>Tipo FallaLógica→EscrituraArbitrariadeArchivos</p>
<p>Vector Local</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>La implementación de pipes del kernel Linux fallaba en inicializar apropiadamente el flag PI-</p>
<p>PE_BUF_FLAG_CAN_MERGEalhacersplicedepáginasdelacachédepáginashaciapipes. Estopermitía</p>
<p>sobreescribirdatosenarchivosdesololecturahaciendosplicedepáginasmodificadasdevuelta.</p>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldecualquierusuarioarootsobreescribiendo/etc/passwduotros</p>
<p>archivosprivilegiados</p>
<p>Explotaciónextremadamenteconfiablerequiriendopermisosmínimos</p>
<p>AfectókernelsLinux5. 8+hasta5. 16. 11</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Contexto de Explotación</p>
<p>Unatacantepodía:1. Abrirunarchivodesololectura(ej./etc/passwd)2. Usarsplice()paracrear</p>
<p>unpipeconteniendopáginasdeesearchivo3. Modificarelbúferdelpipe4. Hacersplicedevuelta</p>
<p>parasobreescribircontenidosdelarchivooriginal</p>
<p>Mitigación</p>
<p>Linux kernel 5. 16. 11+ inicializa apropiadamente los flags de búfer de pipe y previene el splice de</p>
<p>vueltaaarchivosdesololectura.</p>
<p>Observaciones</p>
<p>Las operaciones de pipe y splice son mecanismos complejos del kernel con requisitos sutiles de</p>
<p>gestión de estado. Dirty Pipe demostró cómo bugs de inicialización pueden llevar a primitivas po-</p>
<p>derosasdeescrituraarbitrariadearchivos.</p>
<ol>
  <li>5.3. Bring Your Own Vulnerable Driver (BYOVD)</li>
</ol>
<p>Caso de Estudio: Abuso de Drivers por Lazarus Group</p>
<p>Campo Detalle</p>
<p>Técnica BYOVD(BringYourOwnVulnerableDriver)</p>
<p>Tipo AbusodeDriverLegítimo</p>
<p>Vector Driverfirmadovulnerable</p>
<p>Uso Gruposdeamenazasavanzados</p>
<p>La Técnica</p>
<p>Losatacantesdejancaerundriverlegítimoperovulnerablefirmado(ej. versionesantiguasdedrivers</p>
<p>ASUS,GigabyteoMSI)queWindowscargarádebidoasufirmaválida.</p>
<p>Impacto</p>
<p>Unavezcargado,eldrivervulnerableproporcionaprimitivasdelectura/escrituraarbitrariadel</p>
<p>kernelatravésdesuinterfazIOCTL</p>
<p>Losatacantesusanestoparadeshabilitarcaracterísticasdeseguridad(PatchGuard,AV/EDR)</p>
<p>Permitecargardriversnofirmadosoescalarprivilegios</p>
<p>Contexto de Explotación</p>
<p>LatécnicaBYOVDfueampliamenteusadaporgruposcomoLazarusantesdequeMicrosoftexpan-</p>
<p>dieralaDriverBlocklist. GruposavanzadoshancambiadodeBYOVDaexploitsdirectosdezero-day</p>
<p>delkerneldespuésde2023debidoalaumentodedetección.</p>
<p>Mitigación</p>
<p>HabilitarVulnerableDriverBlocklist(HVCI/MemoryIntegrity)</p>
<p>Monitorearcargasdedriversinusuales</p>
<p>Implementarpolíticasdecontroldeaplicaciones</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<p>Observaciones</p>
<p>Mientrasnoesunavulnerabilidadperse,BYOVDesampliamenteusadoencadenasdeexplotación</p>
<p>yrepresentaunriesgosignificativodeabusodedriverslegítimosfirmados.</p>
<ol>
  <li>6. 1. 6 Evaluación de Impacto y Clasificación</li>
</ol>
<p>Comprendercómoevaluaryclasificarvulnerabilidadesporsuimpactorealyexplotabilidadesfun-</p>
<p>damentalparalapriorizacióndeparchesyrespuestaaincidentes.</p>
<ol>
  <li>6.1. Categorías de Impacto</li>
</ol>
<p>EjecuciónRemotadeCódigo(RCE)-Definición:Atacantepuedeejecutarcódigoarbitrarioenel</p>
<p>sistema objetivo remotamente - Impacto: Máxima severidad - compromiso completo del sistema</p>
<p>posible - Ejemplos: CVE-2024-27130 (QNAP), CVE-2024-2883 (Chrome ANGLE), CVE-2023-4863</p>
<p>(libWebP)</p>
<p>Escalada de Privilegios Local (LPE) - Definición: Atacante con acceso limitado puede obtener</p>
<p>privilegios más altos - Impacto: Alta severidad - permite persistencia, evasión de defensas, movi-</p>
<p>mientolateral-Ejemplos:CVE-2024-26218(WindowsKernelTOCTOU),CVE-2022-0847(DirtyPipe)</p>
<p>Divulgación de Información - Definición: Atacante puede leer datos a los que no debería tener</p>
<p>acceso-Impacto:MediaaAlta-frecuentementeencadenadaconotrosbugsparabypassdeASLR</p>
<p>-Ejemplos:Fugasdeformatstring,lecturasdememorianoinicializada</p>
<p>Denegación de Servicio (DoS) - Definición: Atacante puede hacer un servicio no disponible sin</p>
<p>ganar ejecución de código - Impacto: Baja a Media - interrumpe disponibilidad sin comprometer</p>
<p>confidencialidad/integridad - Ejemplos: CVE-2024-27316 (HTTP/2 CONTINUATION), bombas de</p>
<p>descompresión</p>
<ol>
  <li>6.2. Factores de Explotabilidad</li>
</ol>
<p>Factor Bajo Alto</p>
<p>Complejidad de Ataque Requierepreparación Explotablerepetidamente</p>
<p>compleja conmínimoesfuerzo</p>
<p>Vector de Ataque Requiereaccesofísico Explotableremotamente</p>
<p>sobrered</p>
<p>Privilegios Requeridos Requiereacceso Sinautenticaciónnecesaria</p>
<p>administrativo</p>
<p>Interacciónde Usuario Víctimadeberealizaracción Completamente</p>
<p>automatizado</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES BitácoraRedTeam</p>
<ol>
  <li>6.3. Sistema de Puntuación CVSS</li>
</ol>
<p>ComponentesdelScoreBase(CualidadesIntrínsecas):-VectordeAtaque(AV):Red/Adyacente/Local/Físico</p>
<p>-Complejidad de Ataque (AC):Baja/Alta-Privilegios Requeridos (PR):Ninguno/Bajo/Alto-In-</p>
<p>teracciónde Usuario(UI):Ninguna/Requerida-Alcance(S):SinCambio/ConCambio-Impacto</p>
<p>aConfidencialidad(C),Integridad(I),Disponibilidad(A):Ninguno/Bajo/Alto</p>
<p>Rangos de Score: | Rango | Severidad | |——-|———–| | 0. 0 | Ninguna | | 0. 1-3. 9 | Baja | | 4. 0-6. 9 |</p>
<p>Media||7. 0-8. 9|Alta||9. 0-10. 0|Crítica|</p>
<ol>
  <li>6.4. Conclusiones del Capítulo 1</li>
  <li>La corrupción de memoria sigue siendo prevalente: A pesar de décadas de investigación,</li>
</ol>
<p>los bugs de corrupción de memoria continúan afectando software, especialmente en bases</p>
<p>decódigoC/C++.</p>
<ol>
  <li>La defensa en profundidad es esencial: Cada ejemplo real muestra atacantes evadiendo</li>
</ol>
<p>múltiplesmecanismosdeprotección(DEP,ASLR,CET,safe-linking).</p>
<ol>
  <li>Las mitigaciones modernas elevan la barrera pero no eliminan el riesgo: Mientras tec-</li>
</ol>
<p>nologías como CET shadow stack y safe-linking hacen la explotación más difícil, atacantes</p>
<p>determinadoscontinúanencontrandobypasses.</p>
<ol>
  <li>Lascausasraízsonsimilares,peroloscontextosdifieren:Bugsdestack,heapyUAFcom-</li>
</ol>
<p>parten causas raíz comunes (verificación inadecuada de límites, gestión de tiempo de vida)</p>
<p>perorequierendiferentestécnicasdeexplotación.</p>
<ol>
  <li>Loscomponenteslegacypermanecenvulnerables:Vulnerabilidadesdeañosdeantigüedad</li>
</ol>
<p>en parsers de office y manejadores de archivos continúan siendo explotadas debido a ciclos</p>
<p>deparcheolentos.</p>
<ol>
  <li>Lasvulnerabilidadeslógicasnorequierencorrupcióndememoria:Bypassesdeautentica-</li>
</ol>
<p>ción,fallasTOCTOUyprimitivasdeescrituraarbitrariapuedenserigualmenteimpactantes.</p>
<ol>
  <li>User namespaces expanden la superficie de ataque: Muchas vulnerabilidades del kernel</li>
</ol>
<p>se vuelven explotables desde contextos no privilegiados cuando user namespaces otorgan</p>
<p>capacidadescomoCAP_NET_ADMIN.</p>
<p>Capítulo 3</p>
<p>Fuzzing</p>
<p>El fuzzing es una técnica automatizada de descubrimiento de vulnerabilidades que ha encontrado</p>
<p>milesdebugsdeseguridadcríticosensoftwaredeproducción. Estecapítulocubrelosfundamentos</p>
<p>delfuzzing,herramientasclaveymetodologíasparaencontrarvulnerabilidades.</p>
<ol>
  <li>1. 2. 1 Fundamentos de Fuzzing</li>
</ol>
<p>Qué es el Fuzzing</p>
<p>Elfuzzingesunatécnicadepruebadesoftwarequeinvolucraproporcionardatosinválidos,inespe-</p>
<p>radosoaleatorioscomoentradaaunprograma. Elobjetivoesencontrarcrashes,assertionsfallidos,</p>
<p>fugas de memoria y otros comportamientos anómalos que puedan indicar vulnerabilidades de se-</p>
<p>guridad.</p>
<p>Por Qué el Fuzzing es Efectivo</p>
<p>Automatización:Puedeprobarmillonesdeentradasporhora</p>
<p>Cobertura:Exploracasosextremosquelaspruebasmanualesnuncaalcanzarían</p>
<p>Reproducibilidad:Lasentradasquecausancrashesseguardanparaanálisis</p>
<p>Escalabilidad:Puedeejecutarsecontinuamentedurantedías/semanas</p>
<p>Tipos de Fuzzing</p>
<p>Tipo Descripción Ejemplo</p>
<p>Caja Negra Sinconocimientodelcódigointerno Mutaciónaleatoriade</p>
<p>entradas</p>
<p>Caja Blanca Conocimientocompletodelcódigo Ejecuciónsimbólica</p>
<p>Caja Gris Instrumentacióndecobertura AFL++,libFuzzer</p>
<p>Guiado por Midequécódigoseejecuta AFL++,Honggfuzz</p>
<p>Cobertura</p>
<p>Guiado por Conocelaestructuradelformato Syzkaller(syscalls)</p>
<p>Gramática</p>
            </div>
            
            <div class="page-nav">
                <a href="01-introduccion.html"><i class="fas fa-arrow-left"></i> Capítulo 01: Introducción</a>
                <a href="03-fuzzing.html">Capítulo 03: Fuzzing <i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        const currentPath = window.location.pathname;
        const fileName = currentPath.split('/').pop().replace('.html', '');
        
        document.querySelectorAll('.nav-item').forEach(item => {
            const href = item.getAttribute('href');
            if (href && href.replace('.html', '') === fileName) {
                item.classList.add('active');
            }
        });
    </script>
</body>
</html>