<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 02: Clases de Vulnerabilidades | Bitácora Red Team</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Lato:wght@300;400;700&family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        :root {
            --primary-color: #c62828;
            --primary-dark: #8e0000;
            --secondary-color: #212121;
            --accent-color: #ff5252;
            --text-color: #e0e0e0;
            --text-muted: #9e9e9e;
            --bg-dark: #121212;
            --bg-card: #1a1a1a;
            --bg-hover: #252525;
            --border-color: #333333;
            --sidebar-width: 280px;
            --code-bg: #0d0d0d;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Lato', sans-serif;
            background: linear-gradient(145deg, #0a0a0a 0%, #151515 50%, #0d0d0d 100%);
            color: var(--text-color);
            line-height: 1.8;
            min-height: 100vh;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(198, 40, 40, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(198, 40, 40, 0.05) 0%, transparent 40%);
            pointer-events: none;
            z-index: -1;
        }
        
        .layout { display: flex; min-height: 100vh; }
        
        .sidebar {
            width: var(--sidebar-width);
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }
        
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg-dark); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 3px; }
        
        .sidebar-header {
            padding: 20px;
            background: linear-gradient(180deg, var(--primary-dark) 0%, var(--secondary-color) 100%);
            color: white;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .sidebar-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            margin: 0;
        }
        
        .sidebar-header p {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 5px;
        }
        
        .nav-section {
            padding: 15px 0;
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .nav-item:hover {
            background: var(--bg-hover);
            color: var(--text-color);
            border-left-color: var(--accent-color);
        }
        
        .nav-item.active {
            background: rgba(198, 40, 40, 0.15);
            border-left-color: var(--primary-color);
            font-weight: 600;
            color: var(--accent-color);
        }
        
        .nav-item i { width: 18px; text-align: center; color: var(--text-muted); }
        .nav-item.active i { color: var(--accent-color); }
        
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 40px 50px;
            max-width: calc(100vw - var(--sidebar-width));
        }
        
        .content-header {
            margin-bottom: 35px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
        }
        
        .content-header h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2rem;
            color: var(--text-color);
        }
        
        .section h2 {
            font-family: 'Montserrat', sans-serif;
            color: var(--accent-color);
            margin: 30px 0 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.4rem;
        }
        
        .section h3, .section h4 {
            color: var(--text-color);
            margin: 25px 0 15px;
            font-weight: 600;
        }
        
        .section p { margin-bottom: 15px; text-align: justify; color: #bdbdbd; }
        
        .section a {
            color: var(--accent-color);
            text-decoration: none;
            border-bottom: 1px dotted var(--accent-color);
            transition: all 0.2s;
        }
        
        .section a:hover { color: var(--primary-color); }
        
        .section ul, .section ol { margin: 15px 0 15px 25px; color: #bdbdbd; }
        .section li { margin-bottom: 8px; }
        .section li::marker { color: var(--primary-color); }
        
        .section pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        .section code {
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
        }
        
        .section table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .section th, .section td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border-color);
        }
        
        .section th {
            background: var(--bg-card);
            color: var(--accent-color);
            font-weight: 600;
        }
        
        .section tr:nth-child(even) { background: rgba(255, 255, 255, 0.02); }
        .section tr:hover { background: rgba(198, 40, 40, 0.08); }
        
        .page-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
            padding-top: 25px;
            border-top: 1px solid var(--border-color);
        }
        
        .page-nav a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 14px 24px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-muted);
            transition: all 0.3s ease;
        }
        
        .page-nav a:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(198, 40, 40, 0.3);
        }
        
        .page-nav a.disabled { opacity: 0.4; pointer-events: none; }
        
        @media (max-width: 900px) {
            .sidebar { transform: translateX(-100%); }
            .sidebar.open { transform: translateX(0); }
            .main-content { margin-left: 0; padding: 70px 20px 30px; }
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 4px; }
    </style>
</head>
<body>
    <div class="layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-shield-alt"></i> Bitácora Red Team</h1>
                <p>Explotación Moderna del Kernel de Linux</p>
            </div>
            <nav class="nav-section">
                
            <a href="01-introduccion.html" class="nav-item">
                <i class="fas fa-book"></i> 01: Introducción
            </a>
            <a href="02-clases-vulnerabilidades.html" class="nav-item active">
                <i class="fas fa-bug"></i> 02: Clases de Vulnerabilidades
            </a>
            <a href="03-fuzzing.html" class="nav-item">
                <i class="fas fa-flask"></i> 03: Fuzzing
            </a>
            <a href="04-patch-diffing.html" class="nav-item">
                <i class="fas fa-code-branch"></i> 04: Patch Diffing
            </a>
            <a href="05-analisis-crashes.html" class="nav-item">
                <i class="fas fa-exclamation-triangle"></i> 05: Análisis de Crashes
            </a>
            </nav>
        </aside>
        
        <main class="main-content">
            <div class="content-header">
                <h1>Capítulo 02: Clases de Vulnerabilidades</h1>
            </div>
            
            <div class="section">
                <p><a href="02-clases-vulnerabilidades.html">Capítulo 2</a></p>
<p>Clases de Vulnerabilidades</p>
<p>Estecapítulodocumentalasprincipalesclasesdevulnerabilidadesencontradasensistemasopera-</p>
<p>tivos y aplicaciones, con énfasis particular en el contexto de kernel y sistemas de bajo nivel. Cada</p>
<p>entradaincluyedescripcióntécnica, casosdeestudioreales, impactoymitigacionesaplicables.</p>
<p>Objetivo: Comprender las clases primarias de vulnerabilidades de corrupción de memoria y su</p>
<p>impactoenelmundoreal.</p>
<p>Recursosde Lectura Recomendados:-“The Artof Software Security Assessment”por Mark Dowd,</p>
<p>John Mc Donald, Justin Schuh - <a href="05-analisis-crashes.html">Capítulo 5</a>: Memory Corruption - Memory Corruption: Examples,</p>
<p>Impact, and 4 Ways to Prevent It - Microsoft Security Research: Memory Safety - Google Project</p>
<p>Zero Blog-Hallazgosrecientesdecorrupcióndememoria</p>
<ol>
  <li>1. 1. 1 Fundamentos de Corrupción de Memoria</li>
</ol>
<p>La corrupción de memoria continúa siendo una de las clases de vulnerabilidades más críticas y</p>
<p>prevalentesensoftwareescritoen C/C++. Apesardedécadasdeinvestigaciónenseguridad, estos</p>
<p>bugspersistendebidoalacomplejidadinherentedelagestiónmanualdememoria.</p>
<p>Conceptos Clave:-¿Quéeslacorrupcióndememoriayporquéimporta?Lacorrupcióndeme-</p>
<p>moria ocurre cuando un programa modifica memoria de maneras no intencionadas, permitiendo</p>
<p>a atacantes alterar el estado del programa y potencialmente obtener control de ejecución. - Pi-</p>
<p>la (Stack): Región de memoria para variables locales y direcciones de retorno. Su estructura LIFO</p>
<p>(Last-In-First-Out) la hace vulnerable a desbordamientos que pueden sobrescribir direcciones de</p>
<p>retorno. - Heap: Región de memoria dinámica gestionada por el allocator (malloc/free). Los me-</p>
<p>tadatos del heap y objetos adyacentes pueden ser corrompidos por desbordamientos. - Ciclo de</p>
<p>Vida de Memoria: Asignación → Uso → Liberación. Los errores en cualquier fase pueden llevar a</p>
<p>vulnerabilidades.</p>
<ol>
  <li>1.1. 1. 1.1 Desbordamiento de Búfer en Pila (Stack Buffer Overflow)</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Un desbordamiento de búfer en pila (stack buffer overflow) ocurre cuando un programa escribe</p>
<p>más datos en un búfer ubicado en la pila de los que este puede contener. Esto provoca la sobres-</p>
<p>crituradememoriaadyacente, incluyendodatoscríticoscomodireccionesderetorno, permitiendo</p>
<p>potencialmenteredirigirlaejecucióndelprograma.</p>
<p>Mecánica del Ataque:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ LAYOUT DE PILA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ [Direcciones Altas] │</p>
<p>│ ┌─────────────────┐ │</p>
<p>│ │ Dirección de │ ← Sobrescrita por atacante │</p>
<p>│ │ Retorno │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Frame Pointer │ ← También corrompido │</p>
<p>│ │ Guardado │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Variables │ │</p>
<p>│ │ Locales │ │</p>
<p>│ ├─────────────────┤ │</p>
<p>│ │ Búfer[64] │ ← Desbordamiento ocurre aquí │</p>
<p>│ │ │ │</p>
<p>│ └─────────────────┘ │</p>
<p>│ [Direcciones Bajas] │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-27130 — QNAP QTS/Qu TS Hero</p>
<p>Campo Detalle</p>
<p>Producto Afectado QNAPQT Sy Qu T Shero</p>
<p>Tipo Stack Buffer Overflow</p>
<p>Vector Interfazdeadministraciónweb</p>
<p>Severidad Crítica</p>
<p>Po C Disponible github. com/watchtowrlabs/CVE-2024-27130</p>
<p>El Bug</p>
<p>Los sistemas operativos QTS y Qu TS hero de QNAP contenían múltiples vulnerabilidades de copia</p>
<p>debúferdondefuncionesinsegurascomostrcpy () seutilizabanparacopiarentradasuministrada</p>
<p>por el usuario a búferes de tamaño fijo en la pila sin validación de tamaño adecuada. Las vulnera-</p>
<p>bilidadesafectabanlainterfazdeadministraciónwebyloscomponentesdemanejodearchivos.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Reconocimiento: Atacanteidentificaendpointvulnerableeninterfazdeadministraciónweb</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>Preparación: Construccióndepayloadconentradasobredimensionada</li>
  <li>Explotación: Envío de solicitud especialmente diseñada con datos que exceden el tamaño</li>
</ol>
<p>delbúfer</p>
<ol>
  <li>Corrupción: Losdatosnoverificadosdesbordanelbúferenpila, sobrescribiendo:</li>
</ol>
<p>Variableslocalesadyacentes</p>
<p>Framepointerguardado</p>
<p>Direcciónderetorno</p>
<ol>
  <li>Control de Ejecución: Cuando la función retorna, el flujo de ejecución se redirige a código</li>
</ol>
<p>controladoporelatacante</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigoconlosprivilegiosdelservicio QNAP(típicamenteroot)</p>
<p>Controlcompletodeldispositivo NAS, permitiendo:</p>
<p>·  Accesoatodoslosdatosalmacenados</p>
<p>·  Pivoteoaotrosrecursosdered</p>
<p>·  Instalacióndebackdoorspersistentes</p>
<p>Riesgocríticoparainfraestructuraempresarialdondelos NA Salmacenandatossensibles</p>
<p>Mitigación</p>
<p>QNAP lanzó QTS 5. 1.7. 2770 build 20240520 y Qu TS hero h 5. 1.7. 2770 build 20240520 en mayo de</p>
<p>2024: - Reemplazo de funciones de copia de cadenas inseguras (strcpy, sprintf) con alternativas</p>
<p>converificacióndelímites(strncpy, snprintf)-Implementacióndevalidacióndeentradaadicional</p>
<p>-Habilitacióndeproteccionesdecompilador(stackcanaries)</p>
<p>Observaciones</p>
<p>Los desbordamientos de pila siguen siendo comunes en: - Dispositivos embebidos con código</p>
<p>legacy C/C++-Sistemas NA Sconinterfacesdeadministraciónexpuestasa Internet-Aplicaciones</p>
<p>quenohanadoptado AP Issegurasmodernas</p>
<p>Son particularmente peligrosos cuando: - Proporcionan el punto de entrada inicial para cadenas</p>
<p>de ataque sofisticadas contra infraestructura empresarial - No tienen protecciones de compilador</p>
<p>habilitadas(ASLR, DEP, stackcanaries)</p>
<ol>
  <li>1.2. 1. 1.2 Uso Después de Liberación (Use-After-Free / UAF)</li>
</ol>
<p>Descripción General</p>
<p>Una vulnerabilidad de uso después de liberación (Use-After-Free) ocurre cuando un programa con-</p>
<p>tinúa usando un puntero después de que la memoria a la que apunta ha sido liberada. Esto crea</p>
<p>un “puntero colgante” (dangling pointer) que puede ser explotado controlando cuidadosamente</p>
<p>lasasignacionesdelheapparacolocardatoscontroladosporelatacantedondeelobjetoliberado</p>
<p>residíaanteriormente.</p>
<p>Mecánica del Bug:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ CICLO DE VIDA UAF │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<h2>│ 1. ASIGNACIÓN │</h2>
<p>│ obj = malloc (sizeof (Object)); │</p>
<p>│ obj->vtable = &legitimate_vtable; │</p>
<h2>│ 2. USO LEGÍTIMO │</h2>
<p>│ obj->method (); // Llama función via vtable │</p>
<h2>│ 3. LIBERACIÓN │</h2>
<p>│ free (obj); // Memoria liberada, pero... │</p>
<p>│ // ¡El puntero 'obj' aún existe! │</p>
<p>│ 4. REASIGNACIÓN (por atacante) │</p>
<p>│ attacker_data = malloc (sizeof (Object)); │</p>
<p>│ // Mismo tamaño → puede obtener la misma ubicación │</p>
<p>│ attacker_data->vtable = &malicious_vtable; │</p>
<h2>│ 5. USO DESPUÉS DE LIBERACIÓN │</h2>
<p>│ obj->method (); // ¡Llama función del atacante! │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-2883 — Chrome ANGLE</p>
<p>Campo Detalle</p>
<p>Producto Afectado Google Chrome(componente ANGLE)</p>
<p>Tipo Use-After-Free</p>
<p>Vector Páginawebmaliciosa</p>
<p>Severidad Crítica</p>
<p>Código Explotable Remotamente Sí, sininteraccióndelusuario</p>
<p>El Bug</p>
<p>El componente ANGLE (Almost Native Graphics Layer Engine) de Google Chrome, que traduce lla-</p>
<p>madas de API Open GL ES a Direct X, Vulkan o Open GL nativo, contenía una vulnerabilidad de uso</p>
<p>después de liberación. El bug ocurría cuando los contextos Web GL eran destruidos mientras aún</p>
<p>estabanreferenciadosporoperaciones gráficaspendientes, dejandopunteros colgantesaobjetos</p>
<p>gráficosliberados.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Preparación del Entorno:</li>
</ol>
<p>Atacantecreapágina HTM Lmaliciosaconcódigo Java Script Web GL</p>
<p>Elcódigomanipulalacreaciónydestruccióndecontextosgráficos</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>// Concepto simplificado (no es el exploit real):</p>
<p>let ctx = canvas. get Context ('webgl');</p>
<p>// Iniciar operación gráfica asíncrona</p>
<p>ctx. bind Buffer (ctx. ARRAY_BUFFER, buffer);</p>
<p>// Destruir contexto mientras operación está pendiente</p>
<p>ctx = null;</p>
<p>// Garbage collection libera el contexto</p>
<p>// pero operación pendiente aún tiene referencia</p>
<ol>
  <li>Heap Feng-Shui:</li>
</ol>
<p>Usartécnicasdeheapsprayparacontrolarasignaciones</p>
<p>Asignarobjetosdelmismotamañoqueelobjetoliberado</p>
<p>Colocardatoscontroladosporatacanteenubicaciónliberada</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>Cuandocódigode ANGL Eusaelpunterocolgante, accedeadatosdelatacante</p>
<p>Elatacantecolocaunobjetofalsoconvtablemaliciosa</p>
<p>Lapróximallamadaamétodovirtualejecutacódigodelatacante</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigovíapáginawebmaliciosacon N Ointeraccióndelusuariomásallá</p>
<p>devisitarlapágina</p>
<p>Al colocar un objeto falso en la memoria liberada, el atacante puede secuestrar el flujo de</p>
<p>control</p>
<p>Ejecutarcódigoarbitrarioenelprocesodelrenderer</p>
<p>Puedeencadenarseconexploitsdeescapedesandboxparacompromisocompletodelsiste-</p>
<p>Mitigación</p>
<p>Google Chrome 123. 0.6312. 86 (lanzado marzo 2024) corrigió la vulnerabilidad: - Implementación</p>
<p>degestiónadecuadadeltiempodevidaparaobjetosgráficos-Añadidoconteodereferenciaspara</p>
<p>prevenirdestrucciónprematuradeobjetosaúnenuso-Validaciónadicionalantesdeusarpunteros</p>
<p>aobjetosgráficos</p>
<p>Observaciones</p>
<p>Las vulnerabilidades UAF son particularmente peligrosas en: - Navegadores: Aplicaciones C++</p>
<p>complejasdondeeltiempodevidadeobjetosesdifícilderastrear-Subsistemas Gráficos: ANGLE,</p>
<p>Skiaysimilaresmanejancontenidonoconfiableytienengestióndeestadocompleja-Códigocon</p>
<p>Callbacks Asíncronos: Dondeelordendeejecuciónesdifícildepredecir</p>
<p>Son un objetivo favorito de atacantes avanzados porque: - Ofrecen control fino sobre la ejecución</p>
<p>del programa - Son difíciles de detectar con análisis estático - Las mitigaciones modernas (ASLR)</p>
<p>puedenserevadidascontécnicasdeheapmanipulation</p>
<ol>
  <li>1.3. 1. 1.3 Desbordamiento de Búfer en Heap (Heap Buffer Overflow)</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Similaralosdesbordamientosdepila, losdesbordamientosdeheapocurrencuandounprograma</p>
<p>escribemásalládeloslímitesdeunbúferasignadodinámicamenteenelheap. Enlugardecorrom-</p>
<p>per frames de pila, los desbordamientos de heap típicamente corrompen metadatos del heap o</p>
<p>objetosadyacentes, llevandoacorrupcióndememoriacuandoelallocatorposteriormenteprocesa</p>
<p>lasestructurascorrompidas.</p>
<p>Mecánica del Desbordamiento de Heap:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ LAYOUT DE HEAP │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ┌─────────────────────────────────────────┐ │</p>
<p>│ │ Chunk Header (metadatos del allocator) │ │</p>
<p>│ ├─────────────────────────────────────────┤ │</p>
<p>│ │ Búfer Vulnerable [100 bytes] │ │</p>
<p>│ │ │ │</p>
<p>│ │ ════════════════════════════════════════│← Límite │</p>
<h2>│ │ OVERFLOW →→→→→→→→→→→→→→→→→→→→→→→→→→→→ │ │</h2>
<p>│ └─────────────────────────────────────────┘ │</p>
<p>│ ┌─────────────────────────────────────────┐ │</p>
<p>│ │ Chunk Header (CORROMPIDO) ←←←←←←←←←←← │← Corrupción │</p>
<p>│ ├─────────────────────────────────────────┤ │</p>
<p>│ │ Objeto Adyacente │ │</p>
<p>│ │ - vtable * │← O corrupción │</p>
<p>│ │ - function_ptr │ de objeto │</p>
<p>│ │ - data fields │ │</p>
<p>│ └─────────────────────────────────────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-4863 — lib Web P</p>
<p>Campo Detalle</p>
<p>Producto Afectado lib Web P(Chrome, Firefox, Edge, múltiplesapps)</p>
<p>Tipo Heap Buffer Overflow</p>
<p>Vector Imagen Web Pmaliciosa</p>
<p>Severidad Crítica</p>
<p>Po C Disponible github. com/mistymntncop/CVE-2023-4863</p>
<p>El Bug</p>
<p>Labibliotecalib Web P, utilizadapor Chrome, Firefox, Edgeymuchasotrasaplicacionesparaproce-</p>
<p>sar imágenes Web P, contenía un desbordamiento de heap en la función Build Huffman Table (). Al</p>
<p>parsearimágenes Web Pespecialmentediseñadascondatosdecodificación Huffmanmalformados,</p>
<p>lafunciónescribíamásalládeloslímitesdelbúferasignado.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Vector de Entrada:</li>
</ol>
<p>Atacanteembebeimagen Web Pmaliciosaenpáginaweb</p>
<p>Olaenvíavíaaplicacionesdemensajería(Whats App, Telegram, Signal)</p>
<p>Oincluyeendocumento(email, Word, PDF)</p>
<ol>
  <li>Trigger:</li>
</ol>
<p>Navegador/aplicacióndevíctimaintentadecodificarlaimagen</p>
<p>Parser Web Pprocesadatos Huffmanmalformados</p>
<p>Build Huffman Table () calculatamañodetablaincorrectamente</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>Eldesbordamientocorrompemetadatosdelheap</p>
<p>Ocorrompeobjetosadyacentesconfunciónpointers</p>
<p>Atacantecontroladatosdeldesbordamientoparaconseguirprimitivas</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>Ejecucióndecódigoarbitrarioencontextodelproceso</p>
<p>Ennavegadores: códigoejecutaenprocesorenderer</p>
<p>Impacto</p>
<p>Ejecución remota de código sin interacción del usuario más allá de ver una página web o</p>
<p>abrirunaimagen</p>
<p>Zero-dayexplotado activamente antesdesudivulgaciónpública(septiembre 2023)</p>
<p>Billones de dispositivos afectados enmúltiplesplataformas:</p>
<p>·  Windows, mac OS, Linux(desktop)</p>
<p>·  Android, i OS(mobile)</p>
<p>·  Cualquiersoftwareusandolib Web P(Electronapps, etc.)</p>
<p>Por Qué Esta Vulnerabilidades Emblemática:</p>
<ol>
  <li>Riesgo de Cadena de Suministro: Un bug en lib Web P afectó docenas de aplicaciones ma-</li>
</ol>
<p>yores</p>
<ol>
  <li>Ubicuidad de Imágenes: Lasimágenessonprocesadasautomáticamenteysonubicuas</li>
  <li>Técnicas Modernas de Heap: Los atacantes combinaron heap overflow con técnicas de by-</li>
</ol>
<p>passde ASLR</p>
<p>Mitigación</p>
<p>lib Web P 1. 3.2 (septiembre 2023): Corrigióverificacióndelímitesen Build Huffman Table ()</p>
<p>Chrome 116. 0.5845. 187: Parchedeemergencia</p>
<p>Firefox 117. 0.1: Parchedeemergencia</p>
<p>Otrossoftwareafectadolanzóactualizacionescoordinadas</p>
<p>Observaciones</p>
<p>Los desbordamientos de heap en parsers de imágenes son particularmente peligrosos porque: -</p>
<p>Las imágenes son procesadas automáticamente sin confirmación del usuario - Son compartidas</p>
<p>rutinariamente y consideradas “seguras” - Parsers de imagen optimizan rendimiento, sacrificando</p>
<p>verificaciones de seguridad - La complejidad de formatos de compresión (Huffman, LZW, etc.) in-</p>
<p>troducebugs</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>1.4. 1. 1.4 Lectura Fuera de Límites (Out-of-Bounds Read / Info Leak)</li>
</ol>
<p>Descripción General</p>
<p>Unalecturafueradelímites(Out-of-Bounds Read)ocurrecuandounprogramaleememoriapasando</p>
<p>los límites de un búfer sin modificarla. Aunque no permite escritura directa, frecuentemente se</p>
<p>utilizapara:-Filtrarpunterosparabypassde ASLR/KASLR-Exponermetadatosdeobjetospara</p>
<p>construir primitivas más poderosas - Revelar diseño de memoria del kernel para explotación</p>
<p>confiable</p>
<p>Rolen Cadenas de Explotación:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ CADENA DE EXPLOTACIÓN TÍPICA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 1. OOB READ │ ← Filtrar direcciones de kernel │</p>
<p>│ │ (Info Leak) │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 2. KASLR BYPASS │ ← Calcular direcciones reales │</p>
<p>│ │ │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 3. WRITE PRIMITIVE│ ← Otra vulnerabilidad (UAF, overflow)│</p>
<p>│ │ │ │</p>
<p>│ └─────────┬─────────┘ │</p>
<p>│ │ │</p>
<p>│ ▼ │</p>
<p>│ ┌───────────────────┐ │</p>
<p>│ │ 4. CODE EXECUTION │ ← Escribir a ubicación conocida │</p>
<p>│ │ │ │</p>
<p>│ └───────────────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-53108 — Linux AMDGPU Display Driver</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(driver AMD Display)</p>
<p>Tipo Out-of-Bounds Read(slab-out-of-bounds)</p>
<p>Vector Datos EDID/displaymaliciosos</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Campo Detalle</p>
<p>Severidad Media-Alta</p>
<p>Diff del Parche git. kernel. org</p>
<p>El Bug</p>
<p>En el driver de display AMD del kernel Linux, la ruta de parsing EDID/VSDB (Video Specification</p>
<p>Database)teníaverificacióninsuficientedelímitesalextraeridentificadoresdecapacidades. Cuando</p>
<p>procesaba datos EDID con campos de longitud manipulados, el driver leía más allá de los límites</p>
<p>delbúfer EDI Dasignado.</p>
<p>Elbugfuedetectadopor KASAN(Kernel Address Sanitizer)quereportóaccesoslab-out-of-bounds</p>
<p>durantelaextraccióndedatosdeldisplay.</p>
<p>El Ataque</p>
<p>Unflujodedatos EDID/displaymaliciosamenteconstruidopodría:1. Dispararlectura OO Benespa-</p>
<p>cio de kernel 2. Exponer contenidos de memoria de kernel (incluyendo punteros) 3. Proporcionar</p>
<p>información para evadir KASLR 4. Ser encadenado con otra vulnerabilidad de escritura para explo-</p>
<p>tacióncompleta</p>
<p>Impacto</p>
<p>Divulgación de información: Exposicióndecontenidodememoriadelkernel</p>
<p>Potencial inestabilidad del sistema: Lecturadememoriainválidapuedecausaroops</p>
<p>Habilitador de explotación: Utilizable para evadir KASLR en cadenas de explotación más</p>
<p>complejas</p>
<p>Por Qué las OOB Reads Importan:</p>
<p>En contextos de kernel: - KASLR es una mitigación fundamental contra explotación - Sin info</p>
<p>leak, escritura ciega falla - el atacante necesita saber dónde escribir - OOB reads son el primer</p>
<p>pasodelamayoríadeexploitsmodernosdekernel</p>
<p>Mitigación</p>
<p>Las actualizaciones del kernel ajustaron la validación de longitud: - Verificar que b Length sea >=</p>
<p>tamaño mínimo esperado - Validar offsets antes de acceder a campos - Asegurar que todas las</p>
<p>lecturaspermanezcandentrodeloslímitesdelbúfer EDID</p>
<p>Observaciones</p>
<p>Las lecturas OOB puras son valiosas para construir cadenas de explotación confiables: - Proporcio-</p>
<p>nan información necesaria para bypass de ASLR/KASLR - Son frecuentemente la primera etapa de</p>
<p>exploitsmulti-paso-Enkernel, derrotar KASL Respivotalparaexplotaciónconfiable</p>
<ol>
  <li>1.5. 1. 1.5 Uso de Memoria No Inicializada (Uninitialized Memory Use)</li>
</ol>
<p>Descripción General</p>
<p>Usarmemoriadepila/heap/poolantesdequeseainicializadapuedeexponercontenidosresiduales</p>
<p>deoperacionesprevias. Estoscontenidospuedenincluir:-Punterosprevios(direccionesdelkernel</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>parabypassde KASLR)-Flagsdecapacidad(paraescaladadeprivilegios)-Camposdeestructura</p>
<p>(paraconfusióndetipos)</p>
<p>Por Qué Es Peligroso:</p>
<p>// Código vulnerable - variable no inicializada</p>
<p>void vulnerable_function (struct netlink_msg *msg) {</p>
<p>struct nft_pipapo_match *m; // ← NO INICIALIZADO</p>
<p>// Si algún camino de código no asigna 'm'...</p>
<p>if (some_condition (msg)) {</p>
<p>m = find_match (msg);</p>
<p>// ... pero 'm' se usa incondicionalmente</p>
<p>copy_to_user (response, &m, sizeof (m)); // ← Filtra pila residual</p>
<p>Caso de Estudio: CVE-2024-26581 — Linux Kernel Netfilter</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(subsistemanetfilter)</p>
<p>Tipo Usode Variable No Inicializada</p>
<p>Vector Mensajesnetlinklocales</p>
<p>Severidad Alta</p>
<p>Po C Disponible sploitus. com/exploit?id=A4D521EE-225F-57D5-8C31-</p>
<h2>9F1C86D066B6</h2>
<p>El Bug</p>
<p>Elsubsistemanetfilterdelkernel Linuxconteníaunavulnerabilidaddevariablenoinicializadaenel</p>
<p>componente nf_tables. Al procesar mensajes netlink para configurar reglas de firewall, la función</p>
<p>nft_pipapo_walk () fallabaeninicializarunavariablelocalantesdesuuso.</p>
<p>Lavariablenoinicializadadepilapodríacontenerdatosresidualesdellamadasafuncionesprevias,</p>
<p>incluyendopunterosdelkernelydireccionesdememoriasensibles.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Obtener Capacidades:</li>
</ol>
<p>Atacanteestáenespaciodenombresdeusuarionoprivilegiado</p>
<p>Usernamespacesotorgan CAP_NET_ADMIN(defaulten Ubuntu, Debian)</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>Enviarmensajesnetlinkespecíficosdeconfiguracióndenf_tables</p>
<p>Causarqueseejecutelarutadecódigoconvariablenoinicializada</p>
<p>Lavariableseleeysecopiadevueltaalespaciodeusuario</p>
<ol>
  <li>Recolectar Información:</li>
</ol>
<p>Repetireltriggermúltiplesveces</p>
<p>Analizardatosretornados</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Extraerdireccionesdekernel(heap, stack, código)</p>
<ol>
  <li>Explotar con Información:</li>
</ol>
<p>Usardireccionesfiltradasparaevadir KASLR</p>
<p>Combinarconotravulnerabilidaddeescrituradenetfilter</p>
<p>Lograrescaladadeprivilegioscompleta(LP Echain)</p>
<p>Impacto</p>
<p>Divulgación de información →bypassde KASLR</p>
<p>Lasdireccionesdelkernelfiltradaspermitenexplotaciónconfiabledeotrasvulnerabilidades</p>
<p>Particularmentepeligrosacuandosecombinaconotrosbugsdenetfilterparacadenas LPE</p>
<p>completas</p>
<p>Peligro del Combo: Netfilter+ User Namespaces</p>
<p>Muchas distribuciones Linux permiten user namespaces no privilegiados por defecto: - Ubuntu:</p>
<p>Habilitadopordefecto-Debian: Habilitadopordefecto-Fedora: Habilitadopordefecto</p>
<p>Estosignificaque CAP_NET_ADMI Nestádisponibleparausuariosnoprivilegiados, haciendoquebugs</p>
<p>denetfilterseanexplotablessinprivilegiosroot.</p>
<p>Mitigación</p>
<p>Linuxkernel 6. 8-rc 1(febrero 2024):-Añadióinicializaciónapropiada: struct nft_pipapo_match *m</p>
<p>= NULL; - Habilitó inicializadores designados para estructuras de pila - Habilitó advertencias de</p>
<p>compiladormásestrictas(-Wuninitialized)paranetfilter</p>
<p>Observaciones</p>
<p>Las lecturas de memoria no inicializada son frecuentemente la primera etapa en cadenas de ex-</p>
<p>plotación: - Proporcionan reducciones de entropía para evadir mitigaciones modernas - Son parti-</p>
<p>cularmente valiosas en explotación de kernel donde KASLR es esencial - La combinación de user</p>
<p>namespaces no privilegiados y fugas de netfilter hace esta clase de vulnerabilidad accesible a ata-</p>
<p>canteslocalessinrequerirprivilegiosroot</p>
<ol>
  <li>1.6. 1. 1.6 Errores de Conteo de Referencias (Reference Counting Bugs)</li>
</ol>
<p>Descripción General</p>
<p>Los errores de conteo de referencias ocurren cuando hay incrementos/decrementos incorrectos o</p>
<p>desbordamientosencontadoresquecontrolaneltiempodevidadeobjetos(sistemasdearchivos,</p>
<p>networking, drivers). Estosbugspuedenllevara:-Liberaciónprematura: Objetoliberadomientras</p>
<p>referenciasaúnexisten→UAF-Memoryleak: Objetonuncaliberado→agotamientodememoria</p>
<p>-Double-free: Decrementoexcesivo→corrupcióndeheap</p>
<p>Mecánica de Reference Counting:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ GESTIÓN DE CONTEO DE REFERENCIAS │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ CORRECTO: │</h2>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref = 1 │ ──► │ ref = 2 │ ──► │ ref = 1 │ ──► free () │</p>
<p>│ │ (alloc) │ │ (add) │ │ (drop) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<h2>│ BUG - LIBERACIÓN PREMATURA: │</h2>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref = 1 │ ──► │ ref = 0 │ ──► │ USE │ ← UAF! │</p>
<p>│ │ (alloc) │ │ (drop) │ │ (bug) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<h2>│ BUG - DESBORDAMIENTO DE REFCOUNT: │</h2>
<p>│ ┌─────────┐ ┌─────────┐ ┌─────────┐ │</p>
<p>│ │ ref=MAX │ ──► │ ref = 0 │ ──► │ free () │ ← ¡Aún usado!│</p>
<p>│ │ │ │(overflow)│ │ (wrong) │ │</p>
<p>│ └─────────┘ └─────────┘ └─────────┘ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2022-32250 — Linux Netfilter nf_tables</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(nf_tables)</p>
<p>Tipo Errorde Conteode Referencias→UAF</p>
<p>Vector Usernamespacesnoprivilegiados</p>
<p>Severidad Crítica</p>
<p>Exploit Público github. com/theori-io/CVE-2022-32250-exploit</p>
<p>El Bug</p>
<p>Elsubsistemanetfilterdelkernel Linux(net/netfilter/nf_tables_api. c)teníaunerrordeconteo</p>
<p>dereferenciasenelcomponentenf_tables. Unaverificaciónincorrectade NFT_STATEFUL_EXP Rfallaba</p>
<p>en rastrear adecuadamente los tiempos de vida de objetos de expresión durante actualizaciones</p>
<p>dereglas, llevandoadestrucciónprematuradeobjetosmientrasreferenciasaúnexistían.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Configuración del Entorno:</li>
</ol>
<p>Atacantecreausernamespacenoprivilegiado</p>
<p>Estootorga CAP_NET_ADMI Ndentrodelnamespace</p>
<p>Permitemanipularreglasdenf_tables</p>
<ol>
  <li>Disparar el Bug:</li>
</ol>
<p>Crearexpresionesstatefulenreglasdenf_tables</p>
<p>Modificarreglasensecuenciasespecíficas</p>
<p>Causarqueelkerneldecrementerefcountincorrectamente</p>
<ol>
  <li>Condición UAF:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Elkernelliberaunobjetodeexpresión</p>
<p>Otrareferenciaalobjetoaúnexiste</p>
<p>Elcódigocontinúausandoelpunterocolgante</p>
<ol>
  <li>Explotación:</li>
</ol>
<p>Usartécnicasdeheapsprayparareclamarlamemorialiberada</p>
<p>Colocardatoscontroladosporatacanteenlaubicación</p>
<p>Usarelpunterocolganteparalograrlectura/escrituraarbitraria</p>
<ol>
  <li>Escalada de Privilegios:</li>
</ol>
<p>Modificarcredencialesdelproceso(task_struct->cred)</p>
<p>Osobrescribirpunterosdefuncióndelkernel</p>
<p>Obtenerrootdesdeusuarionoprivilegiado</p>
<p>Impacto</p>
<p>Escalada de privilegios local de cualquier usuario a root en sistemas que permiten names-</p>
<p>pacesnoprivilegiados</p>
<p>La primitiva UA Fpuedeexplotarseparalectura/escrituraarbitrariadememoriadelkernel</p>
<p>Afectókernels Linuxdesde 4. 1(2015)hasta 5. 18. 1(2022)-másde 7 añosdevulnerabilidad</p>
<p>Exploit público disponible haceestavulnerabilidadespecialmentepeligrosa</p>
<p>Distribuciones Afectadas (namespaces habilitados por defecto): -Ubuntu-Debian</p>
<p>-Fedora-Ymuchasotras</p>
<p>Mitigación</p>
<p>Linuxkernel 5. 18. 2+corrigiólalógicadeconteodereferencias:-Añadióincrementos/decrementos</p>
<p>derefcountexplícitosenlospuntosapropiadosdelcódigo-Asegurórastreoadecuadodeltiempo</p>
<p>devidaduranteoperacionesdereglas-Agregóvalidacionesadicionalesenexpresionesstateful</p>
<p>Observaciones</p>
<p>Losbugsdeconteodereferencias:-Sonsutiles: Puedenllevaracondicionesdeliberaciónprema-</p>
<p>tura → use-after-free - O desbordamiento de refcount → free mientras referencias permanecen</p>
<p>- Son particularmente peligrosos en código del kernel donde gestión del tiempo de vida de ob-</p>
<p>jetos es crítica - La accesibilidad vía user namespaces no privilegiados hizo esta vulnerabilidad</p>
<p>particularmenteimpactanteparaescaladadeprivilegioslocal</p>
<ol>
  <li>1.7. 1. 1.7 Desreferencia de Puntero Nulo (NULL Pointer Dereference)</li>
</ol>
<p>Descripción General</p>
<p>Desreferenciarunpuntero NUL Lencódigoprivilegiado. Mientraslossistemasmodernostípicamen-</p>
<p>te previenen el mapeo de páginas NULL en espacio de usuario (mitigando técnicas históricas de</p>
<p>escalada de privilegios), las desreferencias de puntero NULL en kernel siguen siendo fuente signi-</p>
<p>ficativa de vulnerabilidades de: - Denegación de Servicio (kernel panic inmediato) - Divulgación</p>
<p>de Información (en algunos contextos) - Escalada de Privilegios (en configuraciones específicas</p>
<p>legacy)</p>
<p>Evolución de la Mitigación:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<h2>│ EVOLUCIÓN DE PROTECCIONES CONTRA NULL DEREF │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ ANTES (Linux < 2. 6.23): │</p>
<p>│ ┌─────────────────────────────────────────────────────┐ │</p>
<p>│ │ Espacio de Usuario podía mapear página 0 │ │</p>
<p>│ │ NULL deref → Ejecuta código de atacante → ROOT │ │</p>
<p>│ └─────────────────────────────────────────────────────┘ │</p>
<p>│ DESPUÉS (Linux moderno con mmap_min_addr): │</p>
<p>│ ┌─────────────────────────────────────────────────────┐ │</p>
<p>│ │ Página 0 no puede ser mapeada por usuario │ │</p>
<p>│ │ NULL deref → Kernel Panic → Do S (pero no RCE) │ │</p>
<p>│ └─────────────────────────────────────────────────────┘ │</p>
<p>│ /proc/sys/vm/mmap_min_addr = 65536 (típico) │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-52434 — Linux SMB Client</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(cliente SMB/CIFS)</p>
<p>Tipo Desreferenciade Puntero Nulo</p>
<p>Vector Servidor SM Bmalicioso</p>
<p>Severidad Alta(CVSS8. 0)</p>
<p>Vectorde Ataque Redadyacente</p>
<p>El Bug</p>
<p>La implementación del cliente SMB del kernel Linux contenía una vulnerabilidad de desreferencia</p>
<p>de puntero nulo en la función smb 2_parse_contexts (). Al parsear respuestas del servidor durante</p>
<p>elestablecimientodeconexión SMB2/SMB3, elcódigofallabaenvalidarapropiadamenteoffsetsy</p>
<p>longitudesdeestructurasdecontextodecreaciónantesdedesreferenciarpunteros.</p>
<p>Loscontextosmalformadosconoffsetsinválidospodíancausarqueelkernelaccedieraadirecciones</p>
<p>dememorianomapeadas, disparandounadesreferenciadepunteronulo.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Vector de Entrada:</li>
</ol>
<p>Servidor SM Bmaliciosoocomprometidoenlared</p>
<p>Oataqueman-in-the-middlemodificandorespuestas SMB</p>
<ol>
  <li>Trigger:</li>
</ol>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Servidor envía respuestas SMB2_CREATE con estructuras de contexto de creación inváli-</p>
<p>Offsetsapuntanfueradelosdatosválidos</p>
<p>Olongitudescalculanadirecciones NULL</p>
<ol>
  <li>Crash:</li>
</ol>
<p>Cliente Linuxintentamontarelshareoaccederaarchivos</p>
<p>Kernelparseacontextosmalformadossinverificacióndelímites</p>
<p>Accesoadireccióninválida→kernelpanic</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>BUG: unable to handle page fault for address: ffff 8881178 d 8 cc 3</p>
<p>#PF: supervisor read access in kernel mode</p>
<p>Call Trace:</p>
<p>smb 2_parse_contexts+0 x...</p>
<p>Impacto</p>
<p>Denegación de servicio afectandokernels Linuxdesde 5. 3 hasta 6. 7-rc 5</p>
<p>La desreferenciade punteronulo causabakernelpanicinmediato</p>
<p>Cualquier usuario con permiso para montar shares SMB podíadispararlavulnerabilidad</p>
<p>Explotable en entornos multi-usuario dondemontaje SM Bestápermitido</p>
<p>Contextosde Explotación:-Redcorporativa: Usuariomaliciosolevantaservidor SM Bfalso-Wi Fi</p>
<p>público: Atacante hace MITM de conexiones SMB - Red comprometida: Servidor SMB legítimo</p>
<p>comprometidoenvíarespuestasmaliciosas</p>
<p>Mitigación</p>
<p>Parches del kernel Linux (versiones 5. 4.277, 5. 10. 211, 5. 15. 150, 6. 1.80 y 6. 6.8+): - Añadieron vali-</p>
<p>dación comprehensiva de offsets de contextos de creación - Verifican que longitudes no excedan</p>
<p>límitesdelbúfer-Aseguranquetodaaritméticadepunterospermanezcadentrodelímitesasigna-</p>
<p>Observaciones</p>
<p>Lasdesreferenciasdepunteronuloenparsersdeprotocolosderedsonparticularmentepeligrosas</p>
<p>porque:-Puedenserdisparadasremotamenteporservidoresmaliciosos-Omedianteataques</p>
<p>MIT Mmodificandotráficodered-Mientraslasproteccionesmodernasdelkernelprevienenel</p>
<p>mapeo de página NULL (mitigando RCE histórico) - El impacto de Do S permanece crítico para</p>
<p>disponibilidad</p>
<ol>
  <li>1.8. 1. 1.8 Conclusiones de Corrupción de Memoria</li>
</ol>
<p>Hallazgos Clave:</p>
<ol>
  <li>Lacorrupcióndememoriasiguesiendoprevalente: Apesardedécadasdeinvestigaciónen</li>
</ol>
<p>seguridad, los bugs de corrupción de memoria continúan plagando software, especialmente</p>
<p>enbasesdecódigo C/C++.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>La defensa en profundidad es esencial: Cada ejemplo del mundo real muestra atacantes</li>
</ol>
<p>evadiendomúltiplesmecanismosdeprotección(DEP, ASLR, CET, XFG, safe-linking).</p>
<ol>
  <li>Lasmitigacionesmodernaselevanlabarreraperonoeliminanelriesgo: Mientrastecno-</li>
</ol>
<p>logíascomo CE Tshadowstackysafe-linkingdificultanlaexplotación, atacantesdeterminados</p>
<p>continúanencontrandobypasses.</p>
<ol>
  <li>Lascausasraízsonsimilares, peroloscontextosdifieren: Bugsdestack, heapy UA Fcom-</li>
</ol>
<p>parten causas raíz comunes (verificación inadecuada de límites, gestión de tiempo de vida)</p>
<p>perorequierendiferentestécnicasdeexplotación.</p>
<ol>
  <li>Los componentes legacy permanecen vulnerables: Vulnerabilidades de años de antigüe-</li>
</ol>
<p>dad en parsers de office y manejadores de archivos continúan siendo explotadas debido a</p>
<p>ciclosdeparcheolentos.</p>
<p>Preguntasde Discusión:</p>
<ol>
  <li>¿Qué puntos en común ves a través de las clases de vulnerabilidades de corrupción de me-</li>
</ol>
<p>moriacubiertas?</p>
<ol>
  <li>¿Por qué persisten las vulnerabilidades de corrupción de memoria a pesar de décadas de</li>
</ol>
<p>investigaciónenlenguajesmemory-safe?</p>
<ol>
  <li>¿Cómodifierenlastécnicasdeexplotaciónentrevulnerabilidadesdestack, heapy UAF?</li>
  <li>¿Qué mecanismos de defensa fueron evadidos en cada ejemplo, y qué nos dice eso sobre el</li>
</ol>
<p>estadoactualdelamitigacióndeexploits?</p>
<ol>
  <li>2. 1. 2 Vulnerabilidades Lógicas y Condiciones de Carrera</li>
</ol>
<p>Las vulnerabilidades lógicas no involucran corrupción de memoria pero pueden ser igualmente</p>
<p>peligrosas. Estaseccióncubrecondicionesdecarrera, bugs TOCTOU, double-fetch, fallasdeauten-</p>
<p>ticación, primitivasdeescrituraarbitrariaymalusodesincronización.</p>
<p>Recursosde Lectura:-“Web Application Security,2 nd Edition”por Andrew Hoffman-Capítulo 18:</p>
<p>“Business Logic Vulnerabilities” - Portswigger Logic Flaws - Time-of-check Time-of-use (TOCTOU)</p>
<p>Vulnerabilities-Microsoft: Avoiding Race Conditions</p>
<ol>
  <li>2.1. 1. 2.1 Condiciones de Carrera (Race Conditions)</li>
</ol>
<p>Descripción General</p>
<p>Unacondicióndecarreraocurrecuandoelcomportamientodelsoftwaredependedeltimingrelati-</p>
<p>vodeeventos, comoelordenenqueloshilosejecutan. Cuandomúltipleshilosoprocesosacceden</p>
<p>a recursos compartidos sin sincronización apropiada, un atacante puede manipular el timing para</p>
<p>causarcomportamientoinesperado.</p>
<p>Patrones Comunes:</p>
<ol>
  <li>Condiciones de Carrera en Sistema de Archivos: Verificar permisos de un archivo, luego</li>
</ol>
<p>abrirlo(atacanteintercambiaelarchivoentreverificaciónyapertura)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>Double-Fetch: Kernel lee memoria de modo usuario dos veces, atacante la modifica entre</li>
</ol>
<p>lecturas</p>
<ol>
  <li>Primitivas de Sincronización: Uso faltante o incorrecto de locks, mutexes u operaciones</li>
</ol>
<p>atómicas</p>
<p>Caso de Estudio: CVE-2024-26218 — Windows Kernel TOCTOU</p>
<p>Campo Detalle</p>
<p>Producto Afectado Windows Kernel</p>
<p>Tipo Condiciónde Carrera TOCTOU</p>
<p>Vector Local</p>
<p>Severidad Alta(CVSS7. 7)</p>
<p>El Bug</p>
<p>Unacondicióndecarrera Time-of-Check Time-of-Useenel Windows Kernelpermitíaaunatacante</p>
<p>explotarunaventanadetimingentrelavalidaciónyelusoderecursosdelkernel. Lavulnerabilidad</p>
<p>ocurríacuandoelkernelverificabapermisosoestadosderecursosperonorealizabaatómicamente</p>
<p>la operación subsecuente, permitiendo a un hilo en carrera modificar el estado del recurso entre</p>
<p>verificaciónyuso.</p>
<p>El Ataque (Paso a Paso)</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ ATAQUE TOCTOU │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ KERNEL ATACANTE │</h2>
<p>│ ────── ──────── │</p>
<p>│ │ │ │</p>
<p>│ │ 1. Verificar permisos │ │</p>
<p>│ │ del recurso │ │</p>
<p>│ │ resultado: OK │ │</p>
<p>│ │ ║ │ │</p>
<p>│ │ ║ ═══════════════════ │ │</p>
<p>│ │ ║ VENTANA DE │ 2. Modificar │</p>
<p>│ │ ║ CARRERA │ estado del │</p>
<p>│ │ ║ │ recurso │</p>
<p>│ │ ║ ═══════════════════ │ │</p>
<p>│ │ ▼ │ │</p>
<p>│ │ 3. Usar recurso (ahora │ │</p>
<p>│ │ modificado por atacante) │ │</p>
<p>│ │ │ │</p>
<p>│ │ 4. RESULTADO: Escalada de │ │</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>│ │ privilegios │ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldeusuariodebajosprivilegiosa SYSTEM</p>
<p>AfectóWindows 10, Windows 11 y Windows Server 2019/2022</p>
<p>Parcheadoenabril 2024(Microsoft Patch Tuesday)</p>
<p>Por Qué Es Difícil de Corregir:</p>
<p>Las condiciones de carrera requieren: - Operaciones atómicas de check-and-use - Mecanismos de</p>
<p>bloqueoapropiadosatravésdesubsistemascomplejosdelkernel-Copiadefensivaparaasegurar</p>
<p>que el estado verificado coincida con el estado usado - Muchas operaciones del kernel asumen</p>
<p>ejecuciónsecuencialsinconsiderarmodificaciónconcurrente</p>
<p>Mitigación</p>
<p>Microsoft implementó: - Operaciones atómicas de verificación y uso - Mecanismos de bloqueo</p>
<p>apropiados para recursos compartidos - Copia defensiva para asegurar coincidencia de estado ve-</p>
<p>rificado/usado</p>
<p>Observaciones</p>
<p>Lascondicionesdecarrerasondifícilesdereproducirperoproporcionanexplotaciónconfiablecuan-</p>
<p>do el timing es controlado. Requieren comprensión profunda del modelo de concurrencia del sis-</p>
<p>temaobjetivo.</p>
<ol>
  <li>2.2. 1. 2.2 Vulnerabilidades TOCTOU (Time-of-Check Time-of-Use)</li>
</ol>
<p>Descripción General</p>
<p>TOCTOU es un tipo específico de condición de carrera donde hay una brecha entre verificar una</p>
<p>condición y usar el resultado. Durante esa brecha, la condición puede cambiar, invalidando la veri-</p>
<p>ficación.</p>
<p>Ejemplo Clásico — Ataques con Symlinks:</p>
<p>// Programa vulnerable</p>
<ol>
  <li>if (access ("/tmp/important_file", W_OK) == 0) { // VERIFICACIÓN</li>
</ol>
<p>// [VENTANA DE CARRERA] Atacante: ln -s /etc/passwd /tmp/important_file</p>
<ol>
  <li>fd = open ("/tmp/important_file", O_WRONLY); // USO</li>
</ol>
<p>write (fd, data, size); // ¡Escribe a /etc/passwd!</p>
<p>Impacto del Mundo Real:</p>
<p>Escalada de Privilegios: Bugs TOCTOU en programas privilegiados permiten a usuarios no</p>
<p>privilegiadosmodificararchivosprotegidos</p>
<p>Bypassde Verificacionesde Seguridad: Verificacionesdeautenticaciónoautorizaciónpue-</p>
<p>densereludidassielrecursocambiaentreverificaciónyuso</p>
<p>Corrupción de Datos: Modificaciones inesperadas de archivos pueden corromper el estado</p>
<p>delsistema</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Caso de Estudio: CVE-2025-11001/11002 — 7-Zip Symlink Path Traversal</p>
<p>Campo Detalle</p>
<p>Producto Afectado 7-Zip</p>
<p>Tipo TOCTOU/Path Traversalvia Symlink</p>
<p>Vector Archivo ZI Pmalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>Lavalidaciónimpropiadeobjetivosdesymlinksenlaextracciónde ZI Ppermitíatraversaldedirec-</p>
<p>toriosvíasymlinksmaliciosos, habilitandoescriturasfueradeldirectoriodeextracciónprevisto.</p>
<p>El Ataque:</p>
<ol>
  <li>Preparación del Archivo Malicioso:</li>
</ol>
<p>Atacantecreaarchivo ZIP/RA Respecialmentediseñado</p>
<p>Incluyeunsymlink: link. txt -> ../../../etc/cron. d/malicious</p>
<p>Incluyearchivolink. txtconcontenidomalicioso</p>
<ol>
  <li>Extracción:</li>
</ol>
<p>Usuarioextraearchivoen/home/user/downloads/</p>
<p>7-Zipcreasymlinkqueapuntafueradeldirectorio</p>
<p>Luegoescribecontenidoalsymlink</p>
<ol>
  <li>Resultado:</li>
</ol>
<p>Archivoescritoa/etc/cron. d/malicious</p>
<p>Ejecucióndecódigocomorootcuandocronprocesaelarchivo</p>
<p>Impacto</p>
<p>Escrituraarbitrariadearchivosllevandoapotencial RC Eencontextodeusuario</p>
<p>Dependiendodeldirectorioobjetivo(ej.~/. bashrc,/etc/cron. d/,~/. ssh/authorized_keys),</p>
<p>puedepermitirescaladadeprivilegios</p>
<p>Afectaatodoslosusuariosqueextraenarchivosdefuentesnoconfiables</p>
<p>Mitigación</p>
<p>Las actualizaciones abordaron: - Validación de conversión y lógica de symlinks durante extracción</p>
<p>- Verificación de que rutas de destino permanezcan dentro del directorio de extracción - Rechazo</p>
<p>desymlinksqueapuntanfueradelcontextodeextracción</p>
<p>Observaciones</p>
<p>Las vulnerabilidades TOCTOU en parsers de archivos son particularmente peligrosas porque los</p>
<p>usuariosfrecuentementeextraenarchivosdefuentesnoconfiablessinverificaciónadicional.</p>
<ol>
  <li>2.3. 1. 2.3 Vulnerabilidades Double-Fetch</li>
</ol>
<p>Descripción General</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Un double-fetch ocurre cuando el código del kernel lee memoria de modo usuario dos veces, asu-</p>
<p>miendoquenocambiaráentrelecturas. Unatacanteconmúltipleshilospuedemodificarlamemoria</p>
<p>después de la primera lectura pero antes de la segunda, causando que el código del kernel opere</p>
<p>sobredatosinconsistentes.</p>
<p>Mecánica:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ VULNERABILIDAD DOUBLE-FETCH │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<p>│ KERNEL ESPACIO USUARIO (Atacante) │</p>
<p>│ ────── ───────────────────────── │</p>
<p>│ │ │ │</p>
<p>│ │ 1. Primera lectura │ │</p>
<p>│ │ valor = *userptr │ │</p>
<p>│ │ (validar: valor == 1) │ │</p>
<p>│ │ ║ │ │</p>
<p>│ │ ║ ════════════════ │ │</p>
<p>│ │ ║ VENTANA │ 2. *userptr = 999 │</p>
<p>│ │ ║ ════════════════ │ │</p>
<p>│ │ ▼ │ │</p>
<p>│ │ 3. Segunda lectura │ │</p>
<p>│ │ usar *userptr │ │</p>
<p>│ │ (¡ahora es 999!) │ │</p>
<p>│ │ │ │</p>
<p>│ │ 4. Bug: código usa valor │ │</p>
<p>│ │ no validado (999) │ │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2023-4155 — Linux KVM AMD SEV Double-Fetch</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(KVMAMDSEV)</p>
<p>Tipo Double-Fetch→Stack Overflow</p>
<p>Vector Invitado V Mmalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>Una condición de carrera double-fetch en la implementación KVM AMD Secure Encrypted Virtua-</p>
<p>lization del kernel Linux. Invitados KVM usando SEV-ES o SEV-SNP con múltiples v CP Us podían</p>
<p>dispararlavulnerabilidadmanipulandomemoriacompartidadeinvitadoqueelhypervisorleedos</p>
<p>vecessinsincronizaciónapropiada.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>El Patróndel Bug:</p>
<p>Elmanejador VMGEXI Tenelhypervisorleíamemoriacontroladaporelinvitadoparadeterminarqué</p>
<p>operación realizar. Un atacante podía modificar esta memoria entre la primera lectura (validación)</p>
<p>ylasegundalectura(uso), causandocomportamientoinconsistente.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Primera Lectura: Hypervisor lee memoria del invitado para validar el código de razón de</li>
</ol>
<h2>VMGEXIT</h2>
<ol>
  <li>Ventanade Carrera: Elhilov CP Udelatacantemodificalamemoriadelinvitadoconteniendo</li>
</ol>
<p>elcódigoderazón</p>
<ol>
  <li>Segunda Lectura: Hypervisor lee el valor modificado y procesa una operación diferente a la</li>
</ol>
<p>validada</p>
<ol>
  <li>Resultado: Invocaciónrecursivadelmanejador VMGEXIT, llevandoadesbordamientodepila</li>
</ol>
<p>Impacto</p>
<p>Denegacióndeservicio(Do S)víadesbordamientodepilaenhypervisor</p>
<p>En configuraciones del kernel sin páginas de guarda de pila (CONFIG_VMAP_STACK), potencial</p>
<p>escape de invitado a host</p>
<p>Afectaentornosdevirtualizacióncon AMDSE Vhabilitado</p>
<p>Por Qué Es Difícil de Corregir:</p>
<p>Los double-fetch requieren: - Identificar todas las ubicaciones donde código del hypervisor lee</p>
<p>memoriadelinvitadomúltiplesveces-Copiardatosdelinvitadoamemoriadelhypervisorunavez</p>
<p>-Operarsobrelacopiaestable-Consideracionesderendimientohacenlacopiadefensivacostosa</p>
<p>enrutascalientesdevirtualización</p>
<p>Mitigación</p>
<p>Losparchesdelkernel Linux:-Añadieronsincronizaciónapropiadaparaasegurarqueelcódigode</p>
<p>razón VMGEXIT se lea una vez - Almacenaron el valor en variable local antes de validación y uso -</p>
<p>Añadieronverificacionesparaprevenirinvocaciónrecursivadelmanejador</p>
<p>Observaciones</p>
<p>Las vulnerabilidades double-fetch son particularmente difíciles de corregir y particularmente peli-</p>
<p>grosasencontextosdehypervisordondeelescapeinvitado→hosttieneimpactocrítico.</p>
<ol>
  <li>2.4. 1. 2.4 Fallas Lógicas en Autenticación</li>
</ol>
<p>Descripción General</p>
<p>Bugs en el flujo lógico de verificaciones de autenticación o autorización que permiten a atacantes</p>
<p>evadirlímitesdeseguridadsinexplotarcorrupcióndememoria.</p>
<p>Tipos de Fallas Lógicas de Autenticación:</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Tipo Descripción Ejemplo</p>
<p>Bypass de Accedersincredenciales Solicitudesmalformadas</p>
<p>Autenticación evadenverificación</p>
<p>Escalada Vertical Usuarioseconvierteenadmin Manipulacióndeparámetros</p>
<p>derol</p>
<p>Escalada Usuario Aaccedeadatosde B IDOR(Insecure Direct Object</p>
<p>Horizontal Reference)</p>
<p>Confusión de Estadodesesióninconsistente Tokensdereseteo</p>
<p>Estado reutilizables</p>
<p>Caso de Estudio: CVE-2024-0012 — Palo Alto PAN-OS Authentication Bypass</p>
<p>Campo Detalle</p>
<p>Producto Afectado Palo Alto Networks PAN-OS</p>
<p>Tipo Bypassde Autenticación</p>
<p>Vector Interfazwebdeadministración</p>
<p>Severidad Crítica</p>
<p>Po C Disponible github. com/0 xjessie 21/CVE-2024-0012</p>
<p>El Bug</p>
<p>Elsoftware PAN-O Sde Palo Alto Networksconteníaunavulnerabilidaddebypassdeautenticación</p>
<p>ensuinterfazwebdeadministración. Lavulnerabilidadpermitíaaunatacantenoautenticadoeva-</p>
<p>dir completamente las verificaciones de autenticación y obtener privilegios de administrador sin</p>
<p>proporcionarningunacredencial.</p>
<p>El Ataque:</p>
<ol>
  <li>Atacantetieneaccesoderedalainterfazwebdeadministraciónde PAN-OS</li>
  <li>Envíasolicitudesespecialmentediseñadasqueevadenlalógicadeautenticación</li>
  <li>Noserequierencredencialesniinteraccióndelusuario</li>
  <li>Atacanteobtieneaccesodirectodeadministrador</li>
</ol>
<p>Impacto</p>
<p>Bypasscompletodeautenticaciónpermitiendoaatacantesremotosnoautenticadosobte-</p>
<p>nerprivilegiosdeadministradorde PAN-OS</p>
<p>Habilitabarealizaraccionesadministrativas:</p>
<p>·  Manipularconfiguracionesdefirewall</p>
<p>·  Crearreglasparapermitirtráficomalicioso</p>
<p>·  Extraerconfiguracionesycredenciales</p>
<p>Podía encadenarse con otras vulnerabilidades como CVE-2024-9474 para explotación adi-</p>
<p>cional</p>
<p>Mitigación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Palo Altolanzóparchesenversiones 10. 2.12,11. 0.6,11. 1.5 y 11. 2.4(noviembre 2024):-Corrigieron</p>
<p>la lógica devalidaciónde autenticación - Recomendaronrestringir acceso a la interfaz de adminis-</p>
<p>traciónsoloa I Psinternasconfiablescomodefensaenprofundidad</p>
<p>Observaciones</p>
<p>Lasfallaslógicasenautenticaciónyautorizaciónpuedenllevara:-Escaladadeprivilegios(usuario</p>
<p>seconvierteenadmin)-Escaladahorizontal(usuario Aaccedeadatosdeusuario B)-Bypassde</p>
<p>autenticación(accesosincredenciales)</p>
<p>Todo sin corrupción de memoria. Verificaciones faltantes, confusión de estado, manipulación de</p>
<p>parámetrosyfallasdegestióndesesiónsonpatronescomunes.</p>
<ol>
  <li>2.5. 1. 2.5 Escritura Arbitraria (Write-What-Where)</li>
</ol>
<p>Descripción General</p>
<p>Unaprimitivadeescrituraarbitrariapermitealatacanteescribirunvalorcontroladoaunadirección</p>
<p>controlada. Esta es una de las primitivas de explotación más poderosas, ya que permite modificar</p>
<p>cualquierubicacióndememoria.</p>
<p>Usos de Escritura Arbitraria:</p>
<p>┌─────────────────────────────────────────────────────────────┐</p>
<h2>│ PRIMITIVAS DE ESCRITURA ARBITRARIA │</h2>
<p>├─────────────────────────────────────────────────────────────┤</p>
<h2>│ 1. SOBRESCRIBIR CREDENCIALES │</h2>
<p>│ task_struct->cred->uid = 0 → Convertirse en root │</p>
<h2>│ 2. CORROMPER PUNTEROS DE FUNCIÓN │</h2>
<p>│ callback_ptr = &shellcode → Ejecución de código │</p>
<h2>│ 3. DESHABILITAR PROTECCIONES │</h2>
<p>│ security_callback = NULL → Bypass de seguridad │</p>
<h2>│ 4. MODIFICAR POLÍTICAS │</h2>
<p>│ selinux_enforcing = 0 → Deshabilitar SE Linux │</p>
<p>└─────────────────────────────────────────────────────────────┘</p>
<p>Caso de Estudio: CVE-2024-21338 — Windows App Locker Driver Arbitrary Function Call</p>
<p>Campo Detalle</p>
<p>Producto Afectado Windows App Lockerdriver(appid. sys)</p>
<p>Tipo Llamada Arbitrariaa Función→Escritura Arbitraria</p>
<p>Vector Local(serviciolocaloimpersonacióndeadmin)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Campo Detalle</p>
<p>Severidad Alta</p>
<p>Po C Disponible github. com/hakaioffsec/CVE-2024-21338</p>
<p>El Bug</p>
<p>El driver de Windows App Locker (appid. sys) contenía una vulnerabilidad en su manejador IOCTL</p>
<p>(código de control 0 x 22A018) que permitía a un atacante con privilegios de servicio local llamar</p>
<p>punteros de función del kernel arbitrarios con argumentos controlados. El IOCTL estaba diseñado</p>
<p>paraaceptarpunterosdefuncióndelkernelparaoperacionesdearchivosperopermanecíaaccesi-</p>
<p>bledesdeespaciodeusuariosinvalidaciónapropiada.</p>
<p>El Ataque (Paso a Paso)</p>
<ol>
  <li>Obtener Acceso:</li>
</ol>
<p>Atacanteimpersonalacuentadeserviciolocal</p>
<p>Otieneaccesoadminquepuedeimpersonar</p>
<ol>
  <li>Enviar IOCTL Malicioso:</li>
</ol>
<p>Enviarsolicitud IOCT Lespecialmentediseñadaa\Device\App Id</p>
<p>Incluirpunterosdefunciónmaliciososenelbúferdeentrada</p>
<ol>
  <li>Explotar Gadget:</li>
</ol>
<p>Escogerlafuncióngadgetcorrecta</p>
<p>Realizarcopiade 64 bitsadirecciónarbitrariadelkernel</p>
<p>Objetivo específico: Campo Previous Modeenestructura KTHREA Ddelhiloactual</p>
<ol>
  <li>Corrupción de Previous Mode:</li>
</ol>
<p>Corromper Previous Modea Kernel Mode(0)</p>
<p>Esto bypasea verificaciones de modo kernel en syscalls como Nt Read Virtual Memory y</p>
<p>Nt Write Virtual Memory</p>
<p>Otorgacapacidadesdelectura/escrituraarbitrariadelkerneldesdemodousuario</p>
<ol>
  <li>Post-Explotación:</li>
</ol>
<p>Realizarmanipulacióndirectadeobjetosdelkernel(DKOM)</p>
<p>Deshabilitarcallbacksdeseguridad</p>
<p>Cegartelemetría ETW</p>
<p>Suspenderprocesosdeseguridadprotegidospor PPL</p>
<p>Impacto</p>
<p>Estavulnerabilidadfueusadaporelsofisticadorootkit Fud Module para:-Escaladadeprivilegios</p>
<p>local de servicio local (o admin vía impersonación) a lectura/escritura arbitraria nivel kernel - Ata-</p>
<p>que de kernel verdaderamente fileless - sin necesidad de soltar o cargar drivers personalizados</p>
<p>- Manipulación directa de objetos del kernel (DKOM) - Deshabilitación de callbacks de seguridad -</p>
<p>Cegartelemetría ETW-Suspenderprocesosdeseguridadprotegidospor PPL</p>
<p>Por Qué Es Significativo:</p>
<p>Estorepresentaunaevoluciónsofisticadamásalládetécnicas BYOV Dtradicionales. Alexplotar</p>
<p>un zero-day en un driver incorporado de Windows, los atacantes lograron un ataque de kernel</p>
<p>verdaderamentefilelesssinnecesidaddesoltarocargardriverspersonalizados.</p>
<p>Mitigación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Microsoft lanzó parches en febrero 2024 (Patch Tuesday) que: - Añadieron verificación Ex Get Pre-</p>
<p>vious Mode al manejador IOCTL - Previenen que IOCT Ls iniciados desde modo usuario disparen la</p>
<p>invocacióndecallbackarbitrario</p>
<p>Observaciones</p>
<p>Laprimitivadeescrituraarbitraria(logradavíacorrupciónde Previous Mode)esunatécnicacanónica</p>
<p>para: - Voltear bits de privilegios - Sobrescribir punteros de función - Modificar datos de políticas</p>
<p>deseguridad</p>
<p>Estecasodemuestracómomanejadores IOCT Lconvalidacióndeentradainsuficientepuedenpro-</p>
<p>porcionarprimitivaspoderosasparaexplotacióndekernel, especialmentecuandoaceptanpunteros</p>
<p>defunciónopermitenconfusióndeobjetos.</p>
<ol>
  <li>2.6. 1. 2.6 Mal Uso de Locking/RCU</li>
</ol>
<p>Descripción General</p>
<p>Ordenamientodelocksincorrecto, locksfaltantesomalusode RCU(Read-Copy-Update)llevando</p>
<p>acarrerassobreobjetosliberados. Estosbugsocurrenencódigodelkernelconaltaconcurrencia.</p>
<p>Patrones Comunes:</p>
<ol>
  <li>Lock Faltante: Accesoadatoscompartidossinsincronización</li>
  <li>Ordenamiento de Locks Incorrecto: Deadlocksocarrerasporordeninconsistente</li>
  <li>Violaciones de RCU: Usarobjeto RCU-protegidofueradeseccióncrítica</li>
  <li>Liberación Prematura: Soltarlockantesdequeoperacióncomplete</li>
</ol>
<p>Caso de Estudio: CVE-2023-32629 — Linux Netfilter nf_tables Race Condition</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(nf_tables)</p>
<p>Tipo Condiciónde Carrerapor Locking Impropio→UAF</p>
<p>Vector Usernamespacesnoprivilegiados</p>
<p>Severidad Alta</p>
<p>Po C Disponible github. com/Thryn Sec/CVE-2023-32629-CVE-2023-</p>
<p>2640—POC-Escalation</p>
<p>El Bug</p>
<p>El subsistema nf_tables de netfilter del kernel Linux contenía una vulnerabilidad de condición de</p>
<p>carrera debido a bloqueo impropio al manejar operaciones batch. La vulnerabilidad ocurría en el</p>
<p>códigodemanejo detransacciones dondeelacceso concurrentea objetosde nf_tablesnoestaba</p>
<p>sincronizadoapropiadamente, permitiendocondicionesuse-after-free.</p>
<p>El Ataque:</p>
<p>Unatacanteconcapacidad CAP_NET_ADMIN(obtenibleatravésdeusernamespacesnoprivilegiados</p>
<p>enmuchasdistribuciones)podía:</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>Enviarmensajesnetlinkconcurrentesparamanipularreglasdenf_tables</li>
  <li>Cronometrarcuidadosamenteestasoperacionesatravésdemúltipleshilos</li>
  <li>Dispararunaventanadondeunhiloliberaunobjetomientrasotrohiloaúntieneunareferen-</li>
</ol>
<ol>
  <li>Explotarlacondiciónuse-after-freeparaescaladadeprivilegios</li>
</ol>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldeusuarionoprivilegiadoarootensistemasconusernamespa-</p>
<p>cesnoprivilegiadoshabilitados(defaulten Ubuntu, Debian, Fedorayotros)</p>
<p>La primitiva use-after-free podía explotarse para obtener capacidades de lectura/escritura</p>
<p>arbitrariadelkernel</p>
<p>Típicamenteusadaparamodificarcredencialesdeprocesoosobrescribirpunterosdefunción</p>
<p>delkernel</p>
<p>Afectókernels Linuxanterioresaversión 6. 3.1(mayo 2023)</p>
<p>Mitigación</p>
<p>Linux kernel 6. 3.1: - Añadió mecanismos de bloqueo apropiados alrededor del procesamiento de</p>
<p>transaccionesbatchdenf_tables-Implementóconteodereferenciaspararastreartiemposdevida</p>
<p>de objetos correctamente - Aseguró operaciones atómicas para acceso concurrente a estructuras</p>
<p>dedatoscompartidasdenetfilter</p>
<p>Observaciones</p>
<p>El mal uso de locking y RCU lleva a UAF reproducible y corrupción de memoria en rutas calientes</p>
<p>comosistemasdearchivos, networkingytimers. Elordenamientodelocksincorrecto, locksfaltantes</p>
<p>y violaciones de RCU son particularmente peligrosos en código del kernel donde la concurrencia</p>
<p>esomnipresente.</p>
<p>Elsubsistemanetfiltercontinúasiendounafuenterecurrentedetalesvulnerabilidadesdebidoasu</p>
<p>complejidadyusoextensivodeestructurasdedatosconcurrentes.</p>
<ol>
  <li>2.7. 1. 2.7 Conclusiones de Vulnerabilidades Lógicas</li>
</ol>
<p>Hallazgos Clave:</p>
<ol>
  <li>Las vulnerabilidades lógicas no requieren corrupción de memoria: Bypasses de autenti-</li>
</ol>
<p>cación, fallas TOCTOU y primitivas de escritura arbitraria pueden ser tan impactantes como</p>
<p>corrupcióndememoriatradicional.</p>
<ol>
  <li>Losbugsdeconcurrenciahabilitanexploitssofisticados: Double-fetch, condicionesdeca-</li>
</ol>
<p>rreraymalusodelockingsondifícilesdereproducirperoproporcionanexplotaciónconfiable</p>
<p>cuandoeltimingescontrolado.</p>
<ol>
  <li>La escritura arbitraria es la primitiva definitiva: Ya sea lograda a través de manejadores</li>
</ol>
<p>IOCTL, corrupciónde Previous Modeomalusode RCU, laescrituraarbitrariadelkernelhabilita</p>
<p>escaladadeprivilegios, deshabilitacióndecallbacksdeseguridadydesplieguederootkits.</p>
<ol>
  <li>Los user namespaces expanden la superficie de ataque: Muchas vulnerabilidades del ker-</li>
</ol>
<p>nel (netfilter, io_uring) se vuelven explotables desde contextos no privilegiados cuando user</p>
<p>namespacesotorgancapacidadescomo CAP_NET_ADMIN.</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>La defensa requiere operaciones atómicas: Las vulnerabilidades TOCTOU demuestran que</li>
</ol>
<p>lospatronescheck-then-usesoninherentementepropensosacarreras; operacionesatómicas</p>
<p>check-and-use, bloqueoapropiadoycopiadefensivasonesenciales.</p>
<p>Preguntasde Discusión:</p>
<ol>
  <li>¿Cómo difieren las vulnerabilidades double-fetch de las condiciones de carrera TOCTOU tra-</li>
</ol>
<p>dicionalesyquélashaceparticularmentepeligrosasencontextosdehypervisor?</p>
<ol>
  <li>Comparelacomplejidaddeexplotacióndefallaslógicasdeautenticaciónversuscondiciones</li>
</ol>
<p>decarreradelkernel.¿Cuálproporcionaexplotaciónmásconfiableyporqué?</p>
<ol>
  <li>¿Cómo difiere la primitiva de escritura arbitraria lograda en CVE-2024-21338 (vía corrupción</li>
</ol>
<p>de Previous Mode) de la escritura arbitraria tradicional basada en buffer overflow, y qué ven-</p>
<p>tajasproporcionaalosatacantes?</p>
<ol>
  <li>3. 1. 3 Confusión de Tipos y Enteros</li>
</ol>
<p>Las vulnerabilidades de confusión de tipos ocurren cuando un programa procesa un objeto como</p>
<p>untipodiferentealprevisto. Losbugsdeenterosincluyendesbordamiento, subdesbordamientoy</p>
<p>truncamiento.</p>
<ol>
  <li>3.1. 1. 3.1 Confusión de Tipos en JIT</li>
</ol>
<p>Descripción General</p>
<p>La confusión de tipos ocurre cuando un programa procesa un objeto como un tipo diferente al</p>
<p>previsto. Esto puede suceder en lenguajes de tipado dinámico, durante casts de tipo inseguros, o</p>
<p>encompiladores JI Tquehacensuposicionesincorrectassobretiposdeobjetos.</p>
<p>Caso de Estudio: CVE-2024-7971 — V8 Turbo Fan Type Confusion</p>
<p>Campo Detalle</p>
<p>Producto Afectado Google Chrome(V8Java Script Engine)</p>
<p>Tipo Type Confusionen JIT</p>
<p>Vector Páginawebmaliciosa</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>Laoptimizacióndeeliminación Check Boundsde Turbo Fanasumióincorrectamentetiposdeelemen-</p>
<p>tosdearraydurantelacompilación JIT. Alencontraruninlinecachepolimórfico, Turbo Fanaveces</p>
<p>confundíapunterostagged(objetos Heap)con SMI(Small Integers).</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigovíapáginawebmaliciosa</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Permitíacrear JS Arrayfalsoconpunterodebackingstorecontrolado</p>
<p>Capacidadesdelectura/escriturafueradelímites</p>
<p>Escapedelsandbox V8 paraejecucióndeshellcode</p>
<p>Contexto de Explotación</p>
<p>La confusión de tipos permitía construir primitivas de explotación: - addrof: Filtrar direcciones de</p>
<p>objetos (fuga de información para bypass de ASLR) - fakeobj: Crear objetos falsos con estructura</p>
<p>controlada-lectura/escrituraarbitraria: Accesofueradelímitesacualquierubicacióndememoria</p>
<p>Mitigación</p>
<p>V8 parcheólalógicadeeliminación Check Boundspararastrearcorrectamenteinformacióndetipos</p>
<p>durantepasesdeoptimización.</p>
<p>Observaciones</p>
<p>Laexplotacióndenavegadoresesunobjetivodealtovalor. Laconfusióndetiposencompiladores</p>
<p>JI Tesunaclasedevulnerabilidadcomún, connuevasvariantesdescubiertasregularmente.</p>
<ol>
  <li>3.2. 1. 3.2 Desbordamiento de Enteros</li>
</ol>
<p>Descripción General</p>
<p>Losbugsdeenterosincluyen:-Desbordamiento: Excedervalormáximo(ej. INT_MAX + 1 envuelvea</p>
<p>INT_MIN)-Subdesbordamiento: Irpordebajodelvalormínimo(ej. 0 - 1 seconvierteen UINT_MAX</p>
<p>paraunsigned)-Truncamiento: Perderdatosalconvertirdetipomayoramenor</p>
<p>Los bugs de enteros frecuentemente llevan a corrupción de memoria porque los enteros se usan</p>
<p>paratamañosdebúfer, contadoresdebucleeíndicesdearray.</p>
<p>Caso de Estudio: CVE-2024-38063 — Windows TCP/IP Integer Underflow RCE</p>
<p>Campo Detalle</p>
<p>Producto Afectado Windows TCP/IP Stack(tcpip. sys)</p>
<p>Tipo Integer Underflow→RCE</p>
<p>Vector Paquetes I Pv 6 dered</p>
<p>Severidad Crítica(CVSS9. 8)</p>
<p>El Bug</p>
<p>Lapila TCP/I Pde Windowsconteníaunavulnerabilidadcríticadesubdesbordamientodeenterosen</p>
<p>sucódigodeprocesamientodepaquetes I Pv 6. Almanejarpaquetes I Pv 6 especialmentediseñados</p>
<p>concabeceras de extensión malformadas, el driver tcpip. sys realizaba operaciones aritméticas que</p>
<p>podíanresultarenunsubdesbordamientodeenteros.</p>
<p>Impacto</p>
<p>Ejecución Remotade Códigoconprivilegios SYSTE Mensistemas Windowsafectados</p>
<p>CVSS Score:9. 8(Crítico)</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>AfectóWindows 10, Windows 11 y Windows Serverversionesdesde 2008 hasta 2022</p>
<p>Potencialmentewormeable(podíapropagarseautomáticamentecomo SMB Ghost)</p>
<p>Contexto de Explotación</p>
<ol>
  <li>Paquetes I Pv 6 conconfiguracionesespecíficasdecabecerasdeextensión</li>
  <li>Dispararelsubdesbordamientoencálculosdetamaño</li>
  <li>Elvalorsubdesbordadoenvuelveaunenterounsignedgrande</li>
  <li>Elkernelasignabúferpequeñobasadoenelvalorenvuelto</li>
  <li>Operación de copia subsecuente usa tamaño grande original, causando desbordamiento de</li>
</ol>
<p>heap</p>
<ol>
  <li>Eldesbordamientodeheapllevaacorrupcióndememoriadelkernely RCE</li>
</ol>
<p>Mitigación</p>
<p>Microsoftlanzóparchesenagosto 2024 queañadieronverificaciónapropiadadelímitesalprocesa-</p>
<p>mientodepaquetes I Pv 6 ycorrigieronoperacionesaritméticasdeenterosparaprevenircondiciones</p>
<p>desubdesbordamiento.</p>
<p>Observaciones</p>
<p>Esta vulnerabilidad demuestra cómo el subdesbordamiento de enteros en parsers de protocolos</p>
<p>de red puede llevar a vulnerabilidades de RCE críticas. El bug afectaba código de red fundamental</p>
<p>que procesa entrada de red no confiable, haciéndolo objetivo principal para exploits wormables</p>
<p>similaresa SMB Ghosty Eternal Blue.</p>
<ol>
  <li>3.3. 1. 3.3 Vulnerabilidades de Parsers</li>
</ol>
<p>Descripción General</p>
<p>Los parsers convierten datos estructurados (archivos, protocolos de red, etc.) en representaciones</p>
<p>internasdelprograma. Sucomplejidadloshaceobjetivosprincipalesparafuzzingyexplotación.</p>
<p>Caso de Estudio: CVE-2024-47606 — G Streamer Signed-to-Unsigned Integer Underflow</p>
<p>Campo Detalle</p>
<p>Producto Afectado G Streamermultimediaframework</p>
<p>Tipo Conversión Signed-to-Unsigned→RCE</p>
<p>Vector Archivomultimediamalicioso</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>G Streamer contenía una vulnerabilidad de conversión de entero signed a unsigned en la función</p>
<p>qtdemux_parse_theora_extension. Una variable de tamaño gint (entero signed) subdesbordaba</p>
<p>a un valor negativo, que luego era implícitamente convertido a un entero unsigned de 64 bits,</p>
<p>convirtiéndoseenunvalormasivo.</p>
<p>Impacto</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Ejecuciónremotadecódigoalprocesararchivosmultimediamaliciosos</p>
<p>G Streameresusadoporinnumerablesaplicaciones(GNOME, KDE, Firefox, Chrome, derivados</p>
<p>de VLC)</p>
<p>Losarchivosmultimediasoncomúnmentecompartidosyprocesadosautomáticamente</p>
<p>Afectatantosistemasdeescritoriocomoembebidos</p>
<p>Contexto de Explotación</p>
<ol>
  <li>Archivomultimediamaliciosocontieneextensión Theoraconcamposdetamañodiseñados</li>
  <li>Lafuncióncalculatamañousandoaritméticasigned</li>
  <li>Elcálculosubdesborda(ej.-6 o 0 x FFFFFFF Aenrepresentaciónde 32 bits)</li>
  <li>Valornegativode 32 bitsesconvertidoaunsignedde 64 bits→valormasivo</li>
  <li>Soloseasignanbytespequeñosapesardeltamañoenormesolicitado</li>
  <li>memcpysubsecuentecopiadatosgrandesenbúferpequeño</li>
  <li>Desbordamientodebúfercorrompeestructura Gst Map Info</li>
  <li>Secuestrodepunterodefunciónlogra RCE</li>
</ol>
<p>Mitigación</p>
<p>G Streamer 1. 24. 10 (diciembre 2024) corrigió la vulnerabilidad añadiendo verificaciones explícitas</p>
<p>paravaloresnegativosantesdeconvertirsignedaunsignedyusandoaritméticadeenterossegura.</p>
<p>Observaciones</p>
<p>Este es un ejemplo de libro de texto de vulnerabilidades de conversión signed-to-unsigned (CWE-</p>
<p>195). En C/C++, lasconversionesimplícitasentreenterossignedyunsignedsiguenreglascomplejas</p>
<p>quelosdesarrolladoresfrecuentementemalinterpretan. Losenterossignednegativosseconvierten</p>
<p>envaloresunsignedpositivosenormescuandosonconvertidos.</p>
<p>Caso de Estudio: CVE-2024-27316 — nghttp 2 HTTP/2 CONTINUATION Frame Do S</p>
<p>Campo Detalle</p>
<p>Producto Afectado nghttp 2HTTP/2 library</p>
<p>Tipo Agotamientode Recursos→Do S</p>
<p>Vector Conexión HTTP/2 dered</p>
<p>Severidad Alta(CVSS7. 5)</p>
<p>El Bug</p>
<p>La biblioteca nghttp 2 HTTP/2 (usada por Apache httpd, nginx y muchos otros servidores) conte-</p>
<p>nía una vulnerabilidad en su manejo de frames CONTINUATION. La biblioteca fallaba en limitar el</p>
<p>tamañototalacumuladodedatosdecabeceraatravésdeframes CONTINUATION.</p>
<p>Impacto</p>
<p>Denegaciónde Serviciovíaagotamientodememoria</p>
<p>Unaúnicaconexión TC Ppodíaagotargigabytesdememoriadelservidor</p>
<p>Muybajoanchodebandarequeridodelatacante</p>
<p>Afectónghttp 2, Apache HTTP Server, nginxyotros</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Contexto de Explotación</p>
<p>Unatacantepodíaestablecerunaconexión HTTP/2 yejecutar:1. Enviarframe HEADER Sválidopara</p>
<p>iniciarnuevostream 2. Enviarframes CONTINUATIO Ncontinuossinestablecerflag END_HEADERS</p>
<ol>
  <li>Cada frame CONTINUATION añade datos al búfer de cabecera acumulado 4. El servidor asigna</li>
</ol>
<p>másmemoriaporcadaframerecibido 5. Elprocesoserepitehastaquelamemoriadelservidorse</p>
<p>agota</p>
<p>Mitigación</p>
<p>nghttp 2 v 1. 61. 0 (abril 2024) añadió límite NGHTTP2_DEFAULT_MAX_HEADER_LIST_SIZE (64KB por de-</p>
<p>fecto) para el tamaño total acumulado de cabeceras. Apache httpd 2. 4.59 implementó directiva</p>
<p>H2Max Header List Size.</p>
<p>Observaciones</p>
<p>Esta vulnerabilidad demuestra que los parsers deben rastrear el consumo de recursos a través de</p>
<p>operaciones relacionadas, no solo operaciones individuales. El ataque es particularmente efectivo</p>
<p>porqueexplotaelmecanismolegítimodelprotocolo.</p>
<ol>
  <li>4. 1. 4 Vulnerabilidades de Strings y Formato</li>
</ol>
<p>Las vulnerabilidades de format string ocurren cuando datos controlados por el usuario se pasan</p>
<p>comoargumentodeformatstringafuncionescomoprintf, sprintfysimilares.</p>
<p>Caso de Estudio: CVE-2023-35086 — ASUS Router Format String RCE</p>
<p>Campo Detalle</p>
<p>Producto Afectado ASUSRT-AX56UV2 y RT-AC86Urouters</p>
<p>Tipo Format String→RCE</p>
<p>Vector Interfazwebdeadministración</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>Los routers ASUS contenían una vulnerabilidad de format string en su interfaz de administración</p>
<p>web(demoniohttpd). Lafunciónlogmessage_normaldelmódulodo_detwan_cgiusabadirectamen-</p>
<p>teentradacontroladaporelusuariocomoformatstringalllamarasyslog ().</p>
<p>Impacto</p>
<p>Ejecuciónremotadecódigoconprivilegiosroot</p>
<p>Permitíafugadeinformaciónparabypassde ASLR</p>
<p>Habilitabaescrituraarbitrariadememoriavíadirectiva% n</p>
<p>Compromisocompletodeldispositivodered</p>
<p>Contexto de Explotación</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Etapa 1-Fugade Información:-Atacanteenvíasolicitud HTT Pconformatstring:% p.% p.% p.% p-</p>
<p>Routerregistraestoasyslog, filtrandodireccionesdepila-Lasdirectivas% prevelanlayoutdepila</p>
<p>yderrotan ASLR</p>
<p>Etapa 2 - Escritura Arbitraria: - Atacante diseña format string con directiva% n - Sobreescribe</p>
<p>puntero de función o dirección de retorno en pila - Redirige ejecución a shellcode controlado por</p>
<p>atacante-Resultado: Ejecución Remotade Códigoconprivilegiosroot</p>
<p>Mitigación</p>
<p>Actualizacionesdefirmware ASU Scambiaron:</p>
<p>// Vulnerable:</p>
<p>syslog (LOG_INFO, user_input);</p>
<p>// Corregido:</p>
<p>syslog (LOG_INFO, "% s", user_input);</p>
<p>Adicionalmente implementaron validación de entrada y habilitaron advertencias de compilador -</p>
<p>Wformat-security.</p>
<p>Observaciones</p>
<p>Las vulnerabilidades de format string en dispositivos embebidos y routers son particularmente pe-</p>
<p>ligrosas porque los dispositivos frecuentemente ejecutan firmware desactualizado, muchos están</p>
<p>expuestosa Internet, yelcompromisoproporcionaaccesopersistentearedes.</p>
<ol>
  <li>5. 1. 5 Vulnerabilidades de Drivers y Sistemas de Archivos</li>
</ol>
<p>Los drivers y sistemas de archivos representan una superficie de ataque masiva debido a sus inter-</p>
<p>facescomplejasconelkernelyelmanejodeentradanoconfiable.</p>
<ol>
  <li>5.1. Vulnerabilidades de Manejadores IOCTL/Syscall</li>
</ol>
<p>Caso de Estudio: CVE-2023-21768 — Windows AFD. sys Buffer Size Confusion</p>
<p>Campo Detalle</p>
<p>Producto Afectado Windows AFD. sys(Ancillary Function Driver)</p>
<p>Tipo Confusiónde Tamañode Búfer</p>
<p>Vector Local</p>
<p>Severidad Alta</p>
<p>El Bug</p>
<p>El Windows Ancillary Function Driver (AFD. sys), que maneja operaciones de socket, tenía una</p>
<p>vulnerabilidad de confusión de tamaño de búfer en su manejador IOCTL. Al procesar solicitudes</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>IOCTL_AFD_SELECT, eldriverfallabaenvalidarapropiadamentelarelaciónentreeltamañodebúfer</p>
<p>proporcionadoporelusuarioyeltamañorealdelaestructura.</p>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldeusuarioestándara SYSTEM</p>
<p>La primitiva de escritura OOB se usaba para corromper objetos del kernel adyacentes en el</p>
<p>pool</p>
<p>Explotadoenelwildantesdelparcheo</p>
<p>Contexto de Explotación</p>
<p>Un atacante podía llamar a Device Io Control () con un búfer de entrada especialmente diseñado</p>
<p>donde el tamaño declarado no coincidía con el tamaño real de datos. El driver asignaba un búfer</p>
<p>basadoenunvalordetamañoperocopiabadatosbasadoenotro.</p>
<p>Mitigación</p>
<p>Microsoft KB5022845 añadió validación estricta asegurando que la longitud proporcionada por el</p>
<p>usuario coincidiera con el tamaño de estructura esperado, usóProbe For Read () para validar punte-</p>
<p>rosdeusuario, eimplementóverificaciónadicionaldelímites.</p>
<p>Observaciones</p>
<p>Los manejadores IOCTL/syscall son vectores de ataque comunes debido a confusión de tama-</p>
<p>ño/límites, confianzaenpunterosdeusuariosinprobing, yproblemasdedouble-fetch.</p>
<ol>
  <li>5.2. Vulnerabilidades de Sistemas de Archivos</li>
</ol>
<p>Caso de Estudio: CVE-2022-0847 — Dirty Pipe</p>
<p>Campo Detalle</p>
<p>Producto Afectado Linux Kernel(implementacióndepipes)</p>
<p>Tipo Falla Lógica→Escritura Arbitrariade Archivos</p>
<p>Vector Local</p>
<p>Severidad Crítica</p>
<p>El Bug</p>
<p>La implementación de pipes del kernel Linux fallaba en inicializar apropiadamente el flag PI-</p>
<p>PE_BUF_FLAG_CAN_MERG Ealhacersplicedepáginasdelacachédepáginashaciapipes. Estopermitía</p>
<p>sobreescribirdatosenarchivosdesololecturahaciendosplicedepáginasmodificadasdevuelta.</p>
<p>Impacto</p>
<p>Escaladadeprivilegioslocaldecualquierusuarioarootsobreescribiendo/etc/passwduotros</p>
<p>archivosprivilegiados</p>
<p>Explotaciónextremadamenteconfiablerequiriendopermisosmínimos</p>
<p>Afectókernels Linux 5. 8+hasta 5. 16. 11</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Contexto de Explotación</p>
<p>Unatacantepodía:1. Abrirunarchivodesololectura(ej./etc/passwd)2. Usarsplice () paracrear</p>
<p>unpipeconteniendopáginasdeesearchivo 3. Modificarelbúferdelpipe 4. Hacersplicedevuelta</p>
<p>parasobreescribircontenidosdelarchivooriginal</p>
<p>Mitigación</p>
<p>Linux kernel 5. 16. 11+ inicializa apropiadamente los flags de búfer de pipe y previene el splice de</p>
<p>vueltaaarchivosdesololectura.</p>
<p>Observaciones</p>
<p>Las operaciones de pipe y splice son mecanismos complejos del kernel con requisitos sutiles de</p>
<p>gestión de estado. Dirty Pipe demostró cómo bugs de inicialización pueden llevar a primitivas po-</p>
<p>derosasdeescrituraarbitrariadearchivos.</p>
<ol>
  <li>5.3. Bring Your Own Vulnerable Driver (BYOVD)</li>
</ol>
<p>Caso de Estudio: Abuso de Drivers por Lazarus Group</p>
<p>Campo Detalle</p>
<p>Técnica BYOVD(Bring Your Own Vulnerable Driver)</p>
<p>Tipo Abusode Driver Legítimo</p>
<p>Vector Driverfirmadovulnerable</p>
<p>Uso Gruposdeamenazasavanzados</p>
<p>La Técnica</p>
<p>Losatacantesdejancaerundriverlegítimoperovulnerablefirmado(ej. versionesantiguasdedrivers</p>
<p>ASUS, Gigabyteo MSI)que Windowscargarádebidoasufirmaválida.</p>
<p>Impacto</p>
<p>Unavezcargado, eldrivervulnerableproporcionaprimitivasdelectura/escrituraarbitrariadel</p>
<p>kernelatravésdesuinterfaz IOCTL</p>
<p>Losatacantesusanestoparadeshabilitarcaracterísticasdeseguridad(Patch Guard, AV/EDR)</p>
<p>Permitecargardriversnofirmadosoescalarprivilegios</p>
<p>Contexto de Explotación</p>
<p>Latécnica BYOV Dfueampliamenteusadaporgruposcomo Lazarusantesdeque Microsoftexpan-</p>
<p>dierala Driver Blocklist. Gruposavanzadoshancambiadode BYOV Daexploitsdirectosdezero-day</p>
<p>delkerneldespuésde 2023 debidoalaumentodedetección.</p>
<p>Mitigación</p>
<p>Habilitar Vulnerable Driver Blocklist(HVCI/Memory Integrity)</p>
<p>Monitorearcargasdedriversinusuales</p>
<p>Implementarpolíticasdecontroldeaplicaciones</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<p>Observaciones</p>
<p>Mientrasnoesunavulnerabilidadperse, BYOV Desampliamenteusadoencadenasdeexplotación</p>
<p>yrepresentaunriesgosignificativodeabusodedriverslegítimosfirmados.</p>
<ol>
  <li>6. 1. 6 Evaluación de Impacto y Clasificación</li>
</ol>
<p>Comprendercómoevaluaryclasificarvulnerabilidadesporsuimpactorealyexplotabilidadesfun-</p>
<p>damentalparalapriorizacióndeparchesyrespuestaaincidentes.</p>
<ol>
  <li>6.1. Categorías de Impacto</li>
</ol>
<p>Ejecución Remotade Código(RCE)-Definición: Atacantepuedeejecutarcódigoarbitrarioenel</p>
<p>sistema objetivo remotamente - Impacto: Máxima severidad - compromiso completo del sistema</p>
<p>posible - Ejemplos: CVE-2024-27130 (QNAP), CVE-2024-2883 (Chrome ANGLE), CVE-2023-4863</p>
<p>(lib Web P)</p>
<p>Escalada de Privilegios Local (LPE) - Definición: Atacante con acceso limitado puede obtener</p>
<p>privilegios más altos - Impacto: Alta severidad - permite persistencia, evasión de defensas, movi-</p>
<p>mientolateral-Ejemplos: CVE-2024-26218(Windows Kernel TOCTOU), CVE-2022-0847(Dirty Pipe)</p>
<p>Divulgación de Información - Definición: Atacante puede leer datos a los que no debería tener</p>
<p>acceso-Impacto: Mediaa Alta-frecuentementeencadenadaconotrosbugsparabypassde ASLR</p>
<p>-Ejemplos: Fugasdeformatstring, lecturasdememorianoinicializada</p>
<p>Denegación de Servicio (Do S) - Definición: Atacante puede hacer un servicio no disponible sin</p>
<p>ganar ejecución de código - Impacto: Baja a Media - interrumpe disponibilidad sin comprometer</p>
<p>confidencialidad/integridad - Ejemplos: CVE-2024-27316 (HTTP/2 CONTINUATION), bombas de</p>
<p>descompresión</p>
<ol>
  <li>6.2. Factores de Explotabilidad</li>
</ol>
<p>Factor Bajo Alto</p>
<p>Complejidad de Ataque Requierepreparación Explotablerepetidamente</p>
<p>compleja conmínimoesfuerzo</p>
<p>Vector de Ataque Requiereaccesofísico Explotableremotamente</p>
<p>sobrered</p>
<p>Privilegios Requeridos Requiereacceso Sinautenticaciónnecesaria</p>
<p>administrativo</p>
<p>Interacciónde Usuario Víctimadeberealizaracción Completamente</p>
<p>automatizado</p>
<p>CAPÍTULO2. CLASESDEVULNERABILIDADES Bitácora Red Team</p>
<ol>
  <li>6.3. Sistema de Puntuación CVSS</li>
</ol>
<p>Componentesdel Score Base(Cualidades Intrínsecas):-Vectorde Ataque(AV): Red/Adyacente/Local/Físico</p>
<p>-Complejidad de Ataque (AC): Baja/Alta-Privilegios Requeridos (PR): Ninguno/Bajo/Alto-In-</p>
<p>teracciónde Usuario(UI): Ninguna/Requerida-Alcance(S): Sin Cambio/Con Cambio-Impacto</p>
<p>a Confidencialidad(C), Integridad(I), Disponibilidad(A): Ninguno/Bajo/Alto</p>
<p>Rangos de Score: | Rango | Severidad | |——-|———–| | 0. 0 | Ninguna | | 0. 1-3. 9 | Baja | | 4. 0-6. 9 |</p>
<p>Media||7. 0-8. 9|Alta||9. 0-10. 0|Crítica|</p>
<ol>
  <li>6.4. Conclusiones del <a href="01-introduccion.html">Capítulo 1</a></li>
  <li>La corrupción de memoria sigue siendo prevalente: A pesar de décadas de investigación,</li>
</ol>
<p>los bugs de corrupción de memoria continúan afectando software, especialmente en bases</p>
<p>decódigo C/C++.</p>
<ol>
  <li>La defensa en profundidad es esencial: Cada ejemplo real muestra atacantes evadiendo</li>
</ol>
<p>múltiplesmecanismosdeprotección(DEP, ASLR, CET, safe-linking).</p>
<ol>
  <li>Las mitigaciones modernas elevan la barrera pero no eliminan el riesgo: Mientras tec-</li>
</ol>
<p>nologías como CET shadow stack y safe-linking hacen la explotación más difícil, atacantes</p>
<p>determinadoscontinúanencontrandobypasses.</p>
<ol>
  <li>Lascausasraízsonsimilares, peroloscontextosdifieren: Bugsdestack, heapy UA Fcom-</li>
</ol>
<p>parten causas raíz comunes (verificación inadecuada de límites, gestión de tiempo de vida)</p>
<p>perorequierendiferentestécnicasdeexplotación.</p>
<ol>
  <li>Loscomponenteslegacypermanecenvulnerables: Vulnerabilidadesdeañosdeantigüedad</li>
</ol>
<p>en parsers de office y manejadores de archivos continúan siendo explotadas debido a ciclos</p>
<p>deparcheolentos.</p>
<ol>
  <li>Lasvulnerabilidadeslógicasnorequierencorrupcióndememoria: Bypassesdeautentica-</li>
</ol>
<p>ción, fallas TOCTO Uyprimitivasdeescrituraarbitrariapuedenserigualmenteimpactantes.</p>
<ol>
  <li>User namespaces expanden la superficie de ataque: Muchas vulnerabilidades del kernel</li>
</ol>
<p>se vuelven explotables desde contextos no privilegiados cuando user namespaces otorgan</p>
<p>capacidadescomo CAP_NET_ADMIN.</p>
<p><a href="03-fuzzing.html">Capítulo 3</a></p>
<p>Fuzzing</p>
<p>El fuzzing es una técnica automatizada de descubrimiento de vulnerabilidades que ha encontrado</p>
<p>milesdebugsdeseguridadcríticosensoftwaredeproducción. Estecapítulocubrelosfundamentos</p>
<p>delfuzzing, herramientasclaveymetodologíasparaencontrarvulnerabilidades.</p>
<ol>
  <li>1. 2. 1 Fundamentos de Fuzzing</li>
</ol>
<p>Qué es el Fuzzing</p>
<p>Elfuzzingesunatécnicadepruebadesoftwarequeinvolucraproporcionardatosinválidos, inespe-</p>
<p>radosoaleatorioscomoentradaaunprograma. Elobjetivoesencontrarcrashes, assertionsfallidos,</p>
<p>fugas de memoria y otros comportamientos anómalos que puedan indicar vulnerabilidades de se-</p>
<p>guridad.</p>
<p>Por Qué el Fuzzing es Efectivo</p>
<p>Automatización: Puedeprobarmillonesdeentradasporhora</p>
<p>Cobertura: Exploracasosextremosquelaspruebasmanualesnuncaalcanzarían</p>
<p>Reproducibilidad: Lasentradasquecausancrashesseguardanparaanálisis</p>
<p>Escalabilidad: Puedeejecutarsecontinuamentedurantedías/semanas</p>
<p>Tipos de Fuzzing</p>
<p>Tipo Descripción Ejemplo</p>
<p>Caja Negra Sinconocimientodelcódigointerno Mutaciónaleatoriade</p>
<p>entradas</p>
<p>Caja Blanca Conocimientocompletodelcódigo Ejecuciónsimbólica</p>
<p>Caja Gris Instrumentacióndecobertura AFL++, lib Fuzzer</p>
<p>Guiado por Midequécódigoseejecuta AFL++, Honggfuzz</p>
<p>Cobertura</p>
<p>Guiado por Conocelaestructuradelformato Syzkaller(syscalls)</p>
<p>Gramática</p>
            </div>
            
            <div class="page-nav">
                <a href="01-introduccion.html"><i class="fas fa-arrow-left"></i> Capítulo 01: Introducción</a>
                <a href="03-fuzzing.html">Capítulo 03: Fuzzing <i class="fas fa-arrow-right"></i></a>
            </div>
        </main>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
        
        const currentPath = window.location.pathname;
        const fileName = currentPath.split('/').pop().replace('.html', '');
        
        document.querySelectorAll('.nav-item').forEach(item => {
            const href = item.getAttribute('href');
            if (href && href.replace('.html', '') === fileName) {
                item.classList.add('active');
            }
        });
    </script>
</body>
</html>